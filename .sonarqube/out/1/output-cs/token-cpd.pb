щ
ЈC:\Users\Davis\Desktop\Facultad\5to Periodo\Tecnologias\Pacman\ClientePacman\Packages\com.unity.2d.tilemap.extras\Editor\Brushes\CoordinateBrush\CoordinateBrush.cs
	namespace 	
UnityEditor
 
. 
Tilemaps 
{ 
[		 
CustomGridBrush		 
(		 
true		 
,		 
false		  
,		  !
false		" '
,		' (
$str		) ;
)		; <
]		< =
[

 
CreateAssetMenu

 
(

 
fileName

 
=

 
$str

  6
,

6 7
menuName

8 @
=

A B
$str

C ]
)

] ^
]

^ _
public 

class 
CoordinateBrush  
:! "
	GridBrush# ,
{ 
} 
[ 
CustomEditor 
( 
typeof 
( 
CoordinateBrush (
)( )
)) *
]* +
public 

class !
CoordinateBrushEditor &
:' (
GridBrushEditor) 8
{ 
public 
override 
void 
OnPaintSceneGUI ,
(, -

GridLayout- 7
grid8 <
,< =

GameObject> H
brushTargetI T
,T U
	BoundsIntV _
position` h
,h i
GridBrushBasej w
.w x
Toolx |
tool	} Ѓ
,
Ѓ ‚
bool
ѓ ‡
	executing
€ ‘
)
‘ ’
{ 	
base   
.   
OnPaintSceneGUI    
(    !
grid  ! %
,  % &
brushTarget  ' 2
,  2 3
position  4 <
,  < =
tool  > B
,  B C
	executing  D M
)  M N
;  N O
var"" 
	labelText"" 
="" 
$str"" #
+""$ %
position""& .
."". /
position""/ 7
;""7 8
if## 
(## 
position## 
.## 
size## 
.## 
x## 
>##  !
$num##" #
||##$ &
position##' /
.##/ 0
size##0 4
.##4 5
y##5 6
>##7 8
$num##9 :
)##: ;
{##< =
	labelText$$ 
+=$$ 
$str$$ &
+$$' (
position$$) 1
.$$1 2
size$$2 6
;$$6 7
}%% 
Handles'' 
.'' 
Label'' 
('' 
grid'' 
.'' 
CellToWorld'' *
(''* +
position''+ 3
.''3 4
position''4 <
)''< =
,''= >
	labelText''? H
)''H I
;''I J
}(( 	
})) 
}** жР
ЈC:\Users\Davis\Desktop\Facultad\5to Periodo\Tecnologias\Pacman\ClientePacman\Packages\com.unity.2d.tilemap.extras\Editor\Brushes\GameObjectBrush\GameObjectBrush.cs
	namespace 	
UnityEditor
 
. 
Tilemaps 
{ 
[ 
CustomGridBrush 
( 
true 
, 
false  
,  !
false" '
,' (
$str) ;
); <
]< =
public 

class 
GameObjectBrush  
:! "
GridBrushBase# 0
{ 
[ 	
SerializeField	 
] 
[ 	
HideInInspector	 
] 
private 
	BrushCell 
[ 
] 
m_Cells #
;# $
[ 	
SerializeField	 
] 
[ 	
HideInInspector	 
] 
private 

Vector3Int 
m_Size !
;! "
[ 	
SerializeField	 
] 
[ 	
HideInInspector	 
] 
private 

Vector3Int 
m_Pivot "
;" #
[ 	
SerializeField	 
] 
[ 	
HideInInspector	 
] 
private 
bool  
m_CanChangeZPosition )
;) *
public!! 
Vector3!! 
m_Anchor!! 
=!!  !
new!!" %
Vector3!!& -
(!!- .
$num!!. 2
,!!2 3
$num!!4 8
,!!8 9
$num!!: >
)!!> ?
;!!? @
public$$ 

Vector3Int$$ 
size$$ 
{$$  
get$$! $
{$$% &
return$$' -
m_Size$$. 4
;$$4 5
}$$6 7
set$$8 ;
{$$< =
m_Size$$> D
=$$E F
value$$G L
;$$L M
SizeUpdated$$N Y
($$Y Z
)$$Z [
;$$[ \
}$$] ^
}$$_ `
public&& 

Vector3Int&& 
pivot&& 
{&&  !
get&&" %
{&&& '
return&&( .
m_Pivot&&/ 6
;&&6 7
}&&8 9
set&&: =
{&&> ?
m_Pivot&&@ G
=&&H I
value&&J O
;&&O P
}&&Q R
}&&S T
public(( 
	BrushCell(( 
[(( 
](( 
cells((  
{((! "
get((# &
{((' (
return(() /
m_Cells((0 7
;((7 8
}((9 :
}((; <
public** 
int** 
	cellCount** 
{** 
get** "
{**# $
return**% +
m_Cells**, 3
!=**4 6
null**7 ;
?**< =
m_Cells**> E
.**E F
Length**F L
:**M N
$num**O P
;**P Q
}**R S
}**T U
public,, 
bool,, 
canChangeZPosition,, &
{-- 	
get.. 
{.. 
return..  
m_CanChangeZPosition.. -
;..- .
}../ 0
set// 
{//  
m_CanChangeZPosition// &
=//' (
value//) .
;//. /
}//0 1
}00 	
public55 
GameObjectBrush55 
(55 
)55  
{66 	
Init77 
(77 

Vector3Int77 
.77 
one77 
,77  

Vector3Int77! +
.77+ ,
zero77, 0
)770 1
;771 2
SizeUpdated88 
(88 
)88 
;88 
}99 	
public?? 
void?? 
Init?? 
(?? 

Vector3Int?? #
size??$ (
)??( )
{@@ 	
InitAA 
(AA 
sizeAA 
,AA 

Vector3IntAA !
.AA! "
zeroAA" &
)AA& '
;AA' (
SizeUpdatedBB 
(BB 
)BB 
;BB 
}CC 	
publicHH 
voidHH 
InitHH 
(HH 

Vector3IntHH #
sizeHH$ (
,HH( )

Vector3IntHH* 4
pivotHH5 :
)HH: ;
{II 	
m_SizeJJ 
=JJ 
sizeJJ 
;JJ 
m_PivotKK 
=KK 
pivotKK 
;KK 
SizeUpdatedLL 
(LL 
)LL 
;LL 
}MM 	
publicVV 
overrideVV 
voidVV 
PaintVV "
(VV" #

GridLayoutVV# -

gridLayoutVV. 8
,VV8 9

GameObjectVV: D
brushTargetVVE P
,VVP Q

Vector3IntVVR \
positionVV] e
)VVe f
{WW 	
ifYY 
(YY 
brushTargetYY 
.YY 
layerYY !
==YY" $
$numYY% '
)YY' (
returnZZ 
;ZZ 

Vector3Int\\ 
min\\ 
=\\ 
position\\ %
-\\& '
pivot\\( -
;\\- .
	BoundsInt]] 
bounds]] 
=]] 
new]] "
	BoundsInt]]# ,
(]], -
min]]- 0
,]]0 1
m_Size]]2 8
)]]8 9
;]]9 :
BoxFill^^ 
(^^ 

gridLayout^^ 
,^^ 
brushTarget^^  +
,^^+ ,
bounds^^- 3
)^^3 4
;^^4 5
}__ 	
privateaa 
voidaa 
	PaintCellaa 
(aa 

GridLayoutaa )
gridaa* .
,aa. /

Vector3Intaa0 :
positionaa; C
,aaC D
	TransformaaE N
parentaaO U
,aaU V
	BrushCellaaW `
cellaaa e
)aae f
{bb 	
ifcc 
(cc 
cellcc 
.cc 

gameObjectcc 
!=cc  "
nullcc# '
)cc' (
{dd 
SetSceneCellee 
(ee 
gridee !
,ee! "
parentee# )
,ee) *
positionee+ 3
,ee3 4
cellee5 9
.ee9 :

gameObjectee: D
,eeD E
celleeF J
.eeJ K
offseteeK Q
,eeQ R
celleeS W
.eeW X
scaleeeX ]
,ee] ^
cellee_ c
.eec d
orientationeed o
,eeo p
m_Anchoreeq y
)eey z
;eez {
}ff 
}gg 	
publicpp 
overridepp 
voidpp 
Erasepp "
(pp" #

GridLayoutpp# -

gridLayoutpp. 8
,pp8 9

GameObjectpp: D
brushTargetppE P
,ppP Q

Vector3IntppR \
positionpp] e
)ppe f
{qq 	
ifss 
(ss 
brushTargetss 
.ss 
layerss !
==ss" $
$numss% '
)ss' (
returntt 
;tt 

Vector3Intvv 
minvv 
=vv 
positionvv %
-vv& '
pivotvv( -
;vv- .
	BoundsIntww 
boundsww 
=ww 
newww "
	BoundsIntww# ,
(ww, -
minww- 0
,ww0 1
m_Sizeww2 8
)ww8 9
;ww9 :
BoxErasexx 
(xx 

gridLayoutxx 
,xx  
brushTargetxx! ,
,xx, -
boundsxx. 4
)xx4 5
;xx5 6
}yy 	
private{{ 
void{{ 
	EraseCell{{ 
({{ 

GridLayout{{ )
grid{{* .
,{{. /

Vector3Int{{0 :
position{{; C
,{{C D
	Transform{{E N
parent{{O U
){{U V
{|| 	
ClearSceneCell}} 
(}} 
grid}} 
,}}  
parent}}! '
,}}' (
position}}) 1
)}}1 2
;}}2 3
}~~ 	
public
‡‡ 
override
‡‡ 
void
‡‡ 
BoxFill
‡‡ $
(
‡‡$ %

GridLayout
‡‡% /

gridLayout
‡‡0 :
,
‡‡: ;

GameObject
‡‡< F
brushTarget
‡‡G R
,
‡‡R S
	BoundsInt
‡‡T ]
position
‡‡^ f
)
‡‡f g
{
€€ 	
if
ЉЉ 
(
ЉЉ 
brushTarget
ЉЉ 
.
ЉЉ 
layer
ЉЉ !
==
ЉЉ" $
$num
ЉЉ% '
)
ЉЉ' (
return
‹‹ 
;
‹‹ 
if
ЌЌ 
(
ЌЌ 
brushTarget
ЌЌ 
==
ЌЌ 
null
ЌЌ #
)
ЌЌ# $
return
ЋЋ 
;
ЋЋ 
foreach
ђђ 
(
ђђ 

Vector3Int
ђђ 
location
ђђ  (
in
ђђ) +
position
ђђ, 4
.
ђђ4 5 
allPositionsWithin
ђђ5 G
)
ђђG H
{
‘‘ 

Vector3Int
’’ 
local
’’  
=
’’! "
location
’’# +
-
’’, -
position
’’. 6
.
’’6 7
min
’’7 :
;
’’: ;
	BrushCell
““ 
cell
““ 
=
““  
m_Cells
““! (
[
““( )$
GetCellIndexWrapAround
““) ?
(
““? @
local
““@ E
.
““E F
x
““F G
,
““G H
local
““I N
.
““N O
y
““O P
,
““P Q
local
““R W
.
““W X
z
““X Y
)
““Y Z
]
““Z [
;
““[ \
	PaintCell
”” 
(
”” 

gridLayout
”” $
,
””$ %
location
””& .
,
””. /
brushTarget
””0 ;
.
””; <
	transform
””< E
,
””E F
cell
””G K
)
””K L
;
””L M
}
•• 
}
–– 	
public
џџ 
override
џџ 
void
џџ 
BoxErase
џџ %
(
џџ% &

GridLayout
џџ& 0

gridLayout
џџ1 ;
,
џџ; <

GameObject
џџ= G
brushTarget
џџH S
,
џџS T
	BoundsInt
џџU ^
position
џџ_ g
)
џџg h
{
   	
if
ўў 
(
ўў 
brushTarget
ўў 
.
ўў 
layer
ўў !
==
ўў" $
$num
ўў% '
)
ўў' (
return
ЈЈ 
;
ЈЈ 
if
ҐҐ 
(
ҐҐ 
brushTarget
ҐҐ 
==
ҐҐ 
null
ҐҐ #
)
ҐҐ# $
return
¦¦ 
;
¦¦ 
foreach
ЁЁ 
(
ЁЁ 

Vector3Int
ЁЁ 
location
ЁЁ  (
in
ЁЁ) +
position
ЁЁ, 4
.
ЁЁ4 5 
allPositionsWithin
ЁЁ5 G
)
ЁЁG H
{
©© 
	EraseCell
ЄЄ 
(
ЄЄ 

gridLayout
ЄЄ $
,
ЄЄ$ %
location
ЄЄ& .
,
ЄЄ. /
brushTarget
ЄЄ0 ;
.
ЄЄ; <
	transform
ЄЄ< E
)
ЄЄE F
;
ЄЄF G
}
«« 
}
¬¬ 	
public
ґґ 
override
ґґ 
void
ґґ 
	FloodFill
ґґ &
(
ґґ& '

GridLayout
ґґ' 1

gridLayout
ґґ2 <
,
ґґ< =

GameObject
ґґ> H
brushTarget
ґґI T
,
ґґT U

Vector3Int
ґґV `
position
ґґa i
)
ґґi j
{
µµ 	
Debug
¶¶ 
.
¶¶ 

LogWarning
¶¶ 
(
¶¶ 
$str
¶¶ 6
)
¶¶6 7
;
¶¶7 8
}
·· 	
public
ѕѕ 
override
ѕѕ 
void
ѕѕ 
Rotate
ѕѕ #
(
ѕѕ# $
RotationDirection
ѕѕ$ 5
	direction
ѕѕ6 ?
,
ѕѕ? @
Grid
ѕѕA E
.
ѕѕE F

CellLayout
ѕѕF P
layout
ѕѕQ W
)
ѕѕW X
{
її 	

Vector3Int
АА 
oldSize
АА 
=
АА  
m_Size
АА! '
;
АА' (
	BrushCell
ББ 
[
ББ 
]
ББ 
oldCells
ББ  
=
ББ! "
m_Cells
ББ# *
.
ББ* +
Clone
ББ+ 0
(
ББ0 1
)
ББ1 2
as
ББ3 5
	BrushCell
ББ6 ?
[
ББ? @
]
ББ@ A
;
ББA B
size
ВВ 
=
ВВ 
new
ВВ 

Vector3Int
ВВ !
(
ВВ! "
oldSize
ВВ" )
.
ВВ) *
y
ВВ* +
,
ВВ+ ,
oldSize
ВВ- 4
.
ВВ4 5
x
ВВ5 6
,
ВВ6 7
oldSize
ВВ8 ?
.
ВВ? @
z
ВВ@ A
)
ВВA B
;
ВВB C
	BoundsInt
ГГ 
	oldBounds
ГГ 
=
ГГ  !
new
ГГ" %
	BoundsInt
ГГ& /
(
ГГ/ 0

Vector3Int
ГГ0 :
.
ГГ: ;
zero
ГГ; ?
,
ГГ? @
oldSize
ГГA H
)
ГГH I
;
ГГI J
foreach
ЕЕ 
(
ЕЕ 

Vector3Int
ЕЕ 
oldPos
ЕЕ  &
in
ЕЕ' )
	oldBounds
ЕЕ* 3
.
ЕЕ3 4 
allPositionsWithin
ЕЕ4 F
)
ЕЕF G
{
ЖЖ 
int
ЗЗ 
newX
ЗЗ 
=
ЗЗ 
	direction
ЗЗ $
==
ЗЗ% '
RotationDirection
ЗЗ( 9
.
ЗЗ9 :
	Clockwise
ЗЗ: C
?
ЗЗD E
oldSize
ЗЗF M
.
ЗЗM N
y
ЗЗN O
-
ЗЗP Q
oldPos
ЗЗR X
.
ЗЗX Y
y
ЗЗY Z
-
ЗЗ[ \
$num
ЗЗ] ^
:
ЗЗ_ `
oldPos
ЗЗa g
.
ЗЗg h
y
ЗЗh i
;
ЗЗi j
int
ИИ 
newY
ИИ 
=
ИИ 
	direction
ИИ $
==
ИИ% '
RotationDirection
ИИ( 9
.
ИИ9 :
	Clockwise
ИИ: C
?
ИИD E
oldPos
ИИF L
.
ИИL M
x
ИИM N
:
ИИO P
oldSize
ИИQ X
.
ИИX Y
x
ИИY Z
-
ИИ[ \
oldPos
ИИ] c
.
ИИc d
x
ИИd e
-
ИИf g
$num
ИИh i
;
ИИi j
int
ЙЙ 
toIndex
ЙЙ 
=
ЙЙ 
GetCellIndex
ЙЙ *
(
ЙЙ* +
newX
ЙЙ+ /
,
ЙЙ/ 0
newY
ЙЙ1 5
,
ЙЙ5 6
oldPos
ЙЙ7 =
.
ЙЙ= >
z
ЙЙ> ?
)
ЙЙ? @
;
ЙЙ@ A
int
КК 
	fromIndex
КК 
=
КК 
GetCellIndex
КК  ,
(
КК, -
oldPos
КК- 3
.
КК3 4
x
КК4 5
,
КК5 6
oldPos
КК7 =
.
КК= >
y
КК> ?
,
КК? @
oldPos
ККA G
.
ККG H
z
ККH I
,
ККI J
oldSize
ККK R
.
ККR S
x
ККS T
,
ККT U
oldSize
ККV ]
.
КК] ^
y
КК^ _
,
КК_ `
oldSize
ККa h
.
ККh i
z
ККi j
)
ККj k
;
ККk l
m_Cells
ЛЛ 
[
ЛЛ 
toIndex
ЛЛ 
]
ЛЛ  
=
ЛЛ! "
oldCells
ЛЛ# +
[
ЛЛ+ ,
	fromIndex
ЛЛ, 5
]
ЛЛ5 6
;
ЛЛ6 7
}
ММ 
int
ОО 
	newPivotX
ОО 
=
ОО 
	direction
ОО %
==
ОО& (
RotationDirection
ОО) :
.
ОО: ;
	Clockwise
ОО; D
?
ООE F
oldSize
ООG N
.
ООN O
y
ООO P
-
ООQ R
pivot
ООS X
.
ООX Y
y
ООY Z
-
ОО[ \
$num
ОО] ^
:
ОО_ `
pivot
ООa f
.
ООf g
y
ООg h
;
ООh i
int
ПП 
	newPivotY
ПП 
=
ПП 
	direction
ПП %
==
ПП& (
RotationDirection
ПП) :
.
ПП: ;
	Clockwise
ПП; D
?
ППE F
pivot
ППG L
.
ППL M
x
ППM N
:
ППO P
oldSize
ППQ X
.
ППX Y
x
ППY Z
-
ПП[ \
pivot
ПП] b
.
ППb c
x
ППc d
-
ППe f
$num
ППg h
;
ППh i
pivot
РР 
=
РР 
new
РР 

Vector3Int
РР "
(
РР" #
	newPivotX
РР# ,
,
РР, -
	newPivotY
РР. 7
,
РР7 8
pivot
РР9 >
.
РР> ?
z
РР? @
)
РР@ A
;
РРA B
	Matrix4x4
ТТ 
rotation
ТТ 
=
ТТ  
	Matrix4x4
ТТ! *
.
ТТ* +
TRS
ТТ+ .
(
ТТ. /
Vector3
ТТ/ 6
.
ТТ6 7
zero
ТТ7 ;
,
ТТ; <

Quaternion
ТТ= G
.
ТТG H
Euler
ТТH M
(
ТТM N
$num
ТТN P
,
ТТP Q
$num
ТТR T
,
ТТT U
	direction
ТТV _
==
ТТ` b
RotationDirection
ТТc t
.
ТТt u
	Clockwise
ТТu ~
?ТТ Ђ
$numТТЃ „
:ТТ… †
-ТТ‡ €
$numТТ€ ‹
)ТТ‹ Њ
,ТТЊ Ќ
Vector3ТТЋ •
.ТТ• –
oneТТ– ™
)ТТ™ љ
;ТТљ ›

Quaternion
УУ 
orientation
УУ "
=
УУ# $

Quaternion
УУ% /
.
УУ/ 0
Euler
УУ0 5
(
УУ5 6
$num
УУ6 8
,
УУ8 9
$num
УУ: <
,
УУ< =
	direction
УУ> G
==
УУH J
RotationDirection
УУK \
.
УУ\ ]
	Clockwise
УУ] f
?
УУg h
$num
УУi l
:
УУm n
-
УУo p
$num
УУp s
)
УУs t
;
УУt u
foreach
ФФ 
(
ФФ 
	BrushCell
ФФ 
cell
ФФ #
in
ФФ$ &
m_Cells
ФФ' .
)
ФФ. /
{
ХХ 
cell
ЦЦ 
.
ЦЦ 
offset
ЦЦ 
=
ЦЦ 
rotation
ЦЦ &
*
ЦЦ' (
cell
ЦЦ) -
.
ЦЦ- .
offset
ЦЦ. 4
;
ЦЦ4 5
cell
ЧЧ 
.
ЧЧ 
orientation
ЧЧ  
=
ЧЧ! "
cell
ЧЧ# '
.
ЧЧ' (
orientation
ЧЧ( 3
*
ЧЧ4 5
orientation
ЧЧ6 A
;
ЧЧA B
}
ШШ 
}
ЩЩ 	
public
ЮЮ 
override
ЮЮ 
void
ЮЮ 
Flip
ЮЮ !
(
ЮЮ! "
FlipAxis
ЮЮ" *
flip
ЮЮ+ /
,
ЮЮ/ 0
Grid
ЮЮ1 5
.
ЮЮ5 6

CellLayout
ЮЮ6 @
layout
ЮЮA G
)
ЮЮG H
{
ЯЯ 	
if
аа 
(
аа 
flip
аа 
==
аа 
FlipAxis
аа  
.
аа  !
X
аа! "
)
аа" #
FlipX
бб 
(
бб 
)
бб 
;
бб 
else
вв 
FlipY
гг 
(
гг 
)
гг 
;
гг 
}
дд 	
public
оо 
override
оо 
void
оо 
Pick
оо !
(
оо! "

GridLayout
оо" ,

gridLayout
оо- 7
,
оо7 8

GameObject
оо9 C
brushTarget
ооD O
,
ооO P
	BoundsInt
ооQ Z
position
оо[ c
,
ооc d

Vector3Int
ооe o
pivot
ооp u
)
ооu v
{
пп 	
if
сс 
(
сс 
brushTarget
сс 
.
сс 
layer
сс !
==
сс" $
$num
сс% '
)
сс' (
return
тт 
;
тт 
Reset
фф 
(
фф 
)
фф 
;
фф  
UpdateSizeAndPivot
хх 
(
хх 
new
хх "

Vector3Int
хх# -
(
хх- .
position
хх. 6
.
хх6 7
size
хх7 ;
.
хх; <
x
хх< =
,
хх= >
position
хх? G
.
ххG H
size
ххH L
.
ххL M
y
ххM N
,
ххN O
$num
ххP Q
)
ххQ R
,
ххR S
new
ххT W

Vector3Int
ххX b
(
ххb c
pivot
ххc h
.
ххh i
x
ххi j
,
ххj k
pivot
ххl q
.
ххq r
y
ххr s
,
ххs t
$num
ххu v
)
ххv w
)
ххw x
;
ххx y
foreach
чч 
(
чч 

Vector3Int
чч 
pos
чч  #
in
чч$ &
position
чч' /
.
чч/ 0 
allPositionsWithin
чч0 B
)
ччB C
{
шш 

Vector3Int
щщ 
brushPosition
щщ (
=
щщ) *
new
щщ+ .

Vector3Int
щщ/ 9
(
щщ9 :
pos
щщ: =
.
щщ= >
x
щщ> ?
-
щщ@ A
position
щщB J
.
щщJ K
x
щщK L
,
щщL M
pos
щщN Q
.
щщQ R
y
щщR S
-
щщT U
position
щщV ^
.
щщ^ _
y
щщ_ `
,
щщ` a
$num
щщb c
)
щщc d
;
щщd e
PickCell
ъъ 
(
ъъ 
pos
ъъ 
,
ъъ 
brushPosition
ъъ +
,
ъъ+ ,

gridLayout
ъъ- 7
,
ъъ7 8
brushTarget
ъъ9 D
.
ъъD E
	transform
ъъE N
)
ъъN O
;
ъъO P
}
ыы 
}
ьь 	
private
юю 
void
юю 
PickCell
юю 
(
юю 

Vector3Int
юю (
position
юю) 1
,
юю1 2

Vector3Int
юю3 =
brushPosition
юю> K
,
ююK L

GridLayout
ююM W
grid
ююX \
,
юю\ ]
	Transform
юю^ g
parent
ююh n
)
ююn o
{
яя 	
if
ЂЂ 
(
ЂЂ 
parent
ЂЂ 
!=
ЂЂ 
null
ЂЂ 
)
ЂЂ 
{
ЃЃ 
Vector3
‚‚ 

cellCenter
‚‚ "
=
‚‚# $
grid
‚‚% )
.
‚‚) *
LocalToWorld
‚‚* 6
(
‚‚6 7
grid
‚‚7 ;
.
‚‚; <%
CellToLocalInterpolated
‚‚< S
(
‚‚S T
position
‚‚T \
+
‚‚] ^
m_Anchor
‚‚_ g
)
‚‚g h
)
‚‚h i
;
‚‚i j

GameObject
ѓѓ 
go
ѓѓ 
=
ѓѓ 
GetObjectInCell
ѓѓ  /
(
ѓѓ/ 0
grid
ѓѓ0 4
,
ѓѓ4 5
parent
ѓѓ6 <
,
ѓѓ< =
position
ѓѓ> F
)
ѓѓF G
;
ѓѓG H
if
…… 
(
…… 
go
…… 
!=
…… 
null
…… 
)
…… 
{
†† 
Object
‡‡ 
prefab
‡‡ !
=
‡‡" #
PrefabUtility
‡‡$ 1
.
‡‡1 2.
 GetCorrespondingObjectFromSource
‡‡2 R
(
‡‡R S
go
‡‡S U
)
‡‡U V
;
‡‡V W
if
‰‰ 
(
‰‰ 
prefab
‰‰ 
)
‰‰ 
{
ЉЉ 
SetGameObject
‹‹ %
(
‹‹% &
brushPosition
‹‹& 3
,
‹‹3 4
(
‹‹5 6

GameObject
‹‹6 @
)
‹‹@ A
prefab
‹‹B H
)
‹‹H I
;
‹‹I J
}
ЊЊ 
else
ЌЌ 
{
ЋЋ 

GameObject
ЏЏ "
newInstance
ЏЏ# .
=
ЏЏ/ 0
Instantiate
ЏЏ1 <
(
ЏЏ< =
go
ЏЏ= ?
)
ЏЏ? @
;
ЏЏ@ A
newInstance
ђђ #
.
ђђ# $
	hideFlags
ђђ$ -
=
ђђ. /
	HideFlags
ђђ0 9
.
ђђ9 :
HideAndDontSave
ђђ: I
;
ђђI J
SetGameObject
‘‘ %
(
‘‘% &
brushPosition
‘‘& 3
,
‘‘3 4
newInstance
‘‘5 @
)
‘‘@ A
;
‘‘A B
}
’’ 
	SetOffset
”” 
(
”” 
brushPosition
”” +
,
””+ ,
go
””- /
.
””/ 0
	transform
””0 9
.
””9 :
position
””: B
-
””C D

cellCenter
””E O
)
””O P
;
””P Q
SetScale
•• 
(
•• 
brushPosition
•• *
,
••* +
go
••, .
.
••. /
	transform
••/ 8
.
••8 9

localScale
••9 C
)
••C D
;
••D E
SetOrientation
–– "
(
––" #
brushPosition
––# 0
,
––0 1
go
––2 4
.
––4 5
	transform
––5 >
.
––> ?
localRotation
––? L
)
––L M
;
––M N
}
—— 
}
 
}
™™ 	
public
ўў 
override
ўў 
void
ўў 
	MoveStart
ўў &
(
ўў& '

GridLayout
ўў' 1

gridLayout
ўў2 <
,
ўў< =

GameObject
ўў> H
brushTarget
ўўI T
,
ўўT U
	BoundsInt
ўўV _
position
ўў` h
)
ўўh i
{
ЈЈ 	
if
ҐҐ 
(
ҐҐ 
brushTarget
ҐҐ 
.
ҐҐ 
layer
ҐҐ !
==
ҐҐ" $
$num
ҐҐ% '
)
ҐҐ' (
return
¦¦ 
;
¦¦ 
Reset
ЁЁ 
(
ЁЁ 
)
ЁЁ 
;
ЁЁ  
UpdateSizeAndPivot
©© 
(
©© 
new
©© "

Vector3Int
©©# -
(
©©- .
position
©©. 6
.
©©6 7
size
©©7 ;
.
©©; <
x
©©< =
,
©©= >
position
©©? G
.
©©G H
size
©©H L
.
©©L M
y
©©M N
,
©©N O
$num
©©P Q
)
©©Q R
,
©©R S

Vector3Int
©©T ^
.
©©^ _
zero
©©_ c
)
©©c d
;
©©d e
if
«« 
(
«« 
brushTarget
«« 
!=
«« 
null
«« #
)
««# $
{
¬¬ 
foreach
­­ 
(
­­ 

Vector3Int
­­ #
pos
­­$ '
in
­­( *
position
­­+ 3
.
­­3 4 
allPositionsWithin
­­4 F
)
­­F G
{
®® 

Vector3Int
ЇЇ 
brushPosition
ЇЇ ,
=
ЇЇ- .
new
ЇЇ/ 2

Vector3Int
ЇЇ3 =
(
ЇЇ= >
pos
ЇЇ> A
.
ЇЇA B
x
ЇЇB C
-
ЇЇD E
position
ЇЇF N
.
ЇЇN O
x
ЇЇO P
,
ЇЇP Q
pos
ЇЇR U
.
ЇЇU V
y
ЇЇV W
-
ЇЇX Y
position
ЇЇZ b
.
ЇЇb c
y
ЇЇc d
,
ЇЇd e
$num
ЇЇf g
)
ЇЇg h
;
ЇЇh i
PickCell
°° 
(
°° 
pos
°°  
,
°°  !
brushPosition
°°" /
,
°°/ 0

gridLayout
°°1 ;
,
°°; <
brushTarget
°°= H
.
°°H I
	transform
°°I R
)
°°R S
;
°°S T
ClearSceneCell
±± "
(
±±" #

gridLayout
±±# -
,
±±- .
brushTarget
±±/ :
.
±±: ;
	transform
±±; D
,
±±D E
brushPosition
±±F S
)
±±S T
;
±±T U
}
ІІ 
}
іі 
}
ґґ 	
public
ЅЅ 
override
ЅЅ 
void
ЅЅ 
MoveEnd
ЅЅ $
(
ЅЅ$ %

GridLayout
ЅЅ% /

gridLayout
ЅЅ0 :
,
ЅЅ: ;

GameObject
ЅЅ< F
brushTarget
ЅЅG R
,
ЅЅR S
	BoundsInt
ЅЅT ]
position
ЅЅ^ f
)
ЅЅf g
{
ѕѕ 	
if
АА 
(
АА 
brushTarget
АА 
.
АА 
layer
АА !
==
АА" $
$num
АА% '
)
АА' (
return
ББ 
;
ББ 
Paint
ГГ 
(
ГГ 

gridLayout
ГГ 
,
ГГ 
brushTarget
ГГ )
,
ГГ) *
position
ГГ+ 3
.
ГГ3 4
min
ГГ4 7
)
ГГ7 8
;
ГГ8 9
Reset
ДД 
(
ДД 
)
ДД 
;
ДД 
}
ЕЕ 	
public
ИИ 
void
ИИ 
Reset
ИИ 
(
ИИ 
)
ИИ 
{
ЙЙ 	
foreach
КК 
(
КК 
var
КК 
cell
КК 
in
КК  
m_Cells
КК! (
)
КК( )
{
ЛЛ 
if
ММ 
(
ММ 
cell
ММ 
.
ММ 

gameObject
ММ #
!=
ММ$ &
null
ММ' +
&&
ММ, .
!
ММ/ 0
EditorUtility
ММ0 =
.
ММ= >
IsPersistent
ММ> J
(
ММJ K
cell
ММK O
.
ММO P

gameObject
ММP Z
)
ММZ [
)
ММ[ \
{
НН 
DestroyImmediate
ОО $
(
ОО$ %
cell
ОО% )
.
ОО) *

gameObject
ОО* 4
)
ОО4 5
;
ОО5 6
}
ПП 
}
РР  
UpdateSizeAndPivot
СС 
(
СС 

Vector3Int
СС )
.
СС) *
one
СС* -
,
СС- .

Vector3Int
СС/ 9
.
СС9 :
zero
СС: >
)
СС> ?
;
СС? @
}
ТТ 	
private
ФФ 
void
ФФ 
FlipX
ФФ 
(
ФФ 
)
ФФ 
{
ХХ 	
	BrushCell
ЦЦ 
[
ЦЦ 
]
ЦЦ 
oldCells
ЦЦ  
=
ЦЦ! "
m_Cells
ЦЦ# *
.
ЦЦ* +
Clone
ЦЦ+ 0
(
ЦЦ0 1
)
ЦЦ1 2
as
ЦЦ3 5
	BrushCell
ЦЦ6 ?
[
ЦЦ? @
]
ЦЦ@ A
;
ЦЦA B
	BoundsInt
ЧЧ 
	oldBounds
ЧЧ 
=
ЧЧ  !
new
ЧЧ" %
	BoundsInt
ЧЧ& /
(
ЧЧ/ 0

Vector3Int
ЧЧ0 :
.
ЧЧ: ;
zero
ЧЧ; ?
,
ЧЧ? @
m_Size
ЧЧA G
)
ЧЧG H
;
ЧЧH I
foreach
ЩЩ 
(
ЩЩ 

Vector3Int
ЩЩ 
oldPos
ЩЩ  &
in
ЩЩ' )
	oldBounds
ЩЩ* 3
.
ЩЩ3 4 
allPositionsWithin
ЩЩ4 F
)
ЩЩF G
{
ЪЪ 
int
ЫЫ 
newX
ЫЫ 
=
ЫЫ 
m_Size
ЫЫ !
.
ЫЫ! "
x
ЫЫ" #
-
ЫЫ$ %
oldPos
ЫЫ& ,
.
ЫЫ, -
x
ЫЫ- .
-
ЫЫ/ 0
$num
ЫЫ1 2
;
ЫЫ2 3
int
ЬЬ 
toIndex
ЬЬ 
=
ЬЬ 
GetCellIndex
ЬЬ *
(
ЬЬ* +
newX
ЬЬ+ /
,
ЬЬ/ 0
oldPos
ЬЬ1 7
.
ЬЬ7 8
y
ЬЬ8 9
,
ЬЬ9 :
oldPos
ЬЬ; A
.
ЬЬA B
z
ЬЬB C
)
ЬЬC D
;
ЬЬD E
int
ЭЭ 
	fromIndex
ЭЭ 
=
ЭЭ 
GetCellIndex
ЭЭ  ,
(
ЭЭ, -
oldPos
ЭЭ- 3
)
ЭЭ3 4
;
ЭЭ4 5
m_Cells
ЮЮ 
[
ЮЮ 
toIndex
ЮЮ 
]
ЮЮ  
=
ЮЮ! "
oldCells
ЮЮ# +
[
ЮЮ+ ,
	fromIndex
ЮЮ, 5
]
ЮЮ5 6
;
ЮЮ6 7
}
ЯЯ 
int
бб 
	newPivotX
бб 
=
бб 
m_Size
бб "
.
бб" #
x
бб# $
-
бб% &
pivot
бб' ,
.
бб, -
x
бб- .
-
бб/ 0
$num
бб1 2
;
бб2 3
pivot
вв 
=
вв 
new
вв 

Vector3Int
вв "
(
вв" #
	newPivotX
вв# ,
,
вв, -
pivot
вв. 3
.
вв3 4
y
вв4 5
,
вв5 6
pivot
вв7 <
.
вв< =
z
вв= >
)
вв> ?
;
вв? @
	Matrix4x4
гг 
flip
гг 
=
гг 
	Matrix4x4
гг &
.
гг& '
TRS
гг' *
(
гг* +
Vector3
гг+ 2
.
гг2 3
zero
гг3 7
,
гг7 8

Quaternion
гг9 C
.
ггC D
identity
ггD L
,
ггL M
new
ггN Q
Vector3
ггR Y
(
ггY Z
-
ггZ [
$num
гг[ ]
,
гг] ^
$num
гг_ a
,
ггa b
$num
ггc e
)
ггe f
)
ггf g
;
ггg h

Quaternion
дд 
orientation
дд "
=
дд# $

Quaternion
дд% /
.
дд/ 0
Euler
дд0 5
(
дд5 6
$num
дд6 8
,
дд8 9
$num
дд: <
,
дд< =
-
дд> ?
$num
дд? C
)
ддC D
;
ддD E
foreach
жж 
(
жж 
	BrushCell
жж 
cell
жж #
in
жж$ &
m_Cells
жж' .
)
жж. /
{
зз 
Vector3
ии 
	oldOffset
ии !
=
ии" #
cell
ии$ (
.
ии( )
offset
ии) /
;
ии/ 0
cell
йй 
.
йй 
offset
йй 
=
йй 
flip
йй "
*
йй# $
	oldOffset
йй% .
;
йй. /
cell
кк 
.
кк 
orientation
кк  
=
кк! "
cell
кк# '
.
кк' (
orientation
кк( 3
*
кк3 4
orientation
кк4 ?
;
кк? @
}
лл 
}
мм 	
private
оо 
void
оо 
FlipY
оо 
(
оо 
)
оо 
{
пп 	
	BrushCell
рр 
[
рр 
]
рр 
oldCells
рр  
=
рр! "
m_Cells
рр# *
.
рр* +
Clone
рр+ 0
(
рр0 1
)
рр1 2
as
рр3 5
	BrushCell
рр6 ?
[
рр? @
]
рр@ A
;
ррA B
	BoundsInt
сс 
	oldBounds
сс 
=
сс  !
new
сс" %
	BoundsInt
сс& /
(
сс/ 0

Vector3Int
сс0 :
.
сс: ;
zero
сс; ?
,
сс? @
m_Size
ссA G
)
ссG H
;
ссH I
foreach
уу 
(
уу 

Vector3Int
уу 
oldPos
уу  &
in
уу' )
	oldBounds
уу* 3
.
уу3 4 
allPositionsWithin
уу4 F
)
ууF G
{
фф 
int
хх 
newY
хх 
=
хх 
m_Size
хх !
.
хх! "
y
хх" #
-
хх$ %
oldPos
хх& ,
.
хх, -
y
хх- .
-
хх/ 0
$num
хх1 2
;
хх2 3
int
цц 
toIndex
цц 
=
цц 
GetCellIndex
цц *
(
цц* +
oldPos
цц+ 1
.
цц1 2
x
цц2 3
,
цц3 4
newY
цц5 9
,
цц9 :
oldPos
цц; A
.
ццA B
z
ццB C
)
ццC D
;
ццD E
int
чч 
	fromIndex
чч 
=
чч 
GetCellIndex
чч  ,
(
чч, -
oldPos
чч- 3
)
чч3 4
;
чч4 5
m_Cells
шш 
[
шш 
toIndex
шш 
]
шш  
=
шш! "
oldCells
шш# +
[
шш+ ,
	fromIndex
шш, 5
]
шш5 6
;
шш6 7
}
щщ 
int
ыы 
	newPivotY
ыы 
=
ыы 
m_Size
ыы "
.
ыы" #
y
ыы# $
-
ыы% &
pivot
ыы' ,
.
ыы, -
y
ыы- .
-
ыы/ 0
$num
ыы1 2
;
ыы2 3
pivot
ьь 
=
ьь 
new
ьь 

Vector3Int
ьь "
(
ьь" #
pivot
ьь# (
.
ьь( )
x
ьь) *
,
ьь* +
	newPivotY
ьь, 5
,
ьь5 6
pivot
ьь7 <
.
ьь< =
z
ьь= >
)
ьь> ?
;
ьь? @
	Matrix4x4
ээ 
flip
ээ 
=
ээ 
	Matrix4x4
ээ &
.
ээ& '
TRS
ээ' *
(
ээ* +
Vector3
ээ+ 2
.
ээ2 3
zero
ээ3 7
,
ээ7 8

Quaternion
ээ9 C
.
ээC D
identity
ээD L
,
ээL M
new
ээN Q
Vector3
ээR Y
(
ээY Z
$num
ээZ \
,
ээ\ ]
-
ээ^ _
$num
ээ_ a
,
ээa b
$num
ээc e
)
ээe f
)
ээf g
;
ээg h

Quaternion
юю 
orientation
юю "
=
юю# $

Quaternion
юю% /
.
юю/ 0
Euler
юю0 5
(
юю5 6
$num
юю6 8
,
юю8 9
$num
юю: <
,
юю< =
-
юю> ?
$num
юю? C
)
ююC D
;
ююD E
foreach
яя 
(
яя 
	BrushCell
яя 
cell
яя #
in
яя$ &
m_Cells
яя' .
)
яя. /
{
ЂЂ 
Vector3
ЃЃ 
	oldOffset
ЃЃ !
=
ЃЃ" #
cell
ЃЃ$ (
.
ЃЃ( )
offset
ЃЃ) /
;
ЃЃ/ 0
cell
‚‚ 
.
‚‚ 
offset
‚‚ 
=
‚‚ 
flip
‚‚ "
*
‚‚# $
	oldOffset
‚‚% .
;
‚‚. /
cell
ѓѓ 
.
ѓѓ 
orientation
ѓѓ  
=
ѓѓ! "
cell
ѓѓ# '
.
ѓѓ' (
orientation
ѓѓ( 3
*
ѓѓ4 5
orientation
ѓѓ6 A
;
ѓѓA B
}
„„ 
}
…… 	
public
ЉЉ 
void
ЉЉ  
UpdateSizeAndPivot
ЉЉ &
(
ЉЉ& '

Vector3Int
ЉЉ' 1
size
ЉЉ2 6
,
ЉЉ6 7

Vector3Int
ЉЉ8 B
pivot
ЉЉC H
)
ЉЉH I
{
‹‹ 	
m_Size
ЊЊ 
=
ЊЊ 
size
ЊЊ 
;
ЊЊ 
m_Pivot
ЌЌ 
=
ЌЌ 
pivot
ЌЌ 
;
ЌЌ 
SizeUpdated
ЋЋ 
(
ЋЋ 
)
ЋЋ 
;
ЋЋ 
}
ЏЏ 	
public
–– 
void
–– 
SetGameObject
–– !
(
––! "

Vector3Int
––" ,
position
––- 5
,
––5 6

GameObject
––7 A
go
––B D
)
––D E
{
—— 	
if
 
(
 "
ValidateCellPosition
 $
(
$ %
position
% -
)
- .
)
. /
m_Cells
™™ 
[
™™ 
GetCellIndex
™™ $
(
™™$ %
position
™™% -
)
™™- .
]
™™. /
.
™™/ 0

gameObject
™™0 :
=
™™; <
go
™™= ?
;
™™? @
}
љљ 	
public
ЎЎ 
void
ЎЎ 
	SetOffset
ЎЎ 
(
ЎЎ 

Vector3Int
ЎЎ (
position
ЎЎ) 1
,
ЎЎ1 2
Vector3
ЎЎ3 :
offset
ЎЎ; A
)
ЎЎA B
{
ўў 	
if
ЈЈ 
(
ЈЈ "
ValidateCellPosition
ЈЈ $
(
ЈЈ$ %
position
ЈЈ% -
)
ЈЈ- .
)
ЈЈ. /
m_Cells
¤¤ 
[
¤¤ 
GetCellIndex
¤¤ $
(
¤¤$ %
position
¤¤% -
)
¤¤- .
]
¤¤. /
.
¤¤/ 0
offset
¤¤0 6
=
¤¤7 8
offset
¤¤9 ?
;
¤¤? @
}
ҐҐ 	
public
¬¬ 
void
¬¬ 
SetOrientation
¬¬ "
(
¬¬" #

Vector3Int
¬¬# -
position
¬¬. 6
,
¬¬6 7

Quaternion
¬¬8 B
orientation
¬¬C N
)
¬¬N O
{
­­ 	
if
®® 
(
®® "
ValidateCellPosition
®® $
(
®®$ %
position
®®% -
)
®®- .
)
®®. /
m_Cells
ЇЇ 
[
ЇЇ 
GetCellIndex
ЇЇ $
(
ЇЇ$ %
position
ЇЇ% -
)
ЇЇ- .
]
ЇЇ. /
.
ЇЇ/ 0
orientation
ЇЇ0 ;
=
ЇЇ< =
orientation
ЇЇ> I
;
ЇЇI J
}
°° 	
public
·· 
void
·· 
SetScale
·· 
(
·· 

Vector3Int
·· '
position
··( 0
,
··0 1
Vector3
··2 9
scale
··: ?
)
··? @
{
ёё 	
if
№№ 
(
№№ "
ValidateCellPosition
№№ $
(
№№$ %
position
№№% -
)
№№- .
)
№№. /
m_Cells
єє 
[
єє 
GetCellIndex
єє $
(
єє$ %
position
єє% -
)
єє- .
]
єє. /
.
єє/ 0
scale
єє0 5
=
єє6 7
scale
єє8 =
;
єє= >
}
»» 	
public
її 
int
її 
GetCellIndex
її 
(
її  

Vector3Int
її  *
brushPosition
її+ 8
)
її8 9
{
АА 	
return
ББ 
GetCellIndex
ББ 
(
ББ  
brushPosition
ББ  -
.
ББ- .
x
ББ. /
,
ББ/ 0
brushPosition
ББ1 >
.
ББ> ?
y
ББ? @
,
ББ@ A
brushPosition
ББB O
.
ББO P
z
ББP Q
)
ББQ R
;
ББR S
}
ВВ 	
public
ИИ 
int
ИИ 
GetCellIndex
ИИ 
(
ИИ  
int
ИИ  #
x
ИИ$ %
,
ИИ% &
int
ИИ' *
y
ИИ+ ,
,
ИИ, -
int
ИИ. 1
z
ИИ2 3
)
ИИ3 4
{
ЙЙ 	
return
КК 
x
КК 
+
КК 
m_Size
КК 
.
КК 
x
КК 
*
КК  !
y
КК" #
+
КК$ %
m_Size
КК& ,
.
КК, -
x
КК- .
*
КК/ 0
m_Size
КК1 7
.
КК7 8
y
КК8 9
*
КК: ;
z
КК< =
;
КК= >
}
ЛЛ 	
public
ФФ 
int
ФФ 
GetCellIndex
ФФ 
(
ФФ  
int
ФФ  #
x
ФФ$ %
,
ФФ% &
int
ФФ' *
y
ФФ+ ,
,
ФФ, -
int
ФФ. 1
z
ФФ2 3
,
ФФ3 4
int
ФФ5 8
sizex
ФФ9 >
,
ФФ> ?
int
ФФ@ C
sizey
ФФD I
,
ФФI J
int
ФФK N
sizez
ФФO T
)
ФФT U
{
ХХ 	
return
ЦЦ 
x
ЦЦ 
+
ЦЦ 
sizex
ЦЦ 
*
ЦЦ 
y
ЦЦ  
+
ЦЦ! "
sizex
ЦЦ# (
*
ЦЦ) *
sizey
ЦЦ+ 0
*
ЦЦ1 2
z
ЦЦ3 4
;
ЦЦ4 5
}
ЧЧ 	
public
ЮЮ 
int
ЮЮ $
GetCellIndexWrapAround
ЮЮ )
(
ЮЮ) *
int
ЮЮ* -
x
ЮЮ. /
,
ЮЮ/ 0
int
ЮЮ1 4
y
ЮЮ5 6
,
ЮЮ6 7
int
ЮЮ8 ;
z
ЮЮ< =
)
ЮЮ= >
{
ЯЯ 	
return
аа 
(
аа 
x
аа 
%
аа 
m_Size
аа 
.
аа 
x
аа  
)
аа  !
+
аа" #
m_Size
аа$ *
.
аа* +
x
аа+ ,
*
аа- .
(
аа/ 0
y
аа0 1
%
аа2 3
m_Size
аа4 :
.
аа: ;
y
аа; <
)
аа< =
+
аа> ?
m_Size
аа@ F
.
ааF G
x
ааG H
*
ааI J
m_Size
ааK Q
.
ааQ R
y
ааR S
*
ааT U
(
ааV W
z
ааW X
%
ааY Z
m_Size
аа[ a
.
ааa b
z
ааb c
)
ааc d
;
ааd e
}
бб 	
private
гг 
static
гг 

GameObject
гг !
GetObjectInCell
гг" 1
(
гг1 2

GridLayout
гг2 <
grid
гг= A
,
ггA B
	Transform
ггC L
parent
ггM S
,
ггS T

Vector3Int
ггU _
position
гг` h
)
ггh i
{
дд 	
int
ее 

childCount
ее 
=
ее 
parent
ее #
.
ее# $

childCount
ее$ .
;
ее. /
Vector3
жж 
min
жж 
=
жж 
grid
жж 
.
жж 
LocalToWorld
жж +
(
жж+ ,
grid
жж, 0
.
жж0 1%
CellToLocalInterpolated
жж1 H
(
жжH I
position
жжI Q
)
жжQ R
)
жжR S
;
жжS T
Vector3
зз 
max
зз 
=
зз 
grid
зз 
.
зз 
LocalToWorld
зз +
(
зз+ ,
grid
зз, 0
.
зз0 1%
CellToLocalInterpolated
зз1 H
(
ззH I
position
ззI Q
+
ззR S

Vector3Int
ззT ^
.
зз^ _
one
зз_ b
)
ззb c
)
ззc d
;
ззd e
min
кк 
=
кк 
new
кк 
Vector3
кк 
(
кк 
min
кк !
.
кк! "
x
кк" #
,
кк# $
min
кк% (
.
кк( )
y
кк) *
,
кк* +
float
кк, 1
.
кк1 2
MinValue
кк2 :
)
кк: ;
;
кк; <
max
лл 
=
лл 
new
лл 
Vector3
лл 
(
лл 
max
лл !
.
лл! "
x
лл" #
,
лл# $
max
лл% (
.
лл( )
y
лл) *
,
лл* +
float
лл, 1
.
лл1 2
MaxValue
лл2 :
)
лл: ;
;
лл; <
Bounds
нн 
bounds
нн 
=
нн 
new
нн 
Bounds
нн  &
(
нн& '
(
нн' (
max
нн( +
+
нн, -
min
нн. 1
)
нн1 2
*
нн3 4
$num
нн5 8
,
нн8 9
max
нн: =
-
нн> ?
min
нн@ C
)
ннC D
;
ннD E
for
пп 
(
пп 
int
пп 
i
пп 
=
пп 
$num
пп 
;
пп 
i
пп 
<
пп 

childCount
пп  *
;
пп* +
i
пп, -
++
пп- /
)
пп/ 0
{
рр 
	Transform
сс 
child
сс 
=
сс  !
parent
сс" (
.
сс( )
GetChild
сс) 1
(
сс1 2
i
сс2 3
)
сс3 4
;
сс4 5
if
тт 
(
тт 
bounds
тт 
.
тт 
Contains
тт #
(
тт# $
child
тт$ )
.
тт) *
position
тт* 2
)
тт2 3
)
тт3 4
return
уу 
child
уу  
.
уу  !

gameObject
уу! +
;
уу+ ,
}
фф 
return
хх 
null
хх 
;
хх 
}
цц 	
private
шш 
bool
шш "
ValidateCellPosition
шш )
(
шш) *

Vector3Int
шш* 4
position
шш5 =
)
шш= >
{
щщ 	
var
ъъ 
valid
ъъ 
=
ъъ 
position
ыы 
.
ыы 
x
ыы 
>=
ыы 
$num
ыы 
&&
ыы  "
position
ыы# +
.
ыы+ ,
x
ыы, -
<
ыы. /
size
ыы0 4
.
ыы4 5
x
ыы5 6
&&
ыы7 9
position
ьь 
.
ьь 
y
ьь 
>=
ьь 
$num
ьь 
&&
ьь  "
position
ьь# +
.
ьь+ ,
y
ьь, -
<
ьь. /
size
ьь0 4
.
ьь4 5
y
ьь5 6
&&
ьь7 9
position
ээ 
.
ээ 
z
ээ 
>=
ээ 
$num
ээ 
&&
ээ  "
position
ээ# +
.
ээ+ ,
z
ээ, -
<
ээ. /
size
ээ0 4
.
ээ4 5
z
ээ5 6
;
ээ6 7
if
юю 
(
юю 
!
юю 
valid
юю 
)
юю 
throw
яя 
new
яя 
ArgumentException
яя +
(
яя+ ,
string
яя, 2
.
яя2 3
Format
яя3 9
(
яя9 :
$strяя: €
,яя€ ‰
positionяяЉ ’
,яя’ “

Vector3Intяя” ћ
.яяћ џ
zeroяяџ Ј
,яяЈ ¤
sizeяяҐ ©
)яя© Є
)яяЄ «
;яя« ¬
return
ЂЂ 
valid
ЂЂ 
;
ЂЂ 
}
ЃЃ 	
private
ѓѓ 
void
ѓѓ 
SizeUpdated
ѓѓ  
(
ѓѓ  !
)
ѓѓ! "
{
„„ 	
m_Cells
…… 
=
…… 
new
…… 
	BrushCell
…… #
[
……# $
m_Size
……$ *
.
……* +
x
……+ ,
*
……- .
m_Size
……/ 5
.
……5 6
y
……6 7
*
……8 9
m_Size
……: @
.
……@ A
z
……A B
]
……B C
;
……C D
	BoundsInt
†† 
bounds
†† 
=
†† 
new
†† "
	BoundsInt
††# ,
(
††, -

Vector3Int
††- 7
.
††7 8
zero
††8 <
,
††< =
m_Size
††> D
)
††D E
;
††E F
foreach
‡‡ 
(
‡‡ 

Vector3Int
‡‡ 
pos
‡‡  #
in
‡‡$ &
bounds
‡‡' -
.
‡‡- . 
allPositionsWithin
‡‡. @
)
‡‡@ A
{
€€ 
m_Cells
‰‰ 
[
‰‰ 
GetCellIndex
‰‰ $
(
‰‰$ %
pos
‰‰% (
)
‰‰( )
]
‰‰) *
=
‰‰+ ,
new
‰‰- 0
	BrushCell
‰‰1 :
(
‰‰: ;
)
‰‰; <
;
‰‰< =
}
ЉЉ 
}
‹‹ 	
private
ЌЌ 
static
ЌЌ 
void
ЌЌ 
SetSceneCell
ЌЌ (
(
ЌЌ( )

GridLayout
ЌЌ) 3
grid
ЌЌ4 8
,
ЌЌ8 9
	Transform
ЌЌ: C
parent
ЌЌD J
,
ЌЌJ K

Vector3Int
ЌЌL V
position
ЌЌW _
,
ЌЌ_ `

GameObject
ЌЌa k
go
ЌЌl n
,
ЌЌn o
Vector3
ЌЌp w
offset
ЌЌx ~
,
ЌЌ~ 
Vector3ЌЌЂ ‡
scaleЌЌ€ Ќ
,ЌЌЌ Ћ

QuaternionЌЌЏ ™
orientationЌЌљ Ґ
,ЌЌҐ ¦
Vector3ЌЌ§ ®
anchorЌЌЇ µ
)ЌЌµ ¶
{
ЋЋ 	
if
ЏЏ 
(
ЏЏ 
parent
ЏЏ 
==
ЏЏ 
null
ЏЏ 
||
ЏЏ !
go
ЏЏ" $
==
ЏЏ% '
null
ЏЏ( ,
)
ЏЏ, -
return
ђђ 
;
ђђ 

GameObject
’’ 
instance
’’ 
=
’’  !
null
’’" &
;
’’& '
if
““ 
(
““ 
PrefabUtility
““ 
.
““ !
IsPartOfPrefabAsset
““ 1
(
““1 2
go
““2 4
)
““4 5
)
““5 6
{
”” 
instance
•• 
=
•• 
(
•• 

GameObject
•• &
)
••& '
PrefabUtility
••( 5
.
••5 6
InstantiatePrefab
••6 G
(
••G H
go
••H J
)
••J K
;
••K L
}
–– 
else
—— 
{
 
instance
™™ 
=
™™ 
Instantiate
™™ &
(
™™& '
go
™™' )
)
™™) *
;
™™* +
instance
љљ 
.
љљ 
	hideFlags
љљ "
=
љљ# $
	HideFlags
љљ% .
.
љљ. /
None
љљ/ 3
;
љљ3 4
instance
›› 
.
›› 
name
›› 
=
›› 
go
››  "
.
››" #
name
››# '
;
››' (
}
њњ 
Undo
ћћ 
.
ћћ '
RegisterCreatedObjectUndo
ћћ *
(
ћћ* +
instance
ћћ+ 3
,
ћћ3 4
$str
ћћ5 G
)
ћћG H
;
ћћH I
instance
џџ 
.
џџ 
	transform
џџ 
.
џџ 
	SetParent
џџ (
(
џџ( )
parent
џџ) /
)
џџ/ 0
;
џџ0 1
instance
   
.
   
	transform
   
.
   
position
   '
=
  ( )
grid
  * .
.
  . /
LocalToWorld
  / ;
(
  ; <
grid
  < @
.
  @ A%
CellToLocalInterpolated
  A X
(
  X Y
new
  Y \

Vector3Int
  ] g
(
  g h
position
  h p
.
  p q
x
  q r
,
  r s
position
  t |
.
  | }
y
  } ~
,
  ~ 
position  Ђ €
.  € ‰
z  ‰ Љ
)  Љ ‹
+  Њ Ќ
anchor  Ћ ”
)  ” •
)  • –
;  – —
instance
ЎЎ 
.
ЎЎ 
	transform
ЎЎ 
.
ЎЎ 
localRotation
ЎЎ ,
=
ЎЎ- .
orientation
ЎЎ/ :
;
ЎЎ: ;
instance
ўў 
.
ўў 
	transform
ўў 
.
ўў 

localScale
ўў )
=
ўў* +
scale
ўў, 1
;
ўў1 2
instance
ЈЈ 
.
ЈЈ 
	transform
ЈЈ 
.
ЈЈ 
	Translate
ЈЈ (
(
ЈЈ( )
offset
ЈЈ) /
)
ЈЈ/ 0
;
ЈЈ0 1
}
¤¤ 	
private
¦¦ 
static
¦¦ 
void
¦¦ 
ClearSceneCell
¦¦ *
(
¦¦* +

GridLayout
¦¦+ 5
grid
¦¦6 :
,
¦¦: ;
	Transform
¦¦< E
parent
¦¦F L
,
¦¦L M

Vector3Int
¦¦N X
position
¦¦Y a
)
¦¦a b
{
§§ 	
if
ЁЁ 
(
ЁЁ 
parent
ЁЁ 
==
ЁЁ 
null
ЁЁ 
)
ЁЁ 
return
©© 
;
©© 

GameObject
«« 
erased
«« 
=
«« 
GetObjectInCell
««  /
(
««/ 0
grid
««0 4
,
««4 5
parent
««6 <
,
««< =
new
««> A

Vector3Int
««B L
(
««L M
position
««M U
.
««U V
x
««V W
,
««W X
position
««Y a
.
««a b
y
««b c
,
««c d
position
««e m
.
««m n
z
««n o
)
««o p
)
««p q
;
««q r
if
¬¬ 
(
¬¬ 
erased
¬¬ 
!=
¬¬ 
null
¬¬ 
)
¬¬ 
Undo
­­ 
.
­­ $
DestroyObjectImmediate
­­ +
(
­­+ ,
erased
­­, 2
)
­­2 3
;
­­3 4
}
®® 	
public
ґґ 
override
ґґ 
int
ґґ 
GetHashCode
ґґ '
(
ґґ' (
)
ґґ( )
{
µµ 	
int
¶¶ 
hash
¶¶ 
=
¶¶ 
$num
¶¶ 
;
¶¶ 
	unchecked
·· 
{
ёё 
foreach
№№ 
(
№№ 
var
№№ 
cell
№№ !
in
№№" $
cells
№№% *
)
№№* +
{
єє 
hash
»» 
=
»» 
hash
»» 
*
»»  !
$num
»»" $
+
»»% &
cell
»»' +
.
»»+ ,
GetHashCode
»», 7
(
»»7 8
)
»»8 9
;
»»9 :
}
јј 
}
ЅЅ 
return
ѕѕ 
hash
ѕѕ 
;
ѕѕ 
}
її 	
[
ДД 	
Serializable
ДД	 
]
ДД 
public
ЕЕ 
class
ЕЕ 
	BrushCell
ЕЕ 
{
ЖЖ 	
public
КК 

GameObject
КК 

gameObject
КК (
{
КК) *
get
КК+ .
{
КК/ 0
return
КК1 7
m_GameObject
КК8 D
;
ККD E
}
ККF G
set
ККH K
{
ККL M
m_GameObject
ККN Z
=
КК[ \
value
КК] b
;
ККb c
}
ККd e
}
ККf g
public
ОО 
Vector3
ОО 
offset
ОО !
{
ОО" #
get
ОО$ '
{
ОО( )
return
ОО* 0
m_Offset
ОО1 9
;
ОО9 :
}
ОО; <
set
ОО= @
{
ООA B
m_Offset
ООC K
=
ООL M
value
ООN S
;
ООS T
}
ООU V
}
ООW X
public
ТТ 
Vector3
ТТ 
scale
ТТ  
{
ТТ! "
get
ТТ# &
{
ТТ' (
return
ТТ) /
m_Scale
ТТ0 7
;
ТТ7 8
}
ТТ9 :
set
ТТ; >
{
ТТ? @
m_Scale
ТТA H
=
ТТI J
value
ТТK P
;
ТТP Q
}
ТТR S
}
ТТT U
public
ЦЦ 

Quaternion
ЦЦ 
orientation
ЦЦ )
{
ЦЦ* +
get
ЦЦ, /
{
ЦЦ0 1
return
ЦЦ2 8
m_Orientation
ЦЦ9 F
;
ЦЦF G
}
ЦЦH I
set
ЦЦJ M
{
ЦЦN O
m_Orientation
ЦЦP ]
=
ЦЦ^ _
value
ЦЦ` e
;
ЦЦe f
}
ЦЦg h
}
ЦЦi j
[
ШШ 
SerializeField
ШШ 
]
ШШ 
private
ЩЩ 

GameObject
ЩЩ 
m_GameObject
ЩЩ +
;
ЩЩ+ ,
[
ЪЪ 
SerializeField
ЪЪ 
]
ЪЪ 
Vector3
ЫЫ 
m_Offset
ЫЫ 
=
ЫЫ 
Vector3
ЫЫ &
.
ЫЫ& '
zero
ЫЫ' +
;
ЫЫ+ ,
[
ЬЬ 
SerializeField
ЬЬ 
]
ЬЬ 
Vector3
ЭЭ 
m_Scale
ЭЭ 
=
ЭЭ 
Vector3
ЭЭ %
.
ЭЭ% &
one
ЭЭ& )
;
ЭЭ) *
[
ЮЮ 
SerializeField
ЮЮ 
]
ЮЮ 

Quaternion
ЯЯ 
m_Orientation
ЯЯ $
=
ЯЯ% &

Quaternion
ЯЯ' 1
.
ЯЯ1 2
identity
ЯЯ2 :
;
ЯЯ: ;
public
ее 
override
ее 
int
ее 
GetHashCode
ее  +
(
ее+ ,
)
ее, -
{
жж 
int
зз 
hash
зз 
=
зз 
$num
зз 
;
зз 
	unchecked
ии 
{
йй 
hash
кк 
=
кк 

gameObject
кк %
!=
кк& (
null
кк) -
?
кк. /

gameObject
кк0 :
.
кк: ;
GetInstanceID
кк; H
(
ккH I
)
ккI J
:
ккK L
$num
ккM N
;
ккN O
hash
лл 
=
лл 
hash
лл 
*
лл  !
$num
лл" $
+
лл% &
m_Offset
лл' /
.
лл/ 0
GetHashCode
лл0 ;
(
лл; <
)
лл< =
;
лл= >
hash
мм 
=
мм 
hash
мм 
*
мм  !
$num
мм" $
+
мм% &
m_Scale
мм' .
.
мм. /
GetHashCode
мм/ :
(
мм: ;
)
мм; <
;
мм< =
hash
нн 
=
нн 
hash
нн 
*
нн  !
$num
нн" $
+
нн% &
m_Orientation
нн' 4
.
нн4 5
GetHashCode
нн5 @
(
нн@ A
)
ннA B
;
ннB C
}
оо 
return
пп 
hash
пп 
;
пп 
}
рр 
}
сс 	
}
тт 
[
чч 
CustomEditor
чч 
(
чч 
typeof
чч 
(
чч 
GameObjectBrush
чч (
)
чч( )
)
чч) *
]
чч* +
public
шш 

class
шш #
GameObjectBrushEditor
шш &
:
шш' (!
GridBrushEditorBase
шш) <
{
щщ 
public
ээ 
GameObjectBrush
ээ 
brush
ээ $
{
ээ% &
get
ээ' *
{
ээ+ ,
return
ээ- 3
target
ээ4 :
as
ээ; =
GameObjectBrush
ээ> M
;
ээM N
}
ээO P
}
ээQ R
public
€€ 
override
€€ 
void
€€ 
OnPaintSceneGUI
€€ ,
(
€€, -

GridLayout
€€- 7

gridLayout
€€8 B
,
€€B C

GameObject
€€D N
brushTarget
€€O Z
,
€€Z [
	BoundsInt
€€\ e
position
€€f n
,
€€n o
GridBrushBase
€€p }
.
€€} ~
Tool€€~ ‚
tool€€ѓ ‡
,€€‡ €
bool€€‰ Ќ
	executing€€Ћ —
)€€— 
{
‰‰ 	
	BoundsInt
ЉЉ 
	gizmoRect
ЉЉ 
=
ЉЉ  !
position
ЉЉ" *
;
ЉЉ* +
if
ЊЊ 
(
ЊЊ 
tool
ЊЊ 
==
ЊЊ 
GridBrushBase
ЊЊ %
.
ЊЊ% &
Tool
ЊЊ& *
.
ЊЊ* +
Paint
ЊЊ+ 0
||
ЊЊ1 3
tool
ЊЊ4 8
==
ЊЊ9 ;
GridBrushBase
ЊЊ< I
.
ЊЊI J
Tool
ЊЊJ N
.
ЊЊN O
Erase
ЊЊO T
)
ЊЊT U
	gizmoRect
ЌЌ 
=
ЌЌ 
new
ЌЌ 
	BoundsInt
ЌЌ  )
(
ЌЌ) *
position
ЌЌ* 2
.
ЌЌ2 3
min
ЌЌ3 6
-
ЌЌ7 8
brush
ЌЌ9 >
.
ЌЌ> ?
pivot
ЌЌ? D
,
ЌЌD E
brush
ЌЌF K
.
ЌЌK L
size
ЌЌL P
)
ЌЌP Q
;
ЌЌQ R
base
ЏЏ 
.
ЏЏ 
OnPaintSceneGUI
ЏЏ  
(
ЏЏ  !

gridLayout
ЏЏ! +
,
ЏЏ+ ,
brushTarget
ЏЏ- 8
,
ЏЏ8 9
	gizmoRect
ЏЏ: C
,
ЏЏC D
tool
ЏЏE I
,
ЏЏI J
	executing
ЏЏK T
)
ЏЏT U
;
ЏЏU V
}
ђђ 	
public
–– 
override
–– 
void
–– !
OnPaintInspectorGUI
–– 0
(
––0 1
)
––1 2
{
—— 	
	GUILayout
 
.
 
Label
 
(
 
$str
 O
)
O P
;
P Q
	GUILayout
™™ 
.
™™ 
Label
™™ 
(
™™ 
$str
™™ W
)
™™W X
;
™™X Y
}
љљ 	
}
›› 
}њњ  µ
™C:\Users\Davis\Desktop\Facultad\5to Periodo\Tecnologias\Pacman\ClientePacman\Packages\com.unity.2d.tilemap.extras\Editor\Brushes\GroupBrush\GroupBrush.cs
	namespace 	
UnityEditor
 
. 
Tilemaps 
{ 
[ 
CustomGridBrush 
( 
true 
, 
false  
,  !
false" '
,' (
$str) 6
)6 7
]7 8
public 

class 

GroupBrush 
: 
	GridBrush '
{ 
public 

Vector3Int 
gap 
{ 	
get 
{ 
return 
m_Gap 
; 
}  !
set 
{ 
m_Gap 
= 
value 
; 

OnValidate 
( 
) 
; 
} 
} 	
public 

Vector3Int 
limit 
{ 	
get   
{   
return   
m_Limit    
;    !
}  " #
set!! 
{"" 
m_Limit## 
=## 
value## 
;##  

OnValidate$$ 
($$ 
)$$ 
;$$ 
}%% 
}&& 	
private(( 
int((  
visitedLocationsSize(( (
{)) 	
get** 
{** 
return** 
(** 
m_Limit** !
.**! "
x**" #
***$ %
$num**& '
+**( )
$num*** +
)**+ ,
***- .
(**/ 0
m_Limit**0 7
.**7 8
y**8 9
***: ;
$num**< =
+**> ?
$num**@ A
)**A B
***C D
(**E F
m_Limit**F M
.**M N
z**N O
***P Q
$num**R S
+**T U
$num**V W
)**W X
;**X Y
}**Z [
}++ 	
[-- 	
SerializeField--	 
]-- 
private.. 

Vector3Int.. 
m_Gap..  
=..! "

Vector3Int..# -
...- .
one... 1
;..1 2
[// 	
SerializeField//	 
]// 
private00 

Vector3Int00 
m_Limit00 "
=00# $

Vector3Int00% /
.00/ 0
one000 3
*004 5
$num006 7
;007 8
[11 	
SerializeField11	 
]11 
private22 
BitArray22 
m_VisitedLocations22 +
=22, -
new22. 1
BitArray222 :
(22: ;
$num22; <
*22= >
$num22? @
*22A B
$num22C D
)22D E
;22E F
[33 	
SerializeField33	 
]33 
private44 
Stack44 
<44 

Vector3Int44  
>44  !
m_NextPosition44" 0
=441 2
new443 6
Stack447 <
<44< =

Vector3Int44= G
>44G H
(44H I
)44I J
;44J K
private66 
void66 

OnValidate66 
(66  
)66  !
{77 	
if88 
(88 
m_Gap88 
.88 
x88 
<88 
$num88 
)88 
m_Gap99 
.99 
x99 
=99 
$num99 
;99 
if:: 
(:: 
m_Gap:: 
.:: 
y:: 
<:: 
$num:: 
):: 
m_Gap;; 
.;; 
y;; 
=;; 
$num;; 
;;; 
if<< 
(<< 
m_Gap<< 
.<< 
z<< 
<<< 
$num<< 
)<< 
m_Gap== 
.== 
z== 
=== 
$num== 
;== 
if>> 
(>> 
m_Limit>> 
.>> 
x>> 
<>> 
$num>> 
)>> 
m_Limit?? 
.?? 
x?? 
=?? 
$num?? 
;?? 
if@@ 
(@@ 
m_Limit@@ 
.@@ 
y@@ 
<@@ 
$num@@ 
)@@ 
m_LimitAA 
.AA 
yAA 
=AA 
$numAA 
;AA 
ifBB 
(BB 
m_LimitBB 
.BB 
zBB 
<BB 
$numBB 
)BB 
m_LimitCC 
.CC 
zCC 
=CC 
$numCC 
;CC 
ifDD 
(DD 
m_VisitedLocationsDD "
.DD" #
LengthDD# )
!=DD* , 
visitedLocationsSizeDD- A
)DDA B
m_VisitedLocationsEE "
=EE# $
newEE% (
BitArrayEE) 1
(EE1 2 
visitedLocationsSizeEE2 F
)EEF G
;EEG H
}FF 	
publicPP 
overridePP 
voidPP 
PickPP !
(PP! "

GridLayoutPP" ,

gridLayoutPP- 7
,PP7 8

GameObjectPP9 C
brushTargetPPD O
,PPO P
	BoundsIntPPQ Z
positionPP[ c
,PPc d

Vector3IntPPe o
	pickStartPPp y
)PPy z
{QQ 	
ifSS 
(SS 
positionSS 
.SS 
sizeSS 
.SS 
xSS 
>SS  !
$numSS" #
||SS$ &
positionSS' /
.SS/ 0
sizeSS0 4
.SS4 5
ySS5 6
>SS7 8
$numSS9 :
||SS; =
positionSS> F
.SSF G
sizeSSG K
.SSK L
zSSL M
>SSN O
$numSSP Q
)SSQ R
{TT 
baseUU 
.UU 
PickUU 
(UU 

gridLayoutUU $
,UU$ %
brushTargetUU& 1
,UU1 2
positionUU3 ;
,UU; <
	pickStartUU= F
)UUF G
;UUG H
returnVV 
;VV 
}WW 
TilemapYY 
tilemapYY 
=YY 
brushTargetYY )
.YY) *
GetComponentYY* 6
<YY6 7
TilemapYY7 >
>YY> ?
(YY? @
)YY@ A
;YYA B
ifZZ 
(ZZ 
tilemapZZ 
==ZZ 
nullZZ 
)ZZ  
return[[ 
;[[ 
Reset]] 
(]] 
)]] 
;]] 

Vector3Int`` 
limitOrigin`` "
=``# $
position``% -
.``- .
position``. 6
-``7 8
limit``9 >
;``> ?

Vector3Intaa 
	limitSizeaa  
=aa! "

Vector3Intaa# -
.aa- .
oneaa. 1
+aa2 3
limitaa4 9
*aa: ;
$numaa< =
;aa= >
	BoundsIntbb 
limitBoundsbb !
=bb" #
newbb$ '
	BoundsIntbb( 1
(bb1 2
limitOriginbb2 =
,bb= >
	limitSizebb? H
)bbH I
;bbI J
	BoundsIntcc 

pickBoundscc  
=cc! "
newcc# &
	BoundsIntcc' 0
(cc0 1
positioncc1 9
.cc9 :
positioncc: B
,ccB C

Vector3IntccD N
.ccN O
oneccO R
)ccR S
;ccS T
m_VisitedLocationsee 
.ee 
SetAllee %
(ee% &
falseee& +
)ee+ ,
;ee, -
m_VisitedLocationsff 
.ff 
Setff "
(ff" #
GetIndexff# +
(ff+ ,
positionff, 4
.ff4 5
positionff5 =
,ff= >
limitOriginff? J
,ffJ K
	limitSizeffL U
)ffU V
,ffV W
trueffX \
)ff\ ]
;ff] ^
m_NextPositiongg 
.gg 
Cleargg  
(gg  !
)gg! "
;gg" #
m_NextPositionhh 
.hh 
Pushhh 
(hh  
positionhh  (
.hh( )
positionhh) 1
)hh1 2
;hh2 3
whilejj 
(jj 
m_NextPositionjj !
.jj! "
Countjj" '
>jj( )
$numjj* +
)jj+ ,
{kk 

Vector3Intll 
nextll 
=ll  !
m_NextPositionll" 0
.ll0 1
Popll1 4
(ll4 5
)ll5 6
;ll6 7
ifmm 
(mm 
tilemapmm 
.mm 
GetTilemm #
(mm# $
nextmm$ (
)mm( )
!=mm* ,
nullmm- 1
)mm1 2
{nn 
Encapsulateoo 
(oo  
refoo  #

pickBoundsoo$ .
,oo. /
nextoo0 4
)oo4 5
;oo5 6
	BoundsIntpp 
	gapBoundspp '
=pp( )
newpp* -
	BoundsIntpp. 7
(pp7 8
nextpp8 <
-pp= >
gappp? B
,ppB C

Vector3IntppD N
.ppN O
oneppO R
+ppS T
gapppU X
*ppY Z
$numpp[ \
)pp\ ]
;pp] ^
foreachqq 
(qq 
varqq  
gapPositionqq! ,
inqq- /
	gapBoundsqq0 9
.qq9 :
allPositionsWithinqq: L
)qqL M
{rr 
ifss 
(ss 
!ss 
limitBoundsss (
.ss( )
Containsss) 1
(ss1 2
gapPositionss2 =
)ss= >
)ss> ?
continuett $
;tt$ %
intuu 
indexuu !
=uu" #
GetIndexuu$ ,
(uu, -
gapPositionuu- 8
,uu8 9
limitOriginuu: E
,uuE F
	limitSizeuuG P
)uuP Q
;uuQ R
ifvv 
(vv 
!vv 
m_VisitedLocationsvv /
.vv/ 0
Getvv0 3
(vv3 4
indexvv4 9
)vv9 :
)vv: ;
{ww 
m_NextPositionxx *
.xx* +
Pushxx+ /
(xx/ 0
gapPositionxx0 ;
)xx; <
;xx< =
m_VisitedLocationsyy .
.yy. /
Setyy/ 2
(yy2 3
indexyy3 8
,yy8 9
trueyy: >
)yy> ?
;yy? @
}zz 
}{{ 
}|| 
}}} 
UpdateSizeAndPivot 
( 

pickBounds )
.) *
size* .
,. /
position0 8
.8 9
position9 A
-B C

pickBoundsD N
.N O
positionO W
)W X
;X Y
foreach
ЃЃ 
(
ЃЃ 

Vector3Int
ЃЃ 
pos
ЃЃ  #
in
ЃЃ$ &

pickBounds
ЃЃ' 1
.
ЃЃ1 2 
allPositionsWithin
ЃЃ2 D
)
ЃЃD E
{
‚‚ 

Vector3Int
ѓѓ 
brushPosition
ѓѓ (
=
ѓѓ) *
new
ѓѓ+ .

Vector3Int
ѓѓ/ 9
(
ѓѓ9 :
pos
ѓѓ: =
.
ѓѓ= >
x
ѓѓ> ?
-
ѓѓ@ A

pickBounds
ѓѓB L
.
ѓѓL M
x
ѓѓM N
,
ѓѓN O
pos
ѓѓP S
.
ѓѓS T
y
ѓѓT U
-
ѓѓV W

pickBounds
ѓѓX b
.
ѓѓb c
y
ѓѓc d
,
ѓѓd e
pos
ѓѓf i
.
ѓѓi j
z
ѓѓj k
-
ѓѓl m

pickBounds
ѓѓn x
.
ѓѓx y
z
ѓѓy z
)
ѓѓz {
;
ѓѓ{ |
if
„„ 
(
„„  
m_VisitedLocations
„„ &
.
„„& '
Get
„„' *
(
„„* +
GetIndex
„„+ 3
(
„„3 4
pos
„„4 7
,
„„7 8
limitOrigin
„„9 D
,
„„D E
	limitSize
„„F O
)
„„O P
)
„„P Q
)
„„Q R
{
…… 
PickCell
†† 
(
†† 
pos
††  
,
††  !
brushPosition
††" /
,
††/ 0
tilemap
††1 8
)
††8 9
;
††9 :
}
‡‡ 
}
€€ 
}
‰‰ 	
private
‹‹ 
void
‹‹ 
Encapsulate
‹‹  
(
‹‹  !
ref
‹‹! $
	BoundsInt
‹‹% .
bounds
‹‹/ 5
,
‹‹5 6

Vector3Int
‹‹7 A
position
‹‹B J
)
‹‹J K
{
ЊЊ 	
if
ЌЌ 
(
ЌЌ 
bounds
ЌЌ 
.
ЌЌ 
Contains
ЌЌ 
(
ЌЌ  
position
ЌЌ  (
)
ЌЌ( )
)
ЌЌ) *
return
ЋЋ 
;
ЋЋ 
if
ђђ 
(
ђђ 
position
ђђ 
.
ђђ 
x
ђђ 
<
ђђ 
bounds
ђђ #
.
ђђ# $
position
ђђ$ ,
.
ђђ, -
x
ђђ- .
)
ђђ. /
{
‘‘ 
var
’’ 
increase
’’ 
=
’’ 
bounds
’’ %
.
’’% &
x
’’& '
-
’’( )
position
’’* 2
.
’’2 3
x
’’3 4
;
’’4 5
bounds
““ 
.
““ 
position
““ 
=
““  !
new
““" %

Vector3Int
““& 0
(
““0 1
position
““1 9
.
““9 :
x
““: ;
,
““; <
bounds
““= C
.
““C D
y
““D E
,
““E F
bounds
““G M
.
““M N
z
““N O
)
““O P
;
““P Q
bounds
”” 
.
”” 
size
”” 
=
”” 
new
”” !

Vector3Int
””" ,
(
””, -
bounds
””- 3
.
””3 4
size
””4 8
.
””8 9
x
””9 :
+
””; <
increase
””= E
,
””E F
bounds
””G M
.
””M N
size
””N R
.
””R S
y
””S T
,
””T U
bounds
””V \
.
””\ ]
size
””] a
.
””a b
z
””b c
)
””c d
;
””d e
}
•• 
if
–– 
(
–– 
position
–– 
.
–– 
x
–– 
>=
–– 
bounds
–– $
.
––$ %
xMax
––% )
)
––) *
{
—— 
var
 
increase
 
=
 
position
 '
.
' (
x
( )
-
* +
bounds
, 2
.
2 3
xMax
3 7
+
8 9
$num
: ;
;
; <
bounds
™™ 
.
™™ 
size
™™ 
=
™™ 
new
™™ !

Vector3Int
™™" ,
(
™™, -
bounds
™™- 3
.
™™3 4
size
™™4 8
.
™™8 9
x
™™9 :
+
™™; <
increase
™™= E
,
™™E F
bounds
™™G M
.
™™M N
size
™™N R
.
™™R S
y
™™S T
,
™™T U
bounds
™™V \
.
™™\ ]
size
™™] a
.
™™a b
z
™™b c
)
™™c d
;
™™d e
}
љљ 
if
›› 
(
›› 
position
›› 
.
›› 
y
›› 
<
›› 
bounds
›› #
.
››# $
position
››$ ,
.
››, -
y
››- .
)
››. /
{
њњ 
var
ќќ 
increase
ќќ 
=
ќќ 
bounds
ќќ %
.
ќќ% &
y
ќќ& '
-
ќќ( )
position
ќќ* 2
.
ќќ2 3
y
ќќ3 4
;
ќќ4 5
bounds
ћћ 
.
ћћ 
position
ћћ 
=
ћћ  !
new
ћћ" %

Vector3Int
ћћ& 0
(
ћћ0 1
bounds
ћћ1 7
.
ћћ7 8
x
ћћ8 9
,
ћћ9 :
position
ћћ; C
.
ћћC D
y
ћћD E
,
ћћE F
bounds
ћћG M
.
ћћM N
z
ћћN O
)
ћћO P
;
ћћP Q
bounds
џџ 
.
џџ 
size
џџ 
=
џџ 
new
џџ !

Vector3Int
џџ" ,
(
џџ, -
bounds
џџ- 3
.
џџ3 4
size
џџ4 8
.
џџ8 9
x
џџ9 :
,
џџ: ;
bounds
џџ< B
.
џџB C
size
џџC G
.
џџG H
y
џџH I
+
џџJ K
increase
џџL T
,
џџT U
bounds
џџV \
.
џџ\ ]
size
џџ] a
.
џџa b
z
џџb c
)
џџc d
;
џџd e
}
   
if
ЎЎ 
(
ЎЎ 
position
ЎЎ 
.
ЎЎ 
y
ЎЎ 
>=
ЎЎ 
bounds
ЎЎ $
.
ЎЎ$ %
yMax
ЎЎ% )
)
ЎЎ) *
{
ўў 
var
ЈЈ 
increase
ЈЈ 
=
ЈЈ 
position
ЈЈ '
.
ЈЈ' (
y
ЈЈ( )
-
ЈЈ* +
bounds
ЈЈ, 2
.
ЈЈ2 3
yMax
ЈЈ3 7
+
ЈЈ8 9
$num
ЈЈ: ;
;
ЈЈ; <
bounds
¤¤ 
.
¤¤ 
size
¤¤ 
=
¤¤ 
new
¤¤ !

Vector3Int
¤¤" ,
(
¤¤, -
bounds
¤¤- 3
.
¤¤3 4
size
¤¤4 8
.
¤¤8 9
x
¤¤9 :
,
¤¤: ;
bounds
¤¤< B
.
¤¤B C
size
¤¤C G
.
¤¤G H
y
¤¤H I
+
¤¤J K
increase
¤¤L T
,
¤¤T U
bounds
¤¤V \
.
¤¤\ ]
size
¤¤] a
.
¤¤a b
z
¤¤b c
)
¤¤c d
;
¤¤d e
}
ҐҐ 
if
¦¦ 
(
¦¦ 
position
¦¦ 
.
¦¦ 
z
¦¦ 
<
¦¦ 
bounds
¦¦ #
.
¦¦# $
position
¦¦$ ,
.
¦¦, -
z
¦¦- .
)
¦¦. /
{
§§ 
var
ЁЁ 
increase
ЁЁ 
=
ЁЁ 
bounds
ЁЁ %
.
ЁЁ% &
z
ЁЁ& '
-
ЁЁ( )
position
ЁЁ* 2
.
ЁЁ2 3
z
ЁЁ3 4
;
ЁЁ4 5
bounds
©© 
.
©© 
position
©© 
=
©©  !
new
©©" %

Vector3Int
©©& 0
(
©©0 1
bounds
©©1 7
.
©©7 8
x
©©8 9
,
©©9 :
bounds
©©; A
.
©©A B
y
©©B C
,
©©C D
position
©©E M
.
©©M N
z
©©N O
)
©©O P
;
©©P Q
bounds
ЄЄ 
.
ЄЄ 
size
ЄЄ 
=
ЄЄ 
new
ЄЄ !

Vector3Int
ЄЄ" ,
(
ЄЄ, -
bounds
ЄЄ- 3
.
ЄЄ3 4
size
ЄЄ4 8
.
ЄЄ8 9
x
ЄЄ9 :
,
ЄЄ: ;
bounds
ЄЄ< B
.
ЄЄB C
size
ЄЄC G
.
ЄЄG H
y
ЄЄH I
,
ЄЄI J
bounds
ЄЄK Q
.
ЄЄQ R
size
ЄЄR V
.
ЄЄV W
z
ЄЄW X
+
ЄЄY Z
increase
ЄЄ[ c
)
ЄЄc d
;
ЄЄd e
}
«« 
if
¬¬ 
(
¬¬ 
position
¬¬ 
.
¬¬ 
z
¬¬ 
>=
¬¬ 
bounds
¬¬ $
.
¬¬$ %
zMax
¬¬% )
)
¬¬) *
{
­­ 
var
®® 
increase
®® 
=
®® 
position
®® '
.
®®' (
z
®®( )
-
®®* +
bounds
®®, 2
.
®®2 3
zMax
®®3 7
+
®®8 9
$num
®®: ;
;
®®; <
bounds
ЇЇ 
.
ЇЇ 
size
ЇЇ 
=
ЇЇ 
new
ЇЇ !

Vector3Int
ЇЇ" ,
(
ЇЇ, -
bounds
ЇЇ- 3
.
ЇЇ3 4
size
ЇЇ4 8
.
ЇЇ8 9
x
ЇЇ9 :
,
ЇЇ: ;
bounds
ЇЇ< B
.
ЇЇB C
size
ЇЇC G
.
ЇЇG H
y
ЇЇH I
,
ЇЇI J
bounds
ЇЇK Q
.
ЇЇQ R
size
ЇЇR V
.
ЇЇV W
z
ЇЇW X
+
ЇЇY Z
increase
ЇЇ[ c
)
ЇЇc d
;
ЇЇd e
}
°° 
}
±± 	
private
іі 
int
іі 
GetIndex
іі 
(
іі 

Vector3Int
іі '
position
іі( 0
,
іі0 1

Vector3Int
іі2 <
origin
іі= C
,
ііC D

Vector3Int
ііE O
size
ііP T
)
ііT U
{
ґґ 	
return
µµ 
(
µµ 
position
µµ 
.
µµ 
z
µµ 
-
µµ  
origin
µµ! '
.
µµ' (
z
µµ( )
)
µµ) *
*
µµ+ ,
size
µµ- 1
.
µµ1 2
y
µµ2 3
*
µµ4 5
size
µµ6 :
.
µµ: ;
x
µµ; <
+
¶¶ 
(
¶¶ 
position
¶¶ 
.
¶¶ 
y
¶¶  
-
¶¶! "
origin
¶¶# )
.
¶¶) *
y
¶¶* +
)
¶¶+ ,
*
¶¶- .
size
¶¶/ 3
.
¶¶3 4
x
¶¶4 5
+
·· 
(
·· 
position
·· 
.
·· 
x
··  
-
··! "
origin
··# )
.
··) *
x
··* +
)
··+ ,
;
··, -
}
ёё 	
private
єє 
void
єє 
PickCell
єє 
(
єє 

Vector3Int
єє (
position
єє) 1
,
єє1 2

Vector3Int
єє3 =
brushPosition
єє> K
,
єєK L
Tilemap
єєM T
tilemap
єєU \
)
єє\ ]
{
»» 	
if
јј 
(
јј 
tilemap
јј 
!=
јј 
null
јј 
)
јј  
{
ЅЅ 
SetTile
ѕѕ 
(
ѕѕ 
brushPosition
ѕѕ %
,
ѕѕ% &
tilemap
ѕѕ' .
.
ѕѕ. /
GetTile
ѕѕ/ 6
(
ѕѕ6 7
position
ѕѕ7 ?
)
ѕѕ? @
)
ѕѕ@ A
;
ѕѕA B
	SetMatrix
її 
(
її 
brushPosition
її '
,
її' (
tilemap
її) 0
.
її0 1 
GetTransformMatrix
її1 C
(
їїC D
position
їїD L
)
їїL M
)
їїM N
;
їїN O
SetColor
АА 
(
АА 
brushPosition
АА &
,
АА& '
tilemap
АА( /
.
АА/ 0
GetColor
АА0 8
(
АА8 9
position
АА9 A
)
ААA B
)
ААB C
;
ААC D
}
ББ 
}
ВВ 	
[
ЗЗ 	
MenuItem
ЗЗ	 
(
ЗЗ 
$str
ЗЗ 5
)
ЗЗ5 6
]
ЗЗ6 7
public
ИИ 
static
ИИ 
void
ИИ 
CreateBrush
ИИ &
(
ИИ& '
)
ИИ' (
{
ЙЙ 	
string
КК 
path
КК 
=
КК 
EditorUtility
КК '
.
КК' ($
SaveFilePanelInProject
КК( >
(
КК> ?
$str
КК? Q
,
ККQ R
$str
ККS d
,
ККd e
$str
ККf m
,
ККm n
$strККo Ѓ
,ККЃ ‚
$strККѓ ‹
)КК‹ Њ
;ККЊ Ќ
if
ММ 
(
ММ 
path
ММ 
==
ММ 
$str
ММ 
)
ММ 
return
НН 
;
НН 
AssetDatabase
ПП 
.
ПП 
CreateAsset
ПП %
(
ПП% &
ScriptableObject
ПП& 6
.
ПП6 7
CreateInstance
ПП7 E
<
ППE F

GroupBrush
ППF P
>
ППP Q
(
ППQ R
)
ППR S
,
ППS T
path
ППU Y
)
ППY Z
;
ППZ [
}
РР 	
}
СС 
[
ЦЦ 
CustomEditor
ЦЦ 
(
ЦЦ 
typeof
ЦЦ 
(
ЦЦ 

GroupBrush
ЦЦ #
)
ЦЦ# $
)
ЦЦ$ %
]
ЦЦ% &
public
ЧЧ 

class
ЧЧ 
GroupBrushEditor
ЧЧ !
:
ЧЧ" #
GridBrushEditor
ЧЧ$ 3
{
ШШ 
}
ЩЩ 
}ЪЪ “¬
—C:\Users\Davis\Desktop\Facultad\5to Periodo\Tecnologias\Pacman\ClientePacman\Packages\com.unity.2d.tilemap.extras\Editor\Brushes\LineBrush\LineBrush.cs
	namespace 	
UnityEditor
 
. 
Tilemaps 
{ 
[ 
CustomGridBrush 
( 
true 
, 
false  
,  !
false" '
,' (
$str) 5
)5 6
]6 7
[ 
CreateAssetMenu 
( 
fileName 
= 
$str  0
,0 1
menuName2 :
=; <
$str= Q
)Q R
]R S
public 

class 
	LineBrush 
: 
	GridBrush &
{ 
public 
bool 
lineStartActive #
;# $
public 
bool 
fillGaps 
; 
public 

Vector3Int 
	lineStart #
=$ %

Vector3Int& 0
.0 1
zero1 5
;5 6
public"" 
bool"" 
IsMoving"" 
{"" 
get"" "
;""" #
private""$ +
set"", /
;""/ 0
}""1 2
public-- 
override-- 
void-- 
Paint-- "
(--" #

GridLayout--# -
grid--. 2
,--2 3

GameObject--4 >
brushTarget--? J
,--J K

Vector3Int--L V
position--W _
)--_ `
{.. 	
if// 
(// 
lineStartActive// 
)//  
{00 

Vector2Int11 
startPos11 #
=11$ %
new11& )

Vector2Int11* 4
(114 5
	lineStart115 >
.11> ?
x11? @
,11@ A
	lineStart11B K
.11K L
y11L M
)11M N
;11N O

Vector2Int22 
endPos22 !
=22" #
new22$ '

Vector2Int22( 2
(222 3
position223 ;
.22; <
x22< =
,22= >
position22? G
.22G H
y22H I
)22I J
;22J K
if33 
(33 
startPos33 
==33 
endPos33  &
)33& '
base44 
.44 
Paint44 
(44 
grid44 #
,44# $
brushTarget44% 0
,440 1
position442 :
)44: ;
;44; <
else55 
{66 
foreach77 
(77 
var77  
point77! &
in77' )
GetPointsOnLine77* 9
(779 :
startPos77: B
,77B C
endPos77D J
,77J K
fillGaps77L T
)77T U
)77U V
{88 

Vector3Int99 "
paintPos99# +
=99, -
new99. 1

Vector3Int992 <
(99< =
point99= B
.99B C
x99C D
,99D E
point99F K
.99K L
y99L M
,99M N
position99O W
.99W X
z99X Y
)99Y Z
;99Z [
base:: 
.:: 
Paint:: "
(::" #
grid::# '
,::' (
brushTarget::) 4
,::4 5
paintPos::6 >
)::> ?
;::? @
};; 
}<< 
lineStartActive== 
===  !
false==" '
;==' (
}>> 
else?? 
if?? 
(?? 
IsMoving?? 
)?? 
{@@ 
baseAA 
.AA 
PaintAA 
(AA 
gridAA 
,AA  
brushTargetAA! ,
,AA, -
positionAA. 6
)AA6 7
;AA7 8
}BB 
elseCC 
{DD 
	lineStartEE 
=EE 
positionEE $
;EE$ %
lineStartActiveFF 
=FF  !
trueFF" &
;FF& '
}GG 
}HH 	
publicJJ 
overrideJJ 
voidJJ 
	MoveStartJJ &
(JJ& '

GridLayoutJJ' 1

gridLayoutJJ2 <
,JJ< =

GameObjectJJ> H
brushTargetJJI T
,JJT U
	BoundsIntJJV _
positionJJ` h
)JJh i
{KK 	
baseLL 
.LL 
	MoveStartLL 
(LL 

gridLayoutLL %
,LL% &
brushTargetLL' 2
,LL2 3
positionLL4 <
)LL< =
;LL= >
IsMovingMM 
=MM 
trueMM 
;MM 
}NN 	
publicPP 
overridePP 
voidPP 
MoveEndPP $
(PP$ %

GridLayoutPP% /

gridLayoutPP0 :
,PP: ;

GameObjectPP< F
brushTargetPPG R
,PPR S
	BoundsIntPPT ]
positionPP^ f
)PPf g
{QQ 	
baseRR 
.RR 
MoveEndRR 
(RR 

gridLayoutRR #
,RR# $
brushTargetRR% 0
,RR0 1
positionRR2 :
)RR: ;
;RR; <
IsMovingSS 
=SS 
falseSS 
;SS 
}TT 	
publicYY 
staticYY 
IEnumerableYY !
<YY! "

Vector2IntYY" ,
>YY, -
GetPointsOnLineYY. =
(YY= >

Vector2IntYY> H
startPosYYI Q
,YYQ R

Vector2IntYYS ]
endPosYY^ d
,YYd e
boolYYf j
fillGapsYYk s
)YYs t
{ZZ 	
var[[ 
points[[ 
=[[ 
GetPointsOnLine[[ (
([[( )
startPos[[) 1
,[[1 2
endPos[[3 9
)[[9 :
;[[: ;
if\\ 
(\\ 
fillGaps\\ 
)\\ 
{]] 
var^^ 
rise^^ 
=^^ 
endPos^^ !
.^^! "
y^^" #
-^^$ %
startPos^^& .
.^^. /
y^^/ 0
;^^0 1
var__ 
run__ 
=__ 
endPos__  
.__  !
x__! "
-__# $
startPos__% -
.__- .
x__. /
;__/ 0
ifaa 
(aa 
riseaa 
!=aa 
$numaa 
||aa  
runaa! $
!=aa% '
$numaa( )
)aa) *
{bb 
varcc 

extraStartcc "
=cc# $
startPoscc% -
;cc- .
vardd 
extraEnddd  
=dd! "
endPosdd# )
;dd) *
ifgg 
(gg 
Mathfgg 
.gg 
Absgg !
(gg! "
risegg" &
)gg& '
>=gg( *
Mathfgg+ 0
.gg0 1
Absgg1 4
(gg4 5
rungg5 8
)gg8 9
)gg9 :
{hh 
ifjj 
(jj 
risejj  
>jj! "
$numjj# $
)jj$ %
{kk 

extraStartll &
.ll& '
yll' (
+=ll) +
$numll, -
;ll- .
extraEndmm $
.mm$ %
ymm% &
+=mm' )
$nummm* +
;mm+ ,
}nn 
elsepp 
{qq 

extraStartss &
.ss& '
yss' (
-=ss) +
$numss, -
;ss- .
extraEndtt $
.tt$ %
ytt% &
-=tt' )
$numtt* +
;tt+ ,
}uu 
}vv 
elseww 
{xx 
if{{ 
({{ 
run{{ 
>{{  !
$num{{" #
){{# $
{|| 

extraStart}} &
.}}& '
x}}' (
+=}}) +
$num}}, -
;}}- .
extraEnd~~ $
.~~$ %
x~~% &
+=~~' )
$num~~* +
;~~+ ,
} 
else
ЃЃ 
{
‚‚ 

extraStart
ѓѓ &
.
ѓѓ& '
x
ѓѓ' (
-=
ѓѓ) +
$num
ѓѓ, -
;
ѓѓ- .
extraEnd
„„ $
.
„„$ %
x
„„% &
-=
„„' )
$num
„„* +
;
„„+ ,
}
…… 
}
†† 
var
€€ 
extraPoints
€€ #
=
€€$ %
GetPointsOnLine
€€& 5
(
€€5 6

extraStart
€€6 @
,
€€@ A
extraEnd
€€B J
)
€€J K
;
€€K L
extraPoints
‰‰ 
=
‰‰  !
extraPoints
‰‰" -
.
‰‰- .
Except
‰‰. 4
(
‰‰4 5
new
‰‰5 8
[
‰‰8 9
]
‰‰9 :
{
‰‰; <
extraEnd
‰‰= E
}
‰‰F G
)
‰‰G H
;
‰‰H I
points
ЉЉ 
=
ЉЉ 
points
ЉЉ #
.
ЉЉ# $
Union
ЉЉ$ )
(
ЉЉ) *
extraPoints
ЉЉ* 5
)
ЉЉ5 6
;
ЉЉ6 7
}
‹‹ 
}
ЌЌ 
return
ЏЏ 
points
ЏЏ 
;
ЏЏ 
}
ђђ 	
public
™™ 
static
™™ 
IEnumerable
™™ !
<
™™! "

Vector2Int
™™" ,
>
™™, -
GetPointsOnLine
™™. =
(
™™= >

Vector2Int
™™> H
p1
™™I K
,
™™K L

Vector2Int
™™M W
p2
™™X Z
)
™™Z [
{
љљ 	
int
›› 
x0
›› 
=
›› 
p1
›› 
.
›› 
x
›› 
;
›› 
int
њњ 
y0
њњ 
=
њњ 
p1
њњ 
.
њњ 
y
њњ 
;
њњ 
int
ќќ 
x1
ќќ 
=
ќќ 
p2
ќќ 
.
ќќ 
x
ќќ 
;
ќќ 
int
ћћ 
y1
ћћ 
=
ћћ 
p2
ћћ 
.
ћћ 
y
ћћ 
;
ћћ 
bool
   
steep
   
=
   
Math
   
.
   
Abs
   !
(
  ! "
y1
  " $
-
  % &
y0
  ' )
)
  ) *
>
  + ,
Math
  - 1
.
  1 2
Abs
  2 5
(
  5 6
x1
  6 8
-
  9 :
x0
  ; =
)
  = >
;
  > ?
if
ЎЎ 
(
ЎЎ 
steep
ЎЎ 
)
ЎЎ 
{
ўў 
int
ЈЈ 
t
ЈЈ 
;
ЈЈ 
t
¤¤ 
=
¤¤ 
x0
¤¤ 
;
¤¤ 
x0
ҐҐ 
=
ҐҐ 
y0
ҐҐ 
;
ҐҐ 
y0
¦¦ 
=
¦¦ 
t
¦¦ 
;
¦¦ 
t
§§ 
=
§§ 
x1
§§ 
;
§§ 
x1
ЁЁ 
=
ЁЁ 
y1
ЁЁ 
;
ЁЁ 
y1
©© 
=
©© 
t
©© 
;
©© 
}
ЄЄ 
if
«« 
(
«« 
x0
«« 
>
«« 
x1
«« 
)
«« 
{
¬¬ 
int
­­ 
t
­­ 
;
­­ 
t
®® 
=
®® 
x0
®® 
;
®® 
x0
ЇЇ 
=
ЇЇ 
x1
ЇЇ 
;
ЇЇ 
x1
°° 
=
°° 
t
°° 
;
°° 
t
±± 
=
±± 
y0
±± 
;
±± 
y0
ІІ 
=
ІІ 
y1
ІІ 
;
ІІ 
y1
іі 
=
іі 
t
іі 
;
іі 
}
ґґ 
int
µµ 
dx
µµ 
=
µµ 
x1
µµ 
-
µµ 
x0
µµ 
;
µµ 
int
¶¶ 
dy
¶¶ 
=
¶¶ 
Math
¶¶ 
.
¶¶ 
Abs
¶¶ 
(
¶¶ 
y1
¶¶  
-
¶¶! "
y0
¶¶# %
)
¶¶% &
;
¶¶& '
int
·· 
error
·· 
=
·· 
dx
·· 
/
·· 
$num
·· 
;
·· 
int
ёё 
ystep
ёё 
=
ёё 
(
ёё 
y0
ёё 
<
ёё 
y1
ёё  
)
ёё  !
?
ёё" #
$num
ёё$ %
:
ёё& '
-
ёё( )
$num
ёё) *
;
ёё* +
int
№№ 
y
№№ 
=
№№ 
y0
№№ 
;
№№ 
for
єє 
(
єє 
int
єє 
x
єє 
=
єє 
x0
єє 
;
єє 
x
єє 
<=
єє !
x1
єє" $
;
єє$ %
x
єє& '
++
єє' )
)
єє) *
{
»» 
yield
јј 
return
јј 
new
јј  

Vector2Int
јј! +
(
јј+ ,
(
јј, -
steep
јј- 2
?
јј3 4
y
јј5 6
:
јј7 8
x
јј9 :
)
јј: ;
,
јј; <
(
јј= >
steep
јј> C
?
јјD E
x
јјF G
:
јјH I
y
јјJ K
)
јјK L
)
јјL M
;
јјM N
error
ЅЅ 
=
ЅЅ 
error
ЅЅ 
-
ЅЅ 
dy
ЅЅ  "
;
ЅЅ" #
if
ѕѕ 
(
ѕѕ 
error
ѕѕ 
<
ѕѕ 
$num
ѕѕ 
)
ѕѕ 
{
її 
y
АА 
+=
АА 
ystep
АА 
;
АА 
error
ББ 
+=
ББ 
dx
ББ 
;
ББ  
}
ВВ 
}
ГГ 
yield
ДД 
break
ДД 
;
ДД 
}
ЕЕ 	
}
ЖЖ 
[
ЛЛ 
CustomEditor
ЛЛ 
(
ЛЛ 
typeof
ЛЛ 
(
ЛЛ 
	LineBrush
ЛЛ "
)
ЛЛ" #
)
ЛЛ# $
]
ЛЛ$ %
public
ММ 

class
ММ 
LineBrushEditor
ММ  
:
ММ! "
GridBrushEditor
ММ# 2
{
НН 
private
ОО 
	LineBrush
ОО 
	lineBrush
ОО #
{
ОО$ %
get
ОО& )
{
ОО* +
return
ОО, 2
target
ОО3 9
as
ОО: <
	LineBrush
ОО= F
;
ООF G
}
ООH I
}
ООJ K
private
ПП 
Tilemap
ПП 
lastTilemap
ПП #
;
ПП# $
public
ЪЪ 
override
ЪЪ 
void
ЪЪ 
OnPaintSceneGUI
ЪЪ ,
(
ЪЪ, -

GridLayout
ЪЪ- 7
grid
ЪЪ8 <
,
ЪЪ< =

GameObject
ЪЪ> H
brushTarget
ЪЪI T
,
ЪЪT U
	BoundsInt
ЪЪV _
position
ЪЪ` h
,
ЪЪh i
GridBrushBase
ЪЪj w
.
ЪЪw x
Tool
ЪЪx |
toolЪЪ} Ѓ
,ЪЪЃ ‚
boolЪЪѓ ‡
	executingЪЪ€ ‘
)ЪЪ‘ ’
{
ЫЫ 	
base
ЬЬ 
.
ЬЬ 
OnPaintSceneGUI
ЬЬ  
(
ЬЬ  !
grid
ЬЬ! %
,
ЬЬ% &
brushTarget
ЬЬ' 2
,
ЬЬ2 3
position
ЬЬ4 <
,
ЬЬ< =
tool
ЬЬ> B
,
ЬЬB C
	executing
ЬЬD M
)
ЬЬM N
;
ЬЬN O
if
ЭЭ 
(
ЭЭ 
	lineBrush
ЭЭ 
.
ЭЭ 
lineStartActive
ЭЭ )
)
ЭЭ) *
{
ЮЮ 
Tilemap
ЯЯ 
tilemap
ЯЯ 
=
ЯЯ  !
brushTarget
ЯЯ" -
.
ЯЯ- .
GetComponent
ЯЯ. :
<
ЯЯ: ;
Tilemap
ЯЯ; B
>
ЯЯB C
(
ЯЯC D
)
ЯЯD E
;
ЯЯE F
if
аа 
(
аа 
tilemap
аа 
!=
аа 
null
аа #
)
аа# $
lastTilemap
бб 
=
бб  !
tilemap
бб" )
;
бб) *

Vector2Int
дд 
startPos
дд #
=
дд$ %
new
дд& )

Vector2Int
дд* 4
(
дд4 5
	lineBrush
дд5 >
.
дд> ?
	lineStart
дд? H
.
ддH I
x
ддI J
,
ддJ K
	lineBrush
ддL U
.
ддU V
	lineStart
ддV _
.
дд_ `
y
дд` a
)
ддa b
;
ддb c

Vector2Int
ее 
endPos
ее !
=
ее" #
new
ее$ '

Vector2Int
ее( 2
(
ее2 3
position
ее3 ;
.
ее; <
x
ее< =
,
ее= >
position
ее? G
.
ееG H
y
ееH I
)
ееI J
;
ееJ K
if
жж 
(
жж 
startPos
жж 
==
жж 
endPos
жж  &
)
жж& '
PaintPreview
зз  
(
зз  !
grid
зз! %
,
зз% &
brushTarget
зз' 2
,
зз2 3
position
зз4 <
.
зз< =
min
зз= @
)
зз@ A
;
ззA B
else
ии 
{
йй 
foreach
кк 
(
кк 
var
кк  
point
кк! &
in
кк' )
	LineBrush
кк* 3
.
кк3 4
GetPointsOnLine
кк4 C
(
ккC D
startPos
ккD L
,
ккL M
endPos
ккN T
,
ккT U
	lineBrush
ккV _
.
кк_ `
fillGaps
кк` h
)
ккh i
)
ккi j
{
лл 

Vector3Int
мм "
paintPos
мм# +
=
мм, -
new
мм. 1

Vector3Int
мм2 <
(
мм< =
point
мм= B
.
ммB C
x
ммC D
,
ммD E
point
ммF K
.
ммK L
y
ммL M
,
ммM N
position
ммO W
.
ммW X
z
ммX Y
)
ммY Z
;
ммZ [
PaintPreview
нн $
(
нн$ %
grid
нн% )
,
нн) *
brushTarget
нн+ 6
,
нн6 7
paintPos
нн8 @
)
нн@ A
;
ннA B
}
оо 
}
пп 
if
сс 
(
сс 
Event
сс 
.
сс 
current
сс !
.
сс! "
type
сс" &
==
сс' )
	EventType
сс* 3
.
сс3 4
Repaint
сс4 ;
)
сс; <
{
тт 
var
уу 
min
уу 
=
уу 
	lineBrush
уу '
.
уу' (
	lineStart
уу( 1
;
уу1 2
var
фф 
max
фф 
=
фф 
	lineBrush
фф '
.
фф' (
	lineStart
фф( 1
+
фф2 3
position
фф4 <
.
фф< =
size
фф= A
;
ффA B
GL
чч 
.
чч 

PushMatrix
чч !
(
чч! "
)
чч" #
;
чч# $
GL
шш 
.
шш 

MultMatrix
шш !
(
шш! "
GUI
шш" %
.
шш% &
matrix
шш& ,
)
шш, -
;
шш- .
GL
щщ 
.
щщ 
Begin
щщ 
(
щщ 
GL
щщ 
.
щщ  
LINES
щщ  %
)
щщ% &
;
щщ& '
Handles
ъъ 
.
ъъ 
color
ъъ !
=
ъъ" #
Color
ъъ$ )
.
ъъ) *
blue
ъъ* .
;
ъъ. /
Handles
ыы 
.
ыы 
DrawLine
ыы $
(
ыы$ %
new
ыы% (
Vector3
ыы) 0
(
ыы0 1
min
ыы1 4
.
ыы4 5
x
ыы5 6
,
ыы6 7
min
ыы8 ;
.
ыы; <
y
ыы< =
,
ыы= >
min
ыы? B
.
ыыB C
z
ыыC D
)
ыыD E
,
ыыE F
new
ыыG J
Vector3
ыыK R
(
ыыR S
max
ыыS V
.
ыыV W
x
ыыW X
,
ыыX Y
min
ыыZ ]
.
ыы] ^
y
ыы^ _
,
ыы_ `
min
ыыa d
.
ыыd e
z
ыыe f
)
ыыf g
)
ыыg h
;
ыыh i
Handles
ьь 
.
ьь 
DrawLine
ьь $
(
ьь$ %
new
ьь% (
Vector3
ьь) 0
(
ьь0 1
max
ьь1 4
.
ьь4 5
x
ьь5 6
,
ьь6 7
min
ьь8 ;
.
ьь; <
y
ьь< =
,
ьь= >
min
ьь? B
.
ььB C
z
ььC D
)
ььD E
,
ььE F
new
ььG J
Vector3
ььK R
(
ььR S
max
ььS V
.
ььV W
x
ььW X
,
ььX Y
max
ььZ ]
.
ьь] ^
y
ьь^ _
,
ьь_ `
min
ььa d
.
ььd e
z
ььe f
)
ььf g
)
ььg h
;
ььh i
Handles
ээ 
.
ээ 
DrawLine
ээ $
(
ээ$ %
new
ээ% (
Vector3
ээ) 0
(
ээ0 1
max
ээ1 4
.
ээ4 5
x
ээ5 6
,
ээ6 7
max
ээ8 ;
.
ээ; <
y
ээ< =
,
ээ= >
min
ээ? B
.
ээB C
z
ээC D
)
ээD E
,
ээE F
new
ээG J
Vector3
ээK R
(
ээR S
min
ээS V
.
ээV W
x
ээW X
,
ээX Y
max
ээZ ]
.
ээ] ^
y
ээ^ _
,
ээ_ `
min
ээa d
.
ээd e
z
ээe f
)
ээf g
)
ээg h
;
ээh i
Handles
юю 
.
юю 
DrawLine
юю $
(
юю$ %
new
юю% (
Vector3
юю) 0
(
юю0 1
min
юю1 4
.
юю4 5
x
юю5 6
,
юю6 7
max
юю8 ;
.
юю; <
y
юю< =
,
юю= >
min
юю? B
.
ююB C
z
ююC D
)
ююD E
,
ююE F
new
ююG J
Vector3
ююK R
(
ююR S
min
ююS V
.
ююV W
x
ююW X
,
ююX Y
min
ююZ ]
.
юю] ^
y
юю^ _
,
юю_ `
min
ююa d
.
ююd e
z
ююe f
)
ююf g
)
ююg h
;
ююh i
GL
яя 
.
яя 
End
яя 
(
яя 
)
яя 
;
яя 
GL
ЂЂ 
.
ЂЂ 
	PopMatrix
ЂЂ  
(
ЂЂ  !
)
ЂЂ! "
;
ЂЂ" #
}
ЃЃ 
}
‚‚ 
}
ѓѓ 	
public
€€ 
override
€€ 
void
€€ 
ClearPreview
€€ )
(
€€) *
)
€€* +
{
‰‰ 	
base
ЉЉ 
.
ЉЉ 
ClearPreview
ЉЉ 
(
ЉЉ 
)
ЉЉ 
;
ЉЉ  
if
‹‹ 
(
‹‹ 
lastTilemap
‹‹ 
!=
‹‹ 
null
‹‹ #
)
‹‹# $
{
ЊЊ 
lastTilemap
ЌЌ 
.
ЌЌ (
ClearAllEditorPreviewTiles
ЌЌ 6
(
ЌЌ6 7
)
ЌЌ7 8
;
ЌЌ8 9
lastTilemap
ЋЋ 
=
ЋЋ 
null
ЋЋ "
;
ЋЋ" #
}
ЏЏ 
}
ђђ 	
}
‘‘ 
}’’ З^
›C:\Users\Davis\Desktop\Facultad\5to Periodo\Tecnologias\Pacman\ClientePacman\Packages\com.unity.2d.tilemap.extras\Editor\Brushes\PrefabBrush\PrefabBrush.cs
	namespace 	
UnityEditor
 
. 
Tilemaps 
{ 
[

 
CreateAssetMenu

 
(

 
fileName

 
=

 
$str

  .
,

. /
menuName

0 8
=

9 :
$str

; Q
)

Q R
]

R S
[ 
CustomGridBrush 
( 
false 
, 
true  
,  !
false" '
,' (
$str) 7
)7 8
]8 9
public 

class 
PrefabBrush 
: 
	GridBrush (
{ 
private 
const 
float 
k_PerlinOffset *
=+ ,
$num- 4
;4 5
public 

GameObject 
[ 
] 
	m_Prefabs %
;% &
public 
float 
m_PerlinScale "
=# $
$num% )
;) *
public 
Vector3 
m_Anchor 
=  !
new" %
Vector3& -
(- .
$num. 2
,2 3
$num4 8
,8 9
$num: >
)> ?
;? @
private 

GameObject 
prev_brushTarget +
;+ ,
private 

Vector3Int 
prev_position (
=) *

Vector3Int+ 5
.5 6
one6 9
*: ;
Int32< A
.A B
MaxValueB J
;J K
public&& 
override&& 
void&& 
Paint&& "
(&&" #

GridLayout&&# -
grid&&. 2
,&&2 3

GameObject&&4 >
brushTarget&&? J
,&&J K

Vector3Int&&L V
position&&W _
)&&_ `
{'' 	
if(( 
((( 
position(( 
==(( 
prev_position(( )
)(() *
{)) 
return** 
;** 
}++ 
prev_position,, 
=,, 
position,, $
;,,$ %
if-- 
(-- 
brushTarget-- 
)-- 
{-- 
prev_brushTarget..  
=..! "
brushTarget..# .
;... /
}// 
brushTarget00 
=00 
prev_brushTarget00 *
;00* +
if33 
(33 
brushTarget33 
.33 
layer33 !
==33" $
$num33% '
)33' (
return44 
;44 
int66 
index66 
=66 
Mathf66 
.66 
Clamp66 #
(66# $
Mathf66$ )
.66) *

FloorToInt66* 4
(664 5
GetPerlinValue665 C
(66C D
position66D L
,66L M
m_PerlinScale66N [
,66[ \
k_PerlinOffset66] k
)66k l
*66m n
	m_Prefabs66o x
.66x y
Length66y 
)	66 Ђ
,
66Ђ Ѓ
$num
66‚ ѓ
,
66ѓ „
	m_Prefabs
66… Ћ
.
66Ћ Џ
Length
66Џ •
-
66– —
$num
66 ™
)
66™ љ
;
66љ ›

GameObject77 
prefab77 
=77 
	m_Prefabs77  )
[77) *
index77* /
]77/ 0
;770 1

GameObject88 
instance88 
=88  !
(88" #

GameObject88# -
)88- .
PrefabUtility88/ <
.88< =
InstantiatePrefab88= N
(88N O
prefab88O U
)88U V
;88V W
if99 
(99 
instance99 
!=99 
null99  
)99  !
{:: 
Erase;; 
(;; 
grid;; 
,;; 
brushTarget;; '
,;;' (
position;;) 1
);;1 2
;;;2 3
Undo== 
.== !
MoveGameObjectToScene== *
(==* +
instance==+ 3
,==3 4
brushTarget==5 @
.==@ A
scene==A F
,==F G
$str==H W
)==W X
;==X Y
Undo>> 
.>> %
RegisterCreatedObjectUndo>> .
(>>. /
(>>/ 0
Object>>0 6
)>>6 7
instance>>7 ?
,>>? @
$str>>A P
)>>P Q
;>>Q R
instance?? 
.?? 
	transform?? "
.??" #
	SetParent??# ,
(??, -
brushTarget??- 8
.??8 9
	transform??9 B
)??B C
;??C D
instance@@ 
.@@ 
	transform@@ "
.@@" #
position@@# +
=@@, -
grid@@. 2
.@@2 3
LocalToWorld@@3 ?
(@@? @
grid@@@ D
.@@D E#
CellToLocalInterpolated@@E \
(@@\ ]
position@@] e
+@@f g
m_Anchor@@h p
)@@p q
)@@q r
;@@r s
}AA 
}BB 	
publicKK 
overrideKK 
voidKK 
EraseKK "
(KK" #

GridLayoutKK# -
gridKK. 2
,KK2 3

GameObjectKK4 >
brushTargetKK? J
,KKJ K

Vector3IntKKL V
positionKKW _
)KK_ `
{LL 	
ifMM 
(MM 
brushTargetMM 
)MM 
{NN 
prev_brushTargetOO  
=OO! "
brushTargetOO# .
;OO. /
}PP 
brushTargetQQ 
=QQ 
prev_brushTargetQQ *
;QQ* +
ifSS 
(SS 
brushTargetSS 
.SS 
layerSS !
==SS" $
$numSS% '
)SS' (
returnTT 
;TT 
	TransformVV 
erasedVV 
=VV 
GetObjectInCellVV .
(VV. /
gridVV/ 3
,VV3 4
brushTargetVV5 @
.VV@ A
	transformVVA J
,VVJ K
positionVVL T
)VVT U
;VVU V
ifWW 
(WW 
erasedWW 
!=WW 
nullWW 
)WW 
UndoXX 
.XX "
DestroyObjectImmediateXX +
(XX+ ,
erasedXX, 2
.XX2 3

gameObjectXX3 =
)XX= >
;XX> ?
}YY 	
private[[ 
static[[ 
	Transform[[  
GetObjectInCell[[! 0
([[0 1

GridLayout[[1 ;
grid[[< @
,[[@ A
	Transform[[B K
parent[[L R
,[[R S

Vector3Int[[T ^
position[[_ g
)[[g h
{\\ 	
int]] 

childCount]] 
=]] 
parent]] #
.]]# $

childCount]]$ .
;]]. /
Vector3^^ 
min^^ 
=^^ 
grid^^ 
.^^ 
LocalToWorld^^ +
(^^+ ,
grid^^, 0
.^^0 1#
CellToLocalInterpolated^^1 H
(^^H I
position^^I Q
)^^Q R
)^^R S
;^^S T
Vector3__ 
max__ 
=__ 
grid__ 
.__ 
LocalToWorld__ +
(__+ ,
grid__, 0
.__0 1#
CellToLocalInterpolated__1 H
(__H I
position__I Q
+__R S

Vector3Int__T ^
.__^ _
one___ b
)__b c
)__c d
;__d e
Bounds`` 
bounds`` 
=`` 
new`` 
Bounds``  &
(``& '
(``' (
max``( +
+``, -
min``. 1
)``1 2
*``2 3
$num``3 6
,``6 7
max``8 ;
-``< =
min``> A
)``A B
;``B C
forbb 
(bb 
intbb 
ibb 
=bb 
$numbb 
;bb 
ibb 
<bb 

childCountbb  *
;bb* +
ibb, -
++bb- /
)bb/ 0
{cc 
	Transformdd 
childdd 
=dd  !
parentdd" (
.dd( )
GetChilddd) 1
(dd1 2
idd2 3
)dd3 4
;dd4 5
ifee 
(ee 
boundsee 
.ee 
Containsee #
(ee# $
childee$ )
.ee) *
positionee* 2
)ee2 3
)ee3 4
returnff 
childff  
;ff  !
}gg 
returnhh 
nullhh 
;hh 
}ii 	
privatekk 
statickk 
floatkk 
GetPerlinValuekk +
(kk+ ,

Vector3Intkk, 6
positionkk7 ?
,kk? @
floatkkA F
scalekkG L
,kkL M
floatkkN S
offsetkkT Z
)kkZ [
{ll 	
returnmm 
Mathfmm 
.mm 
PerlinNoisemm $
(mm$ %
(mm% &
positionmm& .
.mm. /
xmm/ 0
+mm1 2
offsetmm3 9
)mm9 :
*mm: ;
scalemm; @
,mm@ A
(mmB C
positionmmC K
.mmK L
ymmL M
+mmN O
offsetmmP V
)mmV W
*mmW X
scalemmX ]
)mm] ^
;mm^ _
}nn 	
}oo 
[tt 
CustomEditortt 
(tt 
typeoftt 
(tt 
PrefabBrushtt $
)tt$ %
)tt% &
]tt& '
publicuu 

classuu 
PrefabBrushEditoruu "
:uu# $
GridBrushEditoruu% 4
{vv 
privateww 
PrefabBrushww 
prefabBrushww '
{ww( )
getww* -
{ww. /
returnww0 6
targetww7 =
asww> @
PrefabBrushwwA L
;wwL M
}wwN O
}wwP Q
privateyy 
SerializedPropertyyy "
	m_Prefabsyy# ,
;yy, -
privatezz 
SerializedPropertyzz "
m_Anchorzz# +
;zz+ ,
private{{ 
SerializedObject{{  
m_SerializedObject{{! 3
;{{3 4
	protected}} 
override}} 
void}} 
OnEnable}}  (
(}}( )
)}}) *
{~~ 	
base 
. 
OnEnable 
( 
) 
;  
m_SerializedObject
ЂЂ 
=
ЂЂ  
new
ЂЂ! $
SerializedObject
ЂЂ% 5
(
ЂЂ5 6
target
ЂЂ6 <
)
ЂЂ< =
;
ЂЂ= >
	m_Prefabs
ЃЃ 
=
ЃЃ  
m_SerializedObject
ЃЃ *
.
ЃЃ* +
FindProperty
ЃЃ+ 7
(
ЃЃ7 8
$str
ЃЃ8 C
)
ЃЃC D
;
ЃЃD E
m_Anchor
‚‚ 
=
‚‚  
m_SerializedObject
‚‚ )
.
‚‚) *
FindProperty
‚‚* 6
(
‚‚6 7
$str
‚‚7 A
)
‚‚A B
;
‚‚B C
}
ѓѓ 	
public
‰‰ 
override
‰‰ 
void
‰‰ !
OnPaintInspectorGUI
‰‰ 0
(
‰‰0 1
)
‰‰1 2
{
ЉЉ 	 
m_SerializedObject
‹‹ 
.
‹‹ &
UpdateIfRequiredOrScript
‹‹ 7
(
‹‹7 8
)
‹‹8 9
;
‹‹9 :
prefabBrush
ЊЊ 
.
ЊЊ 
m_PerlinScale
ЊЊ %
=
ЊЊ& '
EditorGUILayout
ЊЊ( 7
.
ЊЊ7 8
Slider
ЊЊ8 >
(
ЊЊ> ?
$str
ЊЊ? M
,
ЊЊM N
prefabBrush
ЊЊO Z
.
ЊЊZ [
m_PerlinScale
ЊЊ[ h
,
ЊЊh i
$num
ЊЊj p
,
ЊЊp q
$num
ЊЊr x
)
ЊЊx y
;
ЊЊy z
EditorGUILayout
ЌЌ 
.
ЌЌ 
PropertyField
ЌЌ )
(
ЌЌ) *
	m_Prefabs
ЌЌ* 3
,
ЌЌ3 4
true
ЌЌ5 9
)
ЌЌ9 :
;
ЌЌ: ;
EditorGUILayout
ЋЋ 
.
ЋЋ 
PropertyField
ЋЋ )
(
ЋЋ) *
m_Anchor
ЋЋ* 2
)
ЋЋ2 3
;
ЋЋ3 4 
m_SerializedObject
ЏЏ 
.
ЏЏ 0
"ApplyModifiedPropertiesWithoutUndo
ЏЏ A
(
ЏЏA B
)
ЏЏB C
;
ЏЏC D
}
ђђ 	
}
‘‘ 
}’’ ВЫ
›C:\Users\Davis\Desktop\Facultad\5to Periodo\Tecnologias\Pacman\ClientePacman\Packages\com.unity.2d.tilemap.extras\Editor\Brushes\RandomBrush\RandomBrush.cs
	namespace 	
UnityEditor
 
. 
Tilemaps 
{ 
[ 
CustomGridBrush 
( 
false 
, 
false !
,! "
false# (
,( )
$str* 8
)8 9
]9 :
[ 
CreateAssetMenu 
( 
fileName 
= 
$str  2
,2 3
menuName4 <
== >
$str? U
)U V
]V W
public 

class 
RandomBrush 
: 
	GridBrush (
{ 
internal 
struct 
SizeEnumerator &
:' (
IEnumerator) 4
<4 5

Vector3Int5 ?
>? @
{ 	
private 
readonly 

Vector3Int '
_min( ,
,, -
_max. 2
,2 3
_delta4 :
;: ;
private 

Vector3Int 
_current '
;' (
public 
SizeEnumerator !
(! "

Vector3Int" ,
min- 0
,0 1

Vector3Int2 <
max= @
,@ A

Vector3IntB L
deltaM R
)R S
{ 
_min 
= 
_current 
=  !
min" %
;% &
_max 
= 
max 
; 
_delta 
= 
delta 
; 
Reset 
( 
) 
; 
} 
public 
SizeEnumerator !
GetEnumerator" /
(/ 0
)0 1
{ 
return   
this   
;   
}!! 
public## 
bool## 
MoveNext##  
(##  !
)##! "
{$$ 
if%% 
(%% 
_current%% 
.%% 
z%% 
>=%% !
_max%%" &
.%%& '
z%%' (
)%%( )
return&& 
false&&  
;&&  !
_current(( 
.(( 
x(( 
+=(( 
_delta(( $
.(($ %
x((% &
;((& '
if)) 
()) 
_current)) 
.)) 
x)) 
>=)) !
_max))" &
.))& '
x))' (
)))( )
{** 
_current++ 
.++ 
x++ 
=++  
_min++! %
.++% &
x++& '
;++' (
_current,, 
.,, 
y,, 
+=,, !
_delta,," (
.,,( )
y,,) *
;,,* +
if-- 
(-- 
_current--  
.--  !
y--! "
>=--# %
_max--& *
.--* +
y--+ ,
)--, -
{.. 
_current//  
.//  !
y//! "
=//# $
_min//% )
.//) *
y//* +
;//+ ,
_current00  
.00  !
z00! "
+=00# %
_delta00& ,
.00, -
z00- .
;00. /
if11 
(11 
_current11 $
.11$ %
z11% &
>=11' )
_max11* .
.11. /
z11/ 0
)110 1
return22 "
false22# (
;22( )
}33 
}44 
return55 
true55 
;55 
}66 
public88 
void88 
Reset88 
(88 
)88 
{99 
_current:: 
=:: 
_min:: 
;::  
_current;; 
.;; 
x;; 
-=;; 
_delta;; $
.;;$ %
x;;% &
;;;& '
}<< 
public>> 

Vector3Int>> 
Current>> %
{>>& '
get>>( +
{>>, -
return>>. 4
_current>>5 =
;>>= >
}>>? @
}>>A B
object@@ 
IEnumerator@@ 
.@@ 
Current@@ &
{@@' (
get@@) ,
{@@- .
return@@/ 5
Current@@6 =
;@@= >
}@@? @
}@@A B
voidBB 
IDisposableBB 
.BB 
DisposeBB $
(BB$ %
)BB% &
{BB' (
}BB( )
}CC 	
[HH 	
SerializableHH	 
]HH 
publicII 
structII 
RandomTileSetII #
{JJ 	
publicLL 
TileBaseLL 
[LL 
]LL 
randomTilesLL )
;LL) *
}MM 	
publicRR 

Vector3IntRR 
randomTileSetSizeRR +
=RR, -

Vector3IntRR. 8
.RR8 9
oneRR9 <
;RR< =
publicWW 
RandomTileSetWW 
[WW 
]WW 
randomTileSetsWW -
;WW- .
public\\ 
bool\\ 
pickRandomTiles\\ #
;\\# $
publicaa 
boolaa 
addToRandomTilesaa $
;aa$ %
publicjj 
overridejj 
voidjj 
Paintjj "
(jj" #

GridLayoutjj# -
gridjj. 2
,jj2 3

GameObjectjj4 >
brushTargetjj? J
,jjJ K

Vector3IntjjL V
positionjjW _
)jj_ `
{kk 	
ifll 
(ll 
randomTileSetsll 
!=ll !
nullll" &
&&ll' )
randomTileSetsll* 8
.ll8 9
Lengthll9 ?
>ll@ A
$numllB C
)llC D
{mm 
ifnn 
(nn 
brushTargetnn 
==nn  "
nullnn# '
)nn' (
returnoo 
;oo 
varqq 
tilemapqq 
=qq 
brushTargetqq )
.qq) *
GetComponentqq* 6
<qq6 7
Tilemapqq7 >
>qq> ?
(qq? @
)qq@ A
;qqA B
ifrr 
(rr 
tilemaprr 
==rr 
nullrr #
)rr# $
returnss 
;ss 

Vector3Intuu 
minuu 
=uu  
positionuu! )
-uu* +
pivotuu, 1
;uu1 2
foreachvv 
(vv 
varvv 
startLocationvv *
invv+ -
newvv. 1
SizeEnumeratorvv2 @
(vv@ A
minvvA D
,vvD E
minvvF I
+vvJ K
sizevvL P
,vvP Q
randomTileSetSizevvR c
)vvc d
)vvd e
{ww 
varxx 
randomTileSetxx %
=xx& '
randomTileSetsxx( 6
[xx6 7
(xx7 8
intxx8 ;
)xx; <
(xx= >
randomTileSetsxx> L
.xxL M
LengthxxM S
*xxT U
UnityEnginexxV a
.xxa b
Randomxxb h
.xxh i
valuexxi n
)xxn o
]xxo p
;xxp q
varyy 
randomBoundsyy $
=yy% &
newyy' *
	BoundsIntyy+ 4
(yy4 5
startLocationyy5 B
,yyB C
randomTileSetSizeyyD U
)yyU V
;yyV W
tilemapzz 
.zz 
SetTilesBlockzz )
(zz) *
randomBoundszz* 6
,zz6 7
randomTileSetzz8 E
.zzE F
randomTileszzF Q
)zzQ R
;zzR S
}{{ 
}|| 
else}} 
{~~ 
base 
. 
Paint 
( 
grid 
,  
brushTarget! ,
,, -
position. 6
)6 7
;7 8
}
ЂЂ 
}
ЃЃ 	
public
‹‹ 
override
‹‹ 
void
‹‹ 
Pick
‹‹ !
(
‹‹! "

GridLayout
‹‹" ,

gridLayout
‹‹- 7
,
‹‹7 8

GameObject
‹‹9 C
brushTarget
‹‹D O
,
‹‹O P
	BoundsInt
‹‹Q Z
bounds
‹‹[ a
,
‹‹a b

Vector3Int
‹‹c m
	pickStart
‹‹n w
)
‹‹w x
{
ЊЊ 	
base
ЌЌ 
.
ЌЌ 
Pick
ЌЌ 
(
ЌЌ 

gridLayout
ЌЌ  
,
ЌЌ  !
brushTarget
ЌЌ" -
,
ЌЌ- .
bounds
ЌЌ/ 5
,
ЌЌ5 6
	pickStart
ЌЌ7 @
)
ЌЌ@ A
;
ЌЌA B
if
ЋЋ 
(
ЋЋ 
!
ЋЋ 
pickRandomTiles
ЋЋ  
)
ЋЋ  !
return
ЏЏ 
;
ЏЏ 
Tilemap
‘‘ 
tilemap
‘‘ 
=
‘‘ 
brushTarget
‘‘ )
.
‘‘) *
GetComponent
‘‘* 6
<
‘‘6 7
Tilemap
‘‘7 >
>
‘‘> ?
(
‘‘? @
)
‘‘@ A
;
‘‘A B
if
’’ 
(
’’ 
tilemap
’’ 
==
’’ 
null
’’ 
)
’’  
return
““ 
;
““ 
int
•• 
i
•• 
=
•• 
$num
•• 
;
•• 
int
–– 
count
–– 
=
–– 
(
–– 
(
–– 
bounds
––  
.
––  !
size
––! %
.
––% &
x
––& '
+
––( )
randomTileSetSize
––* ;
.
––; <
x
––< =
-
––> ?
$num
––@ A
)
––A B
/
––C D
randomTileSetSize
––E V
.
––V W
x
––W X
)
––X Y
*
—— 
(
—— 
(
—— 
bounds
—— "
.
——" #
size
——# '
.
——' (
y
——( )
+
——* +
randomTileSetSize
——, =
.
——= >
y
——> ?
-
——@ A
$num
——B C
)
——C D
/
——E F
randomTileSetSize
——G X
.
——X Y
y
——Y Z
)
——Z [
*
 
(
 
(
 
bounds
 "
.
" #
size
# '
.
' (
z
( )
+
* +
randomTileSetSize
, =
.
= >
z
> ?
-
@ A
$num
B C
)
C D
/
E F
randomTileSetSize
G X
.
X Y
z
Y Z
)
Z [
;
[ \
if
™™ 
(
™™ 
addToRandomTiles
™™  
)
™™  !
{
љљ 
i
›› 
=
›› 
randomTileSets
›› "
!=
››# %
null
››& *
?
››+ ,
randomTileSets
››- ;
.
››; <
Length
››< B
:
››C D
$num
››E F
;
››F G
count
њњ 
+=
њњ 
i
њњ 
;
њњ 
}
ќќ 
Array
ћћ 
.
ћћ 
Resize
ћћ 
(
ћћ 
ref
ћћ 
randomTileSets
ћћ +
,
ћћ+ ,
count
ћћ- 2
)
ћћ2 3
;
ћћ3 4
foreach
   
(
   
var
   
startLocation
   &
in
  ' )
new
  * -
SizeEnumerator
  . <
(
  < =
bounds
  = C
.
  C D
min
  D G
,
  G H
bounds
  I O
.
  O P
max
  P S
,
  S T
randomTileSetSize
  U f
)
  f g
)
  g h
{
ЎЎ 
randomTileSets
ўў 
[
ўў 
i
ўў  
]
ўў  !
.
ўў! "
randomTiles
ўў" -
=
ўў. /
new
ўў0 3
TileBase
ўў4 <
[
ўў< =
randomTileSetSize
ўў= N
.
ўўN O
x
ўўO P
*
ўўQ R
randomTileSetSize
ўўS d
.
ўўd e
y
ўўe f
*
ўўg h
randomTileSetSize
ўўi z
.
ўўz {
z
ўў{ |
]
ўў| }
;
ўў} ~
var
ЈЈ 
randomBounds
ЈЈ  
=
ЈЈ! "
new
ЈЈ# &
	BoundsInt
ЈЈ' 0
(
ЈЈ0 1
startLocation
ЈЈ1 >
,
ЈЈ> ?
randomTileSetSize
ЈЈ@ Q
)
ЈЈQ R
;
ЈЈR S
int
¤¤ 
j
¤¤ 
=
¤¤ 
$num
¤¤ 
;
¤¤ 
foreach
ҐҐ 
(
ҐҐ 

Vector3Int
ҐҐ #
pos
ҐҐ$ '
in
ҐҐ( *
randomBounds
ҐҐ+ 7
.
ҐҐ7 8 
allPositionsWithin
ҐҐ8 J
)
ҐҐJ K
{
¦¦ 
var
§§ 
tile
§§ 
=
§§ 
(
§§  
pos
§§  #
.
§§# $
x
§§$ %
<
§§& '
bounds
§§( .
.
§§. /
max
§§/ 2
.
§§2 3
x
§§3 4
&&
§§5 7
pos
§§8 ;
.
§§; <
y
§§< =
<
§§> ?
bounds
§§@ F
.
§§F G
max
§§G J
.
§§J K
y
§§K L
&&
§§M O
pos
§§P S
.
§§S T
z
§§T U
<
§§V W
bounds
§§X ^
.
§§^ _
max
§§_ b
.
§§b c
z
§§c d
)
§§d e
?
ЁЁ 
tilemap
ЁЁ !
.
ЁЁ! "
GetTile
ЁЁ" )
(
ЁЁ) *
pos
ЁЁ* -
)
ЁЁ- .
:
©© 
null
©© 
;
©© 
randomTileSets
ЄЄ "
[
ЄЄ" #
i
ЄЄ# $
]
ЄЄ$ %
.
ЄЄ% &
randomTiles
ЄЄ& 1
[
ЄЄ1 2
j
ЄЄ2 3
++
ЄЄ3 5
]
ЄЄ5 6
=
ЄЄ7 8
tile
ЄЄ9 =
;
ЄЄ= >
}
«« 
i
¬¬ 
++
¬¬ 
;
¬¬ 
}
­­ 
}
®® 	
}
ЇЇ 
[
ґґ 
CustomEditor
ґґ 
(
ґґ 
typeof
ґґ 
(
ґґ 
RandomBrush
ґґ $
)
ґґ$ %
)
ґґ% &
]
ґґ& '
public
µµ 

class
µµ 
RandomBrushEditor
µµ "
:
µµ# $
GridBrushEditor
µµ% 4
{
¶¶ 
private
·· 
RandomBrush
·· 
randomBrush
·· '
{
··( )
get
··* -
{
··. /
return
··0 6
target
··7 =
as
··> @
RandomBrush
··A L
;
··L M
}
··N O
}
··P Q
private
ёё 

GameObject
ёё 
lastBrushTarget
ёё *
;
ёё* +
public
ББ 
override
ББ 
void
ББ 
PaintPreview
ББ )
(
ББ) *

GridLayout
ББ* 4
grid
ББ5 9
,
ББ9 :

GameObject
ББ; E
brushTarget
ББF Q
,
ББQ R

Vector3Int
ББS ]
position
ББ^ f
)
ББf g
{
ВВ 	
if
ГГ 
(
ГГ 
randomBrush
ГГ 
.
ГГ 
randomTileSets
ГГ *
!=
ГГ+ -
null
ГГ. 2
&&
ГГ3 5
randomBrush
ГГ6 A
.
ГГA B
randomTileSets
ГГB P
.
ГГP Q
Length
ГГQ W
>
ГГX Y
$num
ГГZ [
)
ГГ[ \
{
ДД 
base
ЕЕ 
.
ЕЕ 
PaintPreview
ЕЕ !
(
ЕЕ! "
grid
ЕЕ" &
,
ЕЕ& '
null
ЕЕ( ,
,
ЕЕ, -
position
ЕЕ. 6
)
ЕЕ6 7
;
ЕЕ7 8
if
ЖЖ 
(
ЖЖ 
brushTarget
ЖЖ 
==
ЖЖ  "
null
ЖЖ# '
)
ЖЖ' (
return
ЗЗ 
;
ЗЗ 
var
ЙЙ 
tilemap
ЙЙ 
=
ЙЙ 
brushTarget
ЙЙ )
.
ЙЙ) *
GetComponent
ЙЙ* 6
<
ЙЙ6 7
Tilemap
ЙЙ7 >
>
ЙЙ> ?
(
ЙЙ? @
)
ЙЙ@ A
;
ЙЙA B
if
КК 
(
КК 
tilemap
КК 
==
КК 
null
КК #
)
КК# $
return
ЛЛ 
;
ЛЛ 

Vector3Int
НН 
min
НН 
=
НН  
position
НН! )
-
НН* +
randomBrush
НН, 7
.
НН7 8
pivot
НН8 =
;
НН= >
foreach
ОО 
(
ОО 
var
ОО 
startLocation
ОО *
in
ОО+ -
new
ОО. 1
RandomBrush
ОО2 =
.
ОО= >
SizeEnumerator
ОО> L
(
ООL M
min
ООM P
,
ООP Q
min
ООR U
+
ООV W
randomBrush
ООX c
.
ООc d
size
ООd h
,
ООh i
randomBrush
ООj u
.
ООu v 
randomTileSetSizeООv ‡
)ОО‡ €
)ОО€ ‰
{
ПП 
var
РР 
randomTileSet
РР %
=
РР& '
randomBrush
РР( 3
.
РР3 4
randomTileSets
РР4 B
[
РРB C
(
РРC D
int
РРD G
)
РРG H
(
РРI J
randomBrush
РРJ U
.
РРU V
randomTileSets
РРV d
.
РРd e
Length
РРe k
*
РРl m
UnityEngine
РРn y
.
РРy z
RandomРРz Ђ
.РРЂ Ѓ
valueРРЃ †
)РР† ‡
]РР‡ €
;РР€ ‰
var
СС 
randomBounds
СС $
=
СС% &
new
СС' *
	BoundsInt
СС+ 4
(
СС4 5
startLocation
СС5 B
,
ССB C
randomBrush
ССD O
.
ССO P
randomTileSetSize
ССP a
)
ССa b
;
ССb c
int
ТТ 
j
ТТ 
=
ТТ 
$num
ТТ 
;
ТТ 
foreach
УУ 
(
УУ 

Vector3Int
УУ '
pos
УУ( +
in
УУ, .
randomBounds
УУ/ ;
.
УУ; < 
allPositionsWithin
УУ< N
)
УУN O
{
ФФ 
tilemap
ХХ 
.
ХХ  "
SetEditorPreviewTile
ХХ  4
(
ХХ4 5
pos
ХХ5 8
,
ХХ8 9
randomTileSet
ХХ: G
.
ХХG H
randomTiles
ХХH S
[
ХХS T
j
ХХT U
++
ХХU W
]
ХХW X
)
ХХX Y
;
ХХY Z
}
ЦЦ 
}
ЧЧ 
lastBrushTarget
ШШ 
=
ШШ  !
brushTarget
ШШ" -
;
ШШ- .
}
ЩЩ 
else
ЪЪ 
{
ЫЫ 
base
ЬЬ 
.
ЬЬ 
PaintPreview
ЬЬ !
(
ЬЬ! "
grid
ЬЬ" &
,
ЬЬ& '
brushTarget
ЬЬ( 3
,
ЬЬ3 4
position
ЬЬ5 =
)
ЬЬ= >
;
ЬЬ> ?
}
ЭЭ 
}
ЮЮ 	
public
гг 
override
гг 
void
гг 
ClearPreview
гг )
(
гг) *
)
гг* +
{
дд 	
if
ее 
(
ее 
lastBrushTarget
ее 
!=
ее  "
null
ее# '
)
ее' (
{
жж 
var
зз 
tilemap
зз 
=
зз 
lastBrushTarget
зз -
.
зз- .
GetComponent
зз. :
<
зз: ;
Tilemap
зз; B
>
ззB C
(
ззC D
)
ззD E
;
ззE F
if
ии 
(
ии 
tilemap
ии 
==
ии 
null
ии #
)
ии# $
return
йй 
;
йй 
tilemap
лл 
.
лл (
ClearAllEditorPreviewTiles
лл 2
(
лл2 3
)
лл3 4
;
лл4 5
lastBrushTarget
нн 
=
нн  !
null
нн" &
;
нн& '
}
оо 
else
пп 
{
рр 
base
сс 
.
сс 
ClearPreview
сс !
(
сс! "
)
сс" #
;
сс# $
}
тт 
}
уу 	
public
щщ 
override
щщ 
void
щщ !
OnPaintInspectorGUI
щщ 0
(
щщ0 1
)
щщ1 2
{
ъъ 	
	EditorGUI
ыы 
.
ыы 
BeginChangeCheck
ыы &
(
ыы& '
)
ыы' (
;
ыы( )
randomBrush
ьь 
.
ьь 
pickRandomTiles
ьь '
=
ьь( )
EditorGUILayout
ьь* 9
.
ьь9 :
Toggle
ьь: @
(
ьь@ A
$str
ььA T
,
ььT U
randomBrush
ььV a
.
ььa b
pickRandomTiles
ььb q
)
ььq r
;
ььr s
using
ээ 
(
ээ 
new
ээ 
	EditorGUI
ээ  
.
ээ  !
DisabledScope
ээ! .
(
ээ. /
!
ээ/ 0
randomBrush
ээ0 ;
.
ээ; <
pickRandomTiles
ээ< K
)
ээK L
)
ээL M
{
юю 
randomBrush
яя 
.
яя 
addToRandomTiles
яя ,
=
яя- .
EditorGUILayout
яя/ >
.
яя> ?
Toggle
яя? E
(
яяE F
$str
яяF [
,
яя[ \
randomBrush
яя] h
.
яяh i
addToRandomTiles
яяi y
)
яяy z
;
яяz {
}
ЂЂ 
	EditorGUI
‚‚ 
.
‚‚ 
BeginChangeCheck
‚‚ &
(
‚‚& '
)
‚‚' (
;
‚‚( )
randomBrush
ѓѓ 
.
ѓѓ 
randomTileSetSize
ѓѓ )
=
ѓѓ* +
EditorGUILayout
ѓѓ, ;
.
ѓѓ; <
Vector3IntField
ѓѓ< K
(
ѓѓK L
$str
ѓѓL [
,
ѓѓ[ \
randomBrush
ѓѓ] h
.
ѓѓh i
randomTileSetSize
ѓѓi z
)
ѓѓz {
;
ѓѓ{ |
if
„„ 
(
„„ 
	EditorGUI
„„ 
.
„„ 
EndChangeCheck
„„ (
(
„„( )
)
„„) *
)
„„* +
{
…… 
for
†† 
(
†† 
int
†† 
i
†† 
=
†† 
$num
†† 
;
†† 
i
††  !
<
††" #
randomBrush
††$ /
.
††/ 0
randomTileSets
††0 >
.
††> ?
Length
††? E
;
††E F
++
††G I
i
††I J
)
††J K
{
‡‡ 
int
€€ 
	sizeCount
€€ !
=
€€" #
randomBrush
€€$ /
.
€€/ 0
randomTileSetSize
€€0 A
.
€€A B
x
€€B C
*
€€D E
randomBrush
€€F Q
.
€€Q R
randomTileSetSize
€€R c
.
€€c d
y
€€d e
*
€€f g
randomBrush
‰‰$ /
.
‰‰/ 0
randomTileSetSize
‰‰0 A
.
‰‰A B
z
‰‰B C
;
‰‰C D
randomBrush
ЉЉ 
.
ЉЉ  
randomTileSets
ЉЉ  .
[
ЉЉ. /
i
ЉЉ/ 0
]
ЉЉ0 1
.
ЉЉ1 2
randomTiles
ЉЉ2 =
=
ЉЉ> ?
new
ЉЉ@ C
TileBase
ЉЉD L
[
ЉЉL M
	sizeCount
ЉЉM V
]
ЉЉV W
;
ЉЉW X
}
‹‹ 
}
ЊЊ 
int
ЌЌ  
randomTileSetCount
ЌЌ "
=
ЌЌ# $
EditorGUILayout
ЌЌ% 4
.
ЌЌ4 5
DelayedIntField
ЌЌ5 D
(
ЌЌD E
$str
ЌЌE V
,
ЌЌV W
randomBrush
ЌЌX c
.
ЌЌc d
randomTileSets
ЌЌd r
!=
ЌЌs u
null
ЌЌv z
?
ЌЌ{ |
randomBrushЌЌ} €
.ЌЌ€ ‰
randomTileSetsЌЌ‰ —
.ЌЌ— 
LengthЌЌ ћ
:ЌЌџ  
$numЌЌЎ ў
)ЌЌў Ј
;ЌЌЈ ¤
if
ЋЋ 
(
ЋЋ  
randomTileSetCount
ЋЋ "
<
ЋЋ# $
$num
ЋЋ% &
)
ЋЋ& ' 
randomTileSetCount
ЏЏ "
=
ЏЏ# $
$num
ЏЏ% &
;
ЏЏ& '
if
ђђ 
(
ђђ 
randomBrush
ђђ 
.
ђђ 
randomTileSets
ђђ *
==
ђђ+ -
null
ђђ. 2
||
ђђ3 5
randomBrush
ђђ6 A
.
ђђA B
randomTileSets
ђђB P
.
ђђP Q
Length
ђђQ W
!=
ђђX Z 
randomTileSetCount
ђђ[ m
)
ђђm n
{
‘‘ 
Array
’’ 
.
’’ 
Resize
’’ 
(
’’ 
ref
’’  
randomBrush
’’! ,
.
’’, -
randomTileSets
’’- ;
,
’’; < 
randomTileSetCount
’’= O
)
’’O P
;
’’P Q
for
““ 
(
““ 
int
““ 
i
““ 
=
““ 
$num
““ 
;
““ 
i
““  !
<
““" #
randomBrush
““$ /
.
““/ 0
randomTileSets
““0 >
.
““> ?
Length
““? E
;
““E F
++
““G I
i
““I J
)
““J K
{
”” 
int
•• 
	sizeCount
•• !
=
••" #
randomBrush
••$ /
.
••/ 0
randomTileSetSize
••0 A
.
••A B
x
••B C
*
••D E
randomBrush
••F Q
.
••Q R
randomTileSetSize
••R c
.
••c d
y
••d e
*
••f g
randomBrush
––$ /
.
––/ 0
randomTileSetSize
––0 A
.
––A B
z
––B C
;
––C D
if
—— 
(
—— 
randomBrush
—— #
.
——# $
randomTileSets
——$ 2
[
——2 3
i
——3 4
]
——4 5
.
——5 6
randomTiles
——6 A
==
——B D
null
——E I
||
 
randomBrush
 &
.
& '
randomTileSets
' 5
[
5 6
i
6 7
]
7 8
.
8 9
randomTiles
9 D
.
D E
Length
E K
!=
L N
	sizeCount
O X
)
X Y
randomBrush
™™ #
.
™™# $
randomTileSets
™™$ 2
[
™™2 3
i
™™3 4
]
™™4 5
.
™™5 6
randomTiles
™™6 A
=
™™B C
new
™™D G
TileBase
™™H P
[
™™P Q
	sizeCount
™™Q Z
]
™™Z [
;
™™[ \
}
љљ 
}
›› 
if
ќќ 
(
ќќ  
randomTileSetCount
ќќ "
>
ќќ# $
$num
ќќ% &
)
ќќ& '
{
ћћ 
EditorGUILayout
џџ 
.
џџ  
Space
џџ  %
(
џџ% &
)
џџ& '
;
џџ' (
EditorGUILayout
   
.
    

LabelField
    *
(
  * +
$str
  + @
)
  @ A
;
  A B
for
ўў 
(
ўў 
int
ўў 
i
ўў 
=
ўў 
$num
ўў 
;
ўў 
i
ўў  !
<
ўў" # 
randomTileSetCount
ўў$ 6
;
ўў6 7
i
ўў8 9
++
ўў9 ;
)
ўў; <
{
ЈЈ 
EditorGUILayout
¤¤ #
.
¤¤# $

LabelField
¤¤$ .
(
¤¤. /
$str
¤¤/ :
+
¤¤; <
(
¤¤= >
i
¤¤> ?
+
¤¤? @
$num
¤¤@ A
)
¤¤A B
)
¤¤B C
;
¤¤C D
for
ҐҐ 
(
ҐҐ 
int
ҐҐ 
j
ҐҐ 
=
ҐҐ  
$num
ҐҐ! "
;
ҐҐ" #
j
ҐҐ$ %
<
ҐҐ& '
randomBrush
ҐҐ( 3
.
ҐҐ3 4
randomTileSets
ҐҐ4 B
[
ҐҐB C
i
ҐҐC D
]
ҐҐD E
.
ҐҐE F
randomTiles
ҐҐF Q
.
ҐҐQ R
Length
ҐҐR X
;
ҐҐX Y
++
ҐҐZ \
j
ҐҐ\ ]
)
ҐҐ] ^
{
¦¦ 
randomBrush
§§ #
.
§§# $
randomTileSets
§§$ 2
[
§§2 3
i
§§3 4
]
§§4 5
.
§§5 6
randomTiles
§§6 A
[
§§A B
j
§§B C
]
§§C D
=
§§E F
(
§§G H
TileBase
§§H P
)
§§P Q
EditorGUILayout
§§R a
.
§§a b
ObjectField
§§b m
(
§§m n
$str
§§n u
+
§§v w
(
§§x y
j
§§y z
+
§§z {
$num
§§{ |
)
§§| }
,
§§} ~
randomBrush§§ Љ
.§§Љ ‹
randomTileSets§§‹ ™
[§§™ љ
i§§љ ›
]§§› њ
.§§њ ќ
randomTiles§§ќ Ё
[§§Ё ©
j§§© Є
]§§Є «
,§§« ¬
typeof§§­ і
(§§і ґ
TileBase§§ґ ј
)§§ј Ѕ
,§§Ѕ ѕ
false§§ї Д
,§§Д Е
null§§Ж К
)§§К Л
;§§Л М
}
ЁЁ 
}
©© 
}
ЄЄ 
if
¬¬ 
(
¬¬ 
	EditorGUI
¬¬ 
.
¬¬ 
EndChangeCheck
¬¬ (
(
¬¬( )
)
¬¬) *
)
¬¬* +
EditorUtility
­­ 
.
­­ 
SetDirty
­­ &
(
­­& '
randomBrush
­­' 2
)
­­2 3
;
­­3 4
}
®® 	
}
ЇЇ 
}°° Њ*
—C:\Users\Davis\Desktop\Facultad\5to Periodo\Tecnologias\Pacman\ClientePacman\Packages\com.unity.2d.tilemap.extras\Editor\Brushes\TintBrush\TintBrush.cs
	namespace 	
UnityEditor
 
. 
Tilemaps 
{ 
[

 
CustomGridBrush

 
(

 
false

 
,

 
false

 !
,

! "
false

# (
,

( )
$str

* 6
)

6 7
]

7 8
public 

class 
	TintBrush 
: 
GridBrushBase *
{ 
public 
Color 
m_Color 
= 
Color $
.$ %
white% *
;* +
public 
override 
void 
Paint "
(" #

GridLayout# -
grid. 2
,2 3

GameObject4 >
brushTarget? J
,J K

Vector3IntL V
positionW _
)_ `
{ 	
if 
( 
brushTarget 
. 
layer !
==" $
$num% '
)' (
return 
; 
Tilemap 
tilemap 
= 
brushTarget )
.) *
GetComponent* 6
<6 7
Tilemap7 >
>> ?
(? @
)@ A
;A B
if   
(   
tilemap   
!=   
null   
)    
{!! 
SetColor"" 
("" 
tilemap""  
,""  !
position""" *
,""* +
m_Color"", 3
)""3 4
;""4 5
}## 
}$$ 	
public-- 
override-- 
void-- 
Erase-- "
(--" #

GridLayout--# -
grid--. 2
,--2 3

GameObject--4 >
brushTarget--? J
,--J K

Vector3Int--L V
position--W _
)--_ `
{.. 	
if00 
(00 
brushTarget00 
.00 
layer00 !
==00" $
$num00% '
)00' (
return11 
;11 
Tilemap33 
tilemap33 
=33 
brushTarget33 )
.33) *
GetComponent33* 6
<336 7
Tilemap337 >
>33> ?
(33? @
)33@ A
;33A B
if44 
(44 
tilemap44 
!=44 
null44 
)44  
{55 
SetColor66 
(66 
tilemap66  
,66  !
position66" *
,66* +
Color66, 1
.661 2
white662 7
)667 8
;668 9
}77 
}88 	
private:: 
static:: 
void:: 
SetColor:: $
(::$ %
Tilemap::% ,
tilemap::- 4
,::4 5

Vector3Int::6 @
position::A I
,::I J
Color::K P
color::Q V
)::V W
{;; 	
TileBase<< 
tile<< 
=<< 
tilemap<< #
.<<# $
GetTile<<$ +
(<<+ ,
position<<, 4
)<<4 5
;<<5 6
if== 
(== 
tile== 
!=== 
null== 
)== 
{>> 
if?? 
(?? 
(?? 
tilemap?? 
.?? 
GetTileFlags?? )
(??) *
position??* 2
)??2 3
&??4 5
	TileFlags??6 ?
.??? @
	LockColor??@ I
)??I J
!=??K M
$num??N O
)??O P
{@@ 
ifAA 
(AA 
tileAA 
isAA 
TileAA  $
)AA$ %
{BB 
DebugCC 
.CC 

LogWarningCC (
(CC( )
$strCC) O
+CCP Q
tileCCR V
.CCV W
nameCCW [
+CC\ ]
$str	CC^ ­
)
CC­ ®
;
CC® Ї
}DD 
elseEE 
{FF 
DebugGG 
.GG 

LogWarningGG (
(GG( )
$strGG) O
+GGP Q
tileGGR V
.GGV W
nameGGW [
+GG\ ]
$str	GG^ ™
)
GG™ љ
;
GGљ ›
}HH 
}II 
tilemapKK 
.KK 
SetColorKK  
(KK  !
positionKK! )
,KK) *
colorKK+ 0
)KK0 1
;KK1 2
}LL 
}MM 	
}NN 
[SS 
CustomEditorSS 
(SS 
typeofSS 
(SS 
	TintBrushSS "
)SS" #
)SS# $
]SS$ %
publicTT 

classTT 
TintBrushEditorTT  
:TT! "
GridBrushEditorBaseTT# 6
{UU 
publicXX 
overrideXX 

GameObjectXX "
[XX" #
]XX# $
validTargetsXX% 1
{YY 	
getZZ 
{[[ 
return\\ 

GameObject\\ !
.\\! "
FindObjectsOfType\\" 3
<\\3 4
Tilemap\\4 ;
>\\; <
(\\< =
)\\= >
.\\> ?
Select\\? E
(\\E F
x\\F G
=>\\H J
x\\K L
.\\L M

gameObject\\M W
)\\W X
.\\X Y
ToArray\\Y `
(\\` a
)\\a b
;\\b c
}]] 
}^^ 	
}__ 
}`` ЪD
ЈC:\Users\Davis\Desktop\Facultad\5to Periodo\Tecnologias\Pacman\ClientePacman\Packages\com.unity.2d.tilemap.extras\Editor\Brushes\TintBrushSmooth\TintBrushSmooth.cs
	namespace 	
UnityEditor
 
. 
Tilemaps 
{ 
[

 
CustomGridBrush

 
(

 
false

 
,

 
false

 !
,

! "
false

# (
,

( )
$str

* ?
)

? @
]

@ A
public 

class 
TintBrushSmooth  
:! "
GridBrushBase# 0
{ 
private  
TintTextureGenerator $
	generator% .
{ 	
get 
{  
TintTextureGenerator $
	generator% .
=/ 0
FindObjectOfType1 A
<A B 
TintTextureGeneratorB V
>V W
(W X
)X Y
;Y Z
if 
( 
	generator 
==  
null! %
)% &
{ 
Grid 
grid 
= 
FindObjectOfType  0
<0 1
Grid1 5
>5 6
(6 7
)7 8
;8 9
if 
( 
grid 
!= 
null  $
)$ %
{ 
	generator !
=" #
grid$ (
.( )

gameObject) 3
.3 4
AddComponent4 @
<@ A 
TintTextureGeneratorA U
>U V
(V W
)W X
;X Y
} 
} 
return 
	generator  
;  !
} 
} 	
public"" 
float"" 
m_Blend"" 
="" 
$num"" !
;""! "
public&& 
Color&& 
m_Color&& 
=&& 
Color&& $
.&&$ %
white&&% *
;&&* +
public// 
override// 
void// 
Paint// "
(//" #

GridLayout//# -
grid//. 2
,//2 3

GameObject//4 >
brushTarget//? J
,//J K

Vector3Int//L V
position//W _
)//_ `
{00 	
if22 
(22 
brushTarget22 
.22 
layer22 !
==22" $
$num22% '
)22' (
return33 
;33  
TintTextureGenerator55  
	generator55! *
=55+ ,
GetGenerator55- 9
(559 :
grid55: >
)55> ?
;55? @
if66 
(66 
	generator66 
!=66 
null66 !
)66! "
{77 
var88 
oldColor88 
=88 
	generator88 (
.88( )
GetColor88) 1
(881 2
grid882 6
as887 9
Grid88: >
,88> ?
position88@ H
)88H I
;88I J
var99 

blendColor99 
=99  
oldColor99! )
*99* +
(99, -
$num99- .
-99/ 0
m_Blend991 8
)998 9
+99: ;
m_Color99< C
*99D E
m_Blend99F M
;99M N
	generator:: 
.:: 
SetColor:: "
(::" #
grid::# '
as::( *
Grid::+ /
,::/ 0
position::1 9
,::9 :

blendColor::; E
)::E F
;::F G
};; 
}<< 	
publicEE 
overrideEE 
voidEE 
EraseEE "
(EE" #

GridLayoutEE# -
gridEE. 2
,EE2 3

GameObjectEE4 >
brushTargetEE? J
,EEJ K

Vector3IntEEL V
positionEEW _
)EE_ `
{FF 	
ifHH 
(HH 
brushTargetHH 
.HH 
layerHH !
==HH" $
$numHH% '
)HH' (
returnII 
;II  
TintTextureGeneratorKK  
	generatorKK! *
=KK+ ,
GetGeneratorKK- 9
(KK9 :
gridKK: >
)KK> ?
;KK? @
ifLL 
(LL 
	generatorLL 
!=LL 
nullLL !
)LL! "
{MM 
	generatorNN 
.NN 
SetColorNN "
(NN" #
gridNN# '
asNN( *
GridNN+ /
,NN/ 0
positionNN1 9
,NN9 :
ColorNN; @
.NN@ A
whiteNNA F
)NNF G
;NNG H
}OO 
}PP 	
publicZZ 
overrideZZ 
voidZZ 
PickZZ !
(ZZ! "

GridLayoutZZ" ,
gridZZ- 1
,ZZ1 2

GameObjectZZ3 =
brushTargetZZ> I
,ZZI J
	BoundsIntZZK T
positionZZU ]
,ZZ] ^

Vector3IntZZ_ i
pivotZZj o
)ZZo p
{[[ 	
if]] 
(]] 
brushTarget]] 
.]] 
layer]] !
==]]" $
$num]]% '
)]]' (
return^^ 
;^^  
TintTextureGenerator``  
	generator``! *
=``+ ,
GetGenerator``- 9
(``9 :
grid``: >
)``> ?
;``? @
ifaa 
(aa 
	generatoraa 
!=aa 
nullaa !
)aa! "
{bb 
m_Colorcc 
=cc 
	generatorcc #
.cc# $
GetColorcc$ ,
(cc, -
gridcc- 1
ascc2 4
Gridcc5 9
,cc9 :
positioncc; C
.ccC D
minccD G
)ccG H
;ccH I
}dd 
}ee 	
privategg  
TintTextureGeneratorgg $
GetGeneratorgg% 1
(gg1 2

GridLayoutgg2 <
gridgg= A
)ggA B
{hh 	 
TintTextureGeneratorii  
	generatorii! *
=ii+ ,
FindObjectOfTypeii- =
<ii= > 
TintTextureGeneratorii> R
>iiR S
(iiS T
)iiT U
;iiU V
ifjj 
(jj 
	generatorjj 
==jj 
nulljj !
)jj! "
{kk 
ifll 
(ll 
gridll 
!=ll 
nullll  
)ll  !
{mm 
	generatornn 
=nn 
gridnn  $
.nn$ %

gameObjectnn% /
.nn/ 0
AddComponentnn0 <
<nn< = 
TintTextureGeneratornn= Q
>nnQ R
(nnR S
)nnS T
;nnT U
}oo 
}pp 
returnqq 
	generatorqq 
;qq 
}rr 	
}ss 
[xx 
CustomEditorxx 
(xx 
typeofxx 
(xx 
TintBrushSmoothxx (
)xx( )
)xx) *
]xx* +
publicyy 

classyy !
TintBrushSmoothEditoryy &
:yy' (
GridBrushEditorBaseyy) <
{zz 
public~~ 
TintBrushSmooth~~ 
brush~~ $
{~~% &
get~~' *
{~~+ ,
return~~- 3
target~~4 :
as~~; =
TintBrushSmooth~~> M
;~~M N
}~~O P
}~~Q R
public
‚‚ 
override
‚‚ 

GameObject
‚‚ "
[
‚‚" #
]
‚‚# $
validTargets
‚‚% 1
{
ѓѓ 	
get
„„ 
{
…… 
return
†† 

GameObject
†† !
.
††! "
FindObjectsOfType
††" 3
<
††3 4
Tilemap
††4 ;
>
††; <
(
††< =
)
††= >
.
††> ?
Select
††? E
(
††E F
x
††F G
=>
††H J
x
††K L
.
††L M

gameObject
††M W
)
††W X
.
††X Y
ToArray
††Y `
(
††` a
)
††a b
;
††b c
}
‡‡ 
}
€€ 	
public
ЋЋ 
override
ЋЋ 
void
ЋЋ !
OnPaintInspectorGUI
ЋЋ 0
(
ЋЋ0 1
)
ЋЋ1 2
{
ЏЏ 	
brush
ђђ 
.
ђђ 
m_Color
ђђ 
=
ђђ 
EditorGUILayout
ђђ +
.
ђђ+ ,

ColorField
ђђ, 6
(
ђђ6 7
$str
ђђ7 >
,
ђђ> ?
brush
ђђ@ E
.
ђђE F
m_Color
ђђF M
)
ђђM N
;
ђђN O
brush
‘‘ 
.
‘‘ 
m_Blend
‘‘ 
=
‘‘ 
EditorGUILayout
‘‘ +
.
‘‘+ ,
Slider
‘‘, 2
(
‘‘2 3
$str
‘‘3 :
,
‘‘: ;
brush
‘‘< A
.
‘‘A B
m_Blend
‘‘B I
,
‘‘I J
$num
‘‘K M
,
‘‘M N
$num
‘‘O Q
)
‘‘Q R
;
‘‘R S
	GUILayout
’’ 
.
’’ 
Label
’’ 
(
’’ 
$str
’’ N
)
’’N O
;
’’O P
}
““ 	
}
”” 
}•• У¦
«C:\Users\Davis\Desktop\Facultad\5to Periodo\Tecnologias\Pacman\ClientePacman\Packages\com.unity.2d.tilemap.extras\Editor\Tiles\HexagonalRuleTile\HexagonalRuleTileEditor.cs
	namespace 	
UnityEditor
 
{ 
[ 
CustomEditor 
( 
typeof 
( 
HexagonalRuleTile *
)* +
,+ ,
true- 1
)1 2
]2 3
[ "
CanEditMultipleObjects 
] 
public 

class #
HexagonalRuleTileEditor (
:) *
RuleTileEditor+ 9
{ 
public

 
override

 
int

 
GetArrowIndex

 )
(

) *

Vector3Int

* 4
position

5 =
)

= >
{ 	
var 
hexTile 
= 
tile 
as !
HexagonalRuleTile" 3
;3 4
if 
( 
position 
. 
y 
% 
$num 
!= !
$num" #
)# $
{ 
position 
*= 
$num 
; 
position 
. 
x 
+= 
$num 
;  
} 
if 
( 
position 
. 
x 
== 
$num 
)  
{ 
if 
( 
position 
. 
y 
>  
$num! "
)" #
return 
hexTile "
." #
	m_FlatTop# ,
?- .
$num/ 0
:1 2
$num3 4
;4 5
else 
return 
hexTile "
." #
	m_FlatTop# ,
?- .
$num/ 0
:1 2
$num3 4
;4 5
} 
else 
if 
( 
position 
. 
y 
==  "
$num# $
)$ %
{ 
if 
( 
position 
. 
x 
>  
$num! "
)" #
return 
hexTile "
." #
	m_FlatTop# ,
?- .
$num/ 0
:1 2
$num3 4
;4 5
else 
return   
hexTile   "
.  " #
	m_FlatTop  # ,
?  - .
$num  / 0
:  1 2
$num  3 4
;  4 5
}!! 
else"" 
{## 
if$$ 
($$ 
position$$ 
.$$ 
x$$ 
<$$  
$num$$! "
&&$$# %
position$$& .
.$$. /
y$$/ 0
>$$1 2
$num$$3 4
)$$4 5
return%% 
hexTile%% "
.%%" #
	m_FlatTop%%# ,
?%%- .
$num%%/ 0
:%%1 2
$num%%3 4
;%%4 5
else&& 
if&& 
(&& 
position&& !
.&&! "
x&&" #
>&&$ %
$num&&& '
&&&&( *
position&&+ 3
.&&3 4
y&&4 5
>&&6 7
$num&&8 9
)&&9 :
return'' 
hexTile'' "
.''" #
	m_FlatTop''# ,
?''- .
$num''/ 0
:''1 2
$num''3 4
;''4 5
else(( 
if(( 
((( 
position(( !
.((! "
x((" #
<(($ %
$num((& '
&&((( *
position((+ 3
.((3 4
y((4 5
<((6 7
$num((8 9
)((9 :
return)) 
hexTile)) "
.))" #
	m_FlatTop))# ,
?))- .
$num))/ 0
:))1 2
$num))3 4
;))4 5
else** 
if** 
(** 
position** !
.**! "
x**" #
>**$ %
$num**& '
&&**( *
position**+ 3
.**3 4
y**4 5
<**6 7
$num**8 9
)**9 :
return++ 
hexTile++ "
.++" #
	m_FlatTop++# ,
?++- .
$num++/ 0
:++1 2
$num++3 4
;++4 5
},, 
return.. 
-.. 
$num.. 
;.. 
}// 	
public11 
override11 
	BoundsInt11 !
GetRuleGUIBounds11" 2
(112 3
	BoundsInt113 <
bounds11= C
,11C D
RuleTile11E M
.11M N

TilingRule11N X
rule11Y ]
)11] ^
{22 	
foreach33 
(33 
var33 
n33 
in33 
rule33 "
.33" #
GetNeighbors33# /
(33/ 0
)330 1
)331 2
{44 
if55 
(55 
n55 
.55 
Key55 
.55 
x55 
==55 
bounds55 %
.55% &
xMax55& *
-55+ ,
$num55- .
&&55/ 1
n552 3
.553 4
Key554 7
.557 8
y558 9
%55: ;
$num55< =
!=55> @
$num55A B
)55B C
{66 
bounds77 
.77 
xMax77 
++77 !
;77! "
break88 
;88 
}99 
}:: 
return;; 
base;; 
.;; 
GetRuleGUIBounds;; (
(;;( )
bounds;;) /
,;;/ 0
rule;;1 5
);;5 6
;;;6 7
}<< 	
public>> 
override>> 
Vector2>> 
GetMatrixSize>>  -
(>>- .
	BoundsInt>>. 7
bounds>>8 >
)>>> ?
{?? 	
var@@ 
hexTile@@ 
=@@ 
tile@@ 
as@@ !
HexagonalRuleTile@@" 3
;@@3 4
Vector2AA 
sizeAA 
=AA 
baseAA 
.AA  
GetMatrixSizeAA  -
(AA- .
boundsAA. 4
)AA4 5
;AA5 6
returnBB 
hexTileBB 
.BB 
	m_FlatTopBB $
?BB% &
newBB' *
Vector2BB+ 2
(BB2 3
sizeBB3 7
.BB7 8
yBB8 9
,BB9 :
sizeBB; ?
.BB? @
xBB@ A
)BBA B
:BBC D
sizeBBE I
;BBI J
}CC 	
publicEE 
overrideEE 
voidEE 
RuleMatrixOnGUIEE ,
(EE, -
RuleTileEE- 5
tileEE6 :
,EE: ;
RectEE< @
rectEEA E
,EEE F
	BoundsIntEEG P
boundsEEQ W
,EEW X
RuleTileEEY a
.EEa b

TilingRuleEEb l

tilingRuleEEm w
)EEw x
{FF 	
varGG 
hexTileGG 
=GG 
tileGG 
asGG !
HexagonalRuleTileGG" 3
;GG3 4
boolHH 
flatTopHH 
=HH 
hexTileHH "
.HH" #
	m_FlatTopHH# ,
;HH, -
HandlesJJ 
.JJ 
colorJJ 
=JJ 
EditorGUIUtilityJJ ,
.JJ, -
	isProSkinJJ- 6
?JJ7 8
newJJ9 <
ColorJJ= B
(JJB C
$numJJC E
,JJE F
$numJJG I
,JJI J
$numJJK M
,JJM N
$numJJO S
)JJS T
:JJU V
newJJW Z
ColorJJ[ `
(JJ` a
$numJJa c
,JJc d
$numJJe g
,JJg h
$numJJi k
,JJk l
$numJJm q
)JJq r
;JJr s
floatKK 
wKK 
=KK 
rectKK 
.KK 
widthKK  
/KK! "
(KK# $
flatTopKK$ +
?KK, -
boundsKK. 4
.KK4 5
sizeKK5 9
.KK9 :
yKK: ;
:KK< =
boundsKK> D
.KKD E
sizeKKE I
.KKI J
xKKJ K
)KKK L
;KKL M
floatLL 
hLL 
=LL 
rectLL 
.LL 
heightLL !
/LL" #
(LL$ %
flatTopLL% ,
?LL- .
boundsLL/ 5
.LL5 6
sizeLL6 :
.LL: ;
xLL; <
:LL= >
boundsLL? E
.LLE F
sizeLLF J
.LLJ K
yLLK L
)LLL M
;LLM N
ifOO 
(OO 
flatTopOO 
)OO 
{PP 
forQQ 
(QQ 
intQQ 
yQQ 
=QQ 
$numQQ 
;QQ 
yQQ  !
<=QQ" $
boundsQQ% +
.QQ+ ,
sizeQQ, 0
.QQ0 1
yQQ1 2
;QQ2 3
yQQ4 5
++QQ5 7
)QQ7 8
{RR 
floatSS 
leftSS 
=SS  
rectSS! %
.SS% &
xMinSS& *
+SS+ ,
ySS- .
*SS/ 0
wSS1 2
;SS2 3
floatTT 
offsetTT  
=TT! "
$numTT# $
;TT$ %
ifVV 
(VV 
yVV 
==VV 
$numVV 
&&VV !
boundsVV" (
.VV( )
yMaxVV) -
%VV. /
$numVV0 1
==VV2 4
$numVV5 6
)VV6 7
offsetWW 
=WW  
hWW! "
/WW# $
$numWW% &
;WW& '
elseXX 
ifXX 
(XX 
yXX 
==XX !
boundsXX" (
.XX( )
sizeXX) -
.XX- .
yXX. /
&&XX0 2
boundsXX3 9
.XX9 :
yMinXX: >
%XX? @
$numXXA B
!=XXC E
$numXXF G
)XXG H
offsetYY 
=YY  
hYY! "
/YY# $
$numYY% &
;YY& '
Handles[[ 
.[[ 
DrawLine[[ $
([[$ %
new[[% (
Vector3[[) 0
([[0 1
left[[1 5
,[[5 6
rect[[7 ;
.[[; <
yMin[[< @
+[[A B
offset[[C I
)[[I J
,[[J K
new[[L O
Vector3[[P W
([[W X
left[[X \
,[[\ ]
rect[[^ b
.[[b c
yMax[[c g
-[[h i
offset[[j p
)[[p q
)[[q r
;[[r s
if]] 
(]] 
y]] 
<]] 
bounds]] "
.]]" #
size]]# '
.]]' (
y]]( )
)]]) *
{^^ 
bool__ 
noOffset__ %
=__& '
(__( )
y__) *
+__+ ,
bounds__- 3
.__3 4
yMax__4 8
)__8 9
%__: ;
$num__< =
!=__> @
$num__A B
;__B C
for`` 
(`` 
int``  
x``! "
=``# $
$num``% &
;``& '
x``( )
<``* +
(``, -
noOffset``- 5
?``6 7
(``8 9
bounds``9 ?
.``? @
size``@ D
.``D E
x``E F
+``G H
$num``I J
)``J K
:``L M
bounds``N T
.``T U
size``U Y
.``Y Z
x``Z [
)``[ \
;``\ ]
x``^ _
++``_ a
)``a b
{aa 
floatbb !
topbb" %
=bb& '
rectbb( ,
.bb, -
yMinbb- 1
+bb2 3
xbb4 5
*bb6 7
hbb8 9
+bb: ;
(bb< =
noOffsetbb= E
?bbF G
$numbbH I
:bbJ K
hbbL M
/bbN O
$numbbP Q
)bbQ R
;bbR S
Handlescc #
.cc# $
DrawLinecc$ ,
(cc, -
newcc- 0
Vector3cc1 8
(cc8 9
leftcc9 =
,cc= >
topcc? B
)ccB C
,ccC D
newccE H
Vector3ccI P
(ccP Q
leftccQ U
+ccV W
wccX Y
,ccY Z
topcc[ ^
)cc^ _
)cc_ `
;cc` a
}dd 
}ee 
}ff 
}gg 
elsehh 
{ii 
forjj 
(jj 
intjj 
yjj 
=jj 
$numjj 
;jj 
yjj  !
<=jj" $
boundsjj% +
.jj+ ,
sizejj, 0
.jj0 1
yjj1 2
;jj2 3
yjj4 5
++jj5 7
)jj7 8
{kk 
floatll 
topll 
=ll 
rectll  $
.ll$ %
yMinll% )
+ll* +
yll, -
*ll. /
hll0 1
;ll1 2
floatmm 
offsetmm  
=mm! "
$nummm# $
;mm$ %
ifoo 
(oo 
yoo 
==oo 
$numoo 
&&oo !
boundsoo" (
.oo( )
yMaxoo) -
%oo. /
$numoo0 1
==oo2 4
$numoo5 6
)oo6 7
offsetpp 
=pp  
wpp! "
/pp# $
$numpp% &
;pp& '
elseqq 
ifqq 
(qq 
yqq 
==qq !
boundsqq" (
.qq( )
sizeqq) -
.qq- .
yqq. /
&&qq0 2
boundsqq3 9
.qq9 :
yMinqq: >
%qq? @
$numqqA B
!=qqC E
$numqqF G
)qqG H
offsetrr 
=rr  
wrr! "
/rr# $
$numrr% &
;rr& '
Handlestt 
.tt 
DrawLinett $
(tt$ %
newtt% (
Vector3tt) 0
(tt0 1
recttt1 5
.tt5 6
xMintt6 :
+tt; <
offsettt= C
,ttC D
topttE H
)ttH I
,ttI J
newttK N
Vector3ttO V
(ttV W
rectttW [
.tt[ \
xMaxtt\ `
-tta b
offsetttc i
,tti j
topttk n
)ttn o
)tto p
;ttp q
ifvv 
(vv 
yvv 
<vv 
boundsvv "
.vv" #
sizevv# '
.vv' (
yvv( )
)vv) *
{ww 
boolxx 
noOffsetxx %
=xx& '
(xx( )
yxx) *
+xx+ ,
boundsxx- 3
.xx3 4
yMaxxx4 8
)xx8 9
%xx: ;
$numxx< =
!=xx> @
$numxxA B
;xxB C
foryy 
(yy 
intyy  
xyy! "
=yy# $
$numyy% &
;yy& '
xyy( )
<yy* +
(yy, -
noOffsetyy- 5
?yy6 7
(yy8 9
boundsyy9 ?
.yy? @
sizeyy@ D
.yyD E
xyyE F
+yyG H
$numyyI J
)yyJ K
:yyL M
boundsyyN T
.yyT U
sizeyyU Y
.yyY Z
xyyZ [
)yy[ \
;yy\ ]
xyy^ _
++yy_ a
)yya b
{zz 
float{{ !
left{{" &
={{' (
rect{{) -
.{{- .
xMin{{. 2
+{{3 4
x{{5 6
*{{7 8
w{{9 :
+{{; <
({{= >
noOffset{{> F
?{{G H
$num{{I J
:{{K L
w{{M N
/{{O P
$num{{Q R
){{R S
;{{S T
Handles|| #
.||# $
DrawLine||$ ,
(||, -
new||- 0
Vector3||1 8
(||8 9
left||9 =
,||= >
top||? B
)||B C
,||C D
new||E H
Vector3||I P
(||P Q
left||Q U
,||U V
top||W Z
+||[ \
h||] ^
)||^ _
)||_ `
;||` a
}}} 
}~~ 
} 
}
ЂЂ 
var
‚‚ 
	neighbors
‚‚ 
=
‚‚ 

tilingRule
‚‚ &
.
‚‚& '
GetNeighbors
‚‚' 3
(
‚‚3 4
)
‚‚4 5
;
‚‚5 6
Handles
…… 
.
…… 
color
…… 
=
…… 
Color
…… !
.
……! "
white
……" '
;
……' (
for
†† 
(
†† 
int
†† 
y
†† 
=
†† 
bounds
†† 
.
††  
yMin
††  $
;
††$ %
y
††& '
<
††( )
bounds
††* 0
.
††0 1
yMax
††1 5
;
††5 6
y
††7 8
++
††8 :
)
††: ;
{
‡‡ 
int
€€ 
xMax
€€ 
=
€€ 
y
€€ 
%
€€ 
$num
€€  
==
€€! #
$num
€€$ %
?
€€& '
bounds
€€( .
.
€€. /
xMax
€€/ 3
:
€€4 5
(
€€6 7
bounds
€€7 =
.
€€= >
xMax
€€> B
-
€€C D
$num
€€E F
)
€€F G
;
€€G H
for
‰‰ 
(
‰‰ 
int
‰‰ 
x
‰‰ 
=
‰‰ 
bounds
‰‰ #
.
‰‰# $
xMin
‰‰$ (
;
‰‰( )
x
‰‰* +
<
‰‰, -
xMax
‰‰. 2
;
‰‰2 3
x
‰‰4 5
++
‰‰5 7
)
‰‰7 8
{
ЉЉ 

Vector3Int
‹‹ 
pos
‹‹ "
=
‹‹# $
new
‹‹% (

Vector3Int
‹‹) 3
(
‹‹3 4
x
‹‹4 5
,
‹‹5 6
y
‹‹7 8
,
‹‹8 9
$num
‹‹: ;
)
‹‹; <
;
‹‹< =
Vector2
ЊЊ 
offset
ЊЊ "
=
ЊЊ# $
new
ЊЊ% (
Vector2
ЊЊ) 0
(
ЊЊ0 1
x
ЊЊ1 2
-
ЊЊ3 4
bounds
ЊЊ5 ;
.
ЊЊ; <
xMin
ЊЊ< @
,
ЊЊ@ A
-
ЊЊB C
y
ЊЊC D
+
ЊЊE F
bounds
ЊЊG M
.
ЊЊM N
yMax
ЊЊN R
-
ЊЊS T
$num
ЊЊU V
)
ЊЊV W
;
ЊЊW X
Rect
ЌЌ 
r
ЌЌ 
=
ЌЌ 
flatTop
ЌЌ $
?
ЌЌ% &
new
ЌЌ' *
Rect
ЌЌ+ /
(
ЌЌ/ 0
rect
ЌЌ0 4
.
ЌЌ4 5
xMin
ЌЌ5 9
+
ЌЌ: ;
offset
ЌЌ< B
.
ЌЌB C
y
ЌЌC D
*
ЌЌE F
w
ЌЌG H
,
ЌЌH I
rect
ЌЌJ N
.
ЌЌN O
yMax
ЌЌO S
-
ЌЌT U
offset
ЌЌV \
.
ЌЌ\ ]
x
ЌЌ] ^
*
ЌЌ_ `
h
ЌЌa b
-
ЌЌc d
h
ЌЌe f
,
ЌЌf g
w
ЌЌh i
-
ЌЌj k
$num
ЌЌl m
,
ЌЌm n
h
ЌЌo p
-
ЌЌq r
$num
ЌЌs t
)
ЌЌt u
:
ЋЋ 
new
ЋЋ 
Rect
ЋЋ "
(
ЋЋ" #
rect
ЋЋ# '
.
ЋЋ' (
xMin
ЋЋ( ,
+
ЋЋ- .
offset
ЋЋ/ 5
.
ЋЋ5 6
x
ЋЋ6 7
*
ЋЋ8 9
w
ЋЋ: ;
,
ЋЋ; <
rect
ЋЋ= A
.
ЋЋA B
yMin
ЋЋB F
+
ЋЋG H
offset
ЋЋI O
.
ЋЋO P
y
ЋЋP Q
*
ЋЋR S
h
ЋЋT U
,
ЋЋU V
w
ЋЋW X
-
ЋЋY Z
$num
ЋЋ[ \
,
ЋЋ\ ]
h
ЋЋ^ _
-
ЋЋ` a
$num
ЋЋb c
)
ЋЋc d
;
ЋЋd e
if
ђђ 
(
ђђ 
y
ђђ 
%
ђђ 
$num
ђђ 
!=
ђђ  
$num
ђђ! "
)
ђђ" #
{
‘‘ 
if
’’ 
(
’’ 
flatTop
’’ #
)
’’# $
r
““ 
.
““ 
y
““ 
-=
““  "
h
““# $
/
““% &
$num
““' (
;
““( )
else
”” 
r
•• 
.
•• 
x
•• 
+=
••  "
w
••# $
/
••% &
$num
••' (
;
••( )
}
–– 
if
 
(
 
x
 
!=
 
$num
 
||
 !
y
" #
!=
$ &
$num
' (
)
( )
{
™™ 
if
љљ 
(
љљ 
	neighbors
љљ %
.
љљ% &
ContainsKey
љљ& 1
(
љљ1 2
pos
љљ2 5
)
љљ5 6
)
љљ6 7
{
›› 
	RuleOnGUI
њњ %
(
њњ% &
r
њњ& '
,
њњ' (
pos
њњ) ,
,
њњ, -
	neighbors
њњ. 7
[
њњ7 8
pos
њњ8 ;
]
њњ; <
)
њњ< =
;
њњ= >
RuleTooltipOnGUI
ќќ ,
(
ќќ, -
r
ќќ- .
,
ќќ. /
	neighbors
ќќ0 9
[
ќќ9 :
pos
ќќ: =
]
ќќ= >
)
ќќ> ?
;
ќќ? @
}
ћћ 
if
џџ 
(
џџ  
RuleNeighborUpdate
џџ .
(
џџ. /
r
џџ/ 0
,
џџ0 1

tilingRule
џџ2 <
,
џџ< =
	neighbors
џџ> G
,
џџG H
pos
џџI L
)
џџL M
)
џџM N
{
   
tile
ЎЎ  
.
ЎЎ  !%
UpdateNeighborPositions
ЎЎ! 8
(
ЎЎ8 9
)
ЎЎ9 :
;
ЎЎ: ;
}
ўў 
}
ЈЈ 
else
¤¤ 
{
ҐҐ  
RuleTransformOnGUI
¦¦ *
(
¦¦* +
r
¦¦+ ,
,
¦¦, -

tilingRule
¦¦. 8
.
¦¦8 9
m_RuleTransform
¦¦9 H
)
¦¦H I
;
¦¦I J
if
§§ 
(
§§ !
RuleTransformUpdate
§§ /
(
§§/ 0
r
§§0 1
,
§§1 2

tilingRule
§§3 =
)
§§= >
)
§§> ?
{
ЁЁ 
tile
©©  
.
©©  !%
UpdateNeighborPositions
©©! 8
(
©©8 9
)
©©9 :
;
©©: ;
}
ЄЄ 
}
«« 
}
¬¬ 
}
­­ 
}
®® 	
}
ЇЇ 
}°° „q
«C:\Users\Davis\Desktop\Facultad\5to Periodo\Tecnologias\Pacman\ClientePacman\Packages\com.unity.2d.tilemap.extras\Editor\Tiles\IsometricRuleTile\IsometricRuleTileEditor.cs
	namespace 	
UnityEditor
 
{ 
[ 
CustomEditor 
( 
typeof 
( 
IsometricRuleTile *
)* +
,+ ,
true- 1
)1 2
]2 3
[ "
CanEditMultipleObjects 
] 
public 

class #
IsometricRuleTileEditor (
:) *
RuleTileEditor+ 9
{ 
private

 
static

 
readonly

 
int

  #
[

# $
]

$ %
s_Arrows

& .
=

/ 0
{

1 2
$num

3 4
,

4 5
$num

6 7
,

7 8
$num

9 :
,

: ;
$num

< =
,

= >
-

? @
$num

@ A
,

A B
$num

C D
,

D E
$num

F G
,

G H
$num

I J
,

J K
$num

L M
}

N O
;

O P
public 
override 
int 
GetArrowIndex )
() *

Vector3Int* 4
position5 =
)= >
{ 	
return 
s_Arrows 
[ 
base  
.  !
GetArrowIndex! .
(. /
position/ 7
)7 8
]8 9
;9 :
} 	
public 
override 
Vector2 
GetMatrixSize  -
(- .
	BoundsInt. 7
bounds8 >
)> ?
{ 	
float 
p 
= 
Mathf 
. 
Pow 
(  
$num  !
,! "
$num# '
)' (
;( )
float 
w 
= 
( 
bounds 
. 
size "
." #
x# $
/% &
p' (
+) *
bounds+ 1
.1 2
size2 6
.6 7
y7 8
/9 :
p; <
)< =
*> ?
k_SingleLineHeight@ R
;R S
return 
new 
Vector2 
( 
w  
,  !
w" #
)# $
;$ %
} 	
public 
override 
void 
RuleMatrixOnGUI ,
(, -
RuleTile- 5
ruleTile6 >
,> ?
Rect@ D
rectE I
,I J
	BoundsIntK T
boundsU [
,[ \
RuleTile] e
.e f

TilingRulef p

tilingRuleq {
){ |
{ 	
Handles 
. 
color 
= 
EditorGUIUtility ,
., -
	isProSkin- 6
?7 8
new9 <
Color= B
(B C
$numC E
,E F
$numG I
,I J
$numK M
,M N
$numO S
)S T
:U V
newW Z
Color[ `
(` a
$numa c
,c d
$nume g
,g h
$numi k
,k l
$numm q
)q r
;r s
float 
w 
= 
rect 
. 
width  
/! "
bounds# )
.) *
size* .
.. /
x/ 0
;0 1
float 
h 
= 
rect 
. 
height !
/" #
bounds$ *
.* +
size+ /
./ 0
y0 1
;1 2
float 
d 
= 
rect 
. 
width  
/! "
(# $
bounds$ *
.* +
size+ /
./ 0
x0 1
+2 3
bounds4 :
.: ;
size; ?
.? @
y@ A
)A B
;B C
for   
(   
int   
y   
=   
$num   
;   
y   
<=    
bounds  ! '
.  ' (
size  ( ,
.  , -
y  - .
;  . /
y  0 1
++  1 3
)  3 4
{!! 
float"" 
left"" 
="" 
rect"" !
.""! "
xMin""" &
+""' (
d"") *
*""+ ,
y""- .
;"". /
float## 
top## 
=## 
rect##  
.##  !
yMin##! %
+##& '
d##( )
*##* +
y##, -
;##- .
float$$ 
right$$ 
=$$ 
rect$$ "
.$$" #
xMax$$# '
-$$( )
d$$* +
*$$, -
($$. /
bounds$$/ 5
.$$5 6
size$$6 :
.$$: ;
y$$; <
-$$= >
y$$? @
)$$@ A
;$$A B
float%% 
bottom%% 
=%% 
rect%% #
.%%# $
yMax%%$ (
-%%) *
d%%+ ,
*%%- .
(%%/ 0
bounds%%0 6
.%%6 7
size%%7 ;
.%%; <
y%%< =
-%%> ?
y%%@ A
)%%A B
;%%B C
Handles&& 
.&& 
DrawLine&&  
(&&  !
new&&! $
Vector3&&% ,
(&&, -
left&&- 1
,&&1 2
bottom&&3 9
)&&9 :
,&&: ;
new&&< ?
Vector3&&@ G
(&&G H
right&&H M
,&&M N
top&&O R
)&&R S
)&&S T
;&&T U
}'' 
for(( 
((( 
int(( 
x(( 
=(( 
$num(( 
;(( 
x(( 
<=((  
bounds((! '
.((' (
size((( ,
.((, -
x((- .
;((. /
x((0 1
++((1 3
)((3 4
{)) 
float** 
left** 
=** 
rect** !
.**! "
xMin**" &
+**' (
d**) *
***+ ,
x**- .
;**. /
float++ 
top++ 
=++ 
rect++  
.++  !
yMax++! %
-++& '
d++( )
*++* +
x++, -
;++- .
float,, 
right,, 
=,, 
rect,, "
.,," #
xMax,,# '
-,,( )
d,,* +
*,,, -
(,,. /
bounds,,/ 5
.,,5 6
size,,6 :
.,,: ;
x,,; <
-,,= >
x,,? @
),,@ A
;,,A B
float-- 
bottom-- 
=-- 
rect-- #
.--# $
yMin--$ (
+--) *
d--+ ,
*--- .
(--/ 0
bounds--0 6
.--6 7
size--7 ;
.--; <
x--< =
---> ?
x--@ A
)--A B
;--B C
Handles.. 
... 
DrawLine..  
(..  !
new..! $
Vector3..% ,
(.., -
left..- 1
,..1 2
bottom..3 9
)..9 :
,..: ;
new..< ?
Vector3..@ G
(..G H
right..H M
,..M N
top..O R
)..R S
)..S T
;..T U
}// 
Handles00 
.00 
color00 
=00 
Color00 !
.00! "
white00" '
;00' (
var22 
	neighbors22 
=22 

tilingRule22 &
.22& '
GetNeighbors22' 3
(223 4
)224 5
;225 6
float55 
iconSize55 
=55 
(55 
rect55 "
.55" #
width55# (
-55) *
d55+ ,
)55, -
/55. /
(550 1
bounds551 7
.557 8
size558 <
.55< =
x55= >
+55? @
bounds55A G
.55G H
size55H L
.55L M
y55M N
-55O P
$num55Q R
)55R S
;55S T
float66 
	iconScale66 
=66 
Mathf66 #
.66# $
Pow66$ '
(66' (
$num66( )
,66) *
$num66+ /
)66/ 0
;660 1
for88 
(88 
int88 
y88 
=88 
bounds88 
.88  
yMin88  $
;88$ %
y88& '
<88( )
bounds88* 0
.880 1
yMax881 5
;885 6
y887 8
++888 :
)88: ;
{99 
for:: 
(:: 
int:: 
x:: 
=:: 
bounds:: #
.::# $
xMin::$ (
;::( )
x::* +
<::, -
bounds::. 4
.::4 5
xMax::5 9
;::9 :
x::; <
++::< >
)::> ?
{;; 

Vector3Int<< 
pos<< "
=<<# $
new<<% (

Vector3Int<<) 3
(<<3 4
x<<4 5
,<<5 6
y<<7 8
,<<8 9
$num<<: ;
)<<; <
;<<< =

Vector3Int== 
offset== %
===& '
new==( +

Vector3Int==, 6
(==6 7
pos==7 :
.==: ;
x==; <
-=== >
bounds==? E
.==E F
xMin==F J
,==J K
pos==L O
.==O P
y==P Q
-==R S
bounds==T Z
.==Z [
yMin==[ _
,==_ `
$num==a b
)==b c
;==c d
Rect>> 
r>> 
=>> 
new>>  
Rect>>! %
(>>% &
rect?? 
.?? 
xMin?? !
+??" #
rect??$ (
.??( )
size??) -
.??- .
x??. /
-??0 1
iconSize??2 :
*??; <
(??= >
offset??> D
.??D E
y??E F
-??G H
offset??I O
.??O P
x??P Q
+??R S
$num??T X
+??Y Z
bounds??[ a
.??a b
size??b f
.??f g
x??g h
)??h i
,??i j
rect@@ 
.@@ 
yMin@@ !
+@@" #
rect@@$ (
.@@( )
size@@) -
.@@- .
y@@. /
-@@0 1
iconSize@@2 :
*@@; <
(@@= >
offset@@> D
.@@D E
y@@E F
+@@G H
offset@@I O
.@@O P
x@@P Q
+@@R S
$num@@T X
)@@X Y
,@@Y Z
iconSizeAA  
,AA  !
iconSizeAA" *
)BB 
;BB 
Vector2CC 
centerCC "
=CC# $
rCC% &
.CC& '
centerCC' -
;CC- .
rDD 
.DD 
sizeDD 
*=DD 
	iconScaleDD '
;DD' (
rEE 
.EE 
centerEE 
=EE 
centerEE %
;EE% &
ifFF 
(FF 
xFF 
!=FF 
$numFF 
||FF !
yFF" #
!=FF$ &
$numFF' (
)FF( )
{GG 
ifHH 
(HH 
	neighborsHH %
.HH% &
ContainsKeyHH& 1
(HH1 2
posHH2 5
)HH5 6
)HH6 7
{II 
	RuleOnGUIJJ %
(JJ% &
rJJ& '
,JJ' (
posJJ) ,
,JJ, -
	neighborsJJ. 7
[JJ7 8
posJJ8 ;
]JJ; <
)JJ< =
;JJ= >
RuleTooltipOnGUIKK ,
(KK, -
rKK- .
,KK. /
	neighborsKK0 9
[KK9 :
posKK: =
]KK= >
)KK> ?
;KK? @
}LL 
ifMM 
(MM 
RuleNeighborUpdateMM .
(MM. /
rMM/ 0
,MM0 1

tilingRuleMM2 <
,MM< =
	neighborsMM> G
,MMG H
posMMI L
)MML M
)MMM N
{NN 
tileOO  
.OO  !#
UpdateNeighborPositionsOO! 8
(OO8 9
)OO9 :
;OO: ;
}PP 
}QQ 
elseRR 
{SS 
RuleTransformOnGUITT *
(TT* +
rTT+ ,
,TT, -

tilingRuleTT. 8
.TT8 9
m_RuleTransformTT9 H
)TTH I
;TTI J
ifUU 
(UU 
RuleTransformUpdateUU /
(UU/ 0
rUU0 1
,UU1 2

tilingRuleUU3 =
)UU= >
)UU> ?
{VV 
tileWW  
.WW  !#
UpdateNeighborPositionsWW! 8
(WW8 9
)WW9 :
;WW: ;
}XX 
}YY 
}ZZ 
}[[ 
}\\ 	
public^^ 
override^^ 
bool^^ !
ContainsMousePosition^^ 2
(^^2 3
Rect^^3 7
rect^^8 <
)^^< =
{__ 	
var`` 
center`` 
=`` 
rect`` 
.`` 
center`` $
;``$ %
varaa 
	halfWidthaa 
=aa 
rectaa  
.aa  !
widthaa! &
/aa' (
$numaa) *
;aa* +
varbb 

halfHeightbb 
=bb 
rectbb !
.bb! "
heightbb" (
/bb) *
$numbb+ ,
;bb, -
varcc 
mouseFromCentercc 
=cc  !
Eventcc" '
.cc' (
currentcc( /
.cc/ 0
mousePositioncc0 =
-cc> ?
centercc@ F
;ccF G
vardd 
xAbsdd 
=dd 
Mathfdd 
.dd 
Absdd  
(dd  !
Vector2dd! (
.dd( )
Dotdd) ,
(dd, -
mouseFromCenterdd- <
,dd< =
Vector2dd> E
.ddE F
rightddF K
)ddK L
)ddL M
;ddM N
varee 
yAbsee 
=ee 
Mathfee 
.ee 
Absee  
(ee  !
Vector2ee! (
.ee( )
Dotee) ,
(ee, -
mouseFromCenteree- <
,ee< =
Vector2ee> E
.eeE F
upeeF H
)eeH I
)eeI J
;eeJ K
returnff 
(ff 
xAbsff 
/ff 
	halfWidthff $
+ff% &
yAbsff' +
/ff, -

halfHeightff. 8
)ff8 9
<=ff: <
$numff= >
;ff> ?
}gg 	
}hh 
}ii щ:
±C:\Users\Davis\Desktop\Facultad\5to Periodo\Tecnologias\Pacman\ClientePacman\Packages\com.unity.2d.tilemap.extras\Editor\Tiles\RuleOverrideTile\PopulateRuleOverrideTileWizard.cs
	namespace 	
UnityEditor
 
. 
Tilemaps 
{ 
[		 
	MovedFrom		 
(		 
true		 
,		 
$str		 "
)		" #
]		# $
public

 

class

 )
PopulateRuleOverideTileWizard

 .
:

/ 0
ScriptableWizard

1 A
{ 
[ 	
MenuItem	 
( 
$str G
)G H
]H I
static 
void 

MenuOption 
( 
MenuCommand *
menuCommand+ 6
)6 7
{ 	)
PopulateRuleOverideTileWizard )
.) *
CreateWizard* 6
(6 7
menuCommand7 B
.B C
contextC J
asK M
RuleOverrideTileN ^
)^ _
;_ `
} 	
[ 	
MenuItem	 
( 
$str G
,G H
trueI M
)M N
]N O
static 
bool  
MenuOptionValidation (
(( )
MenuCommand) 4
menuCommand5 @
)@ A
{ 	
RuleOverrideTile 
tile !
=" #
menuCommand$ /
./ 0
context0 7
as8 :
RuleOverrideTile; K
;K L
return 
tile 
. 
m_Tile 
&& !
!" #
tile# '
.' (

m_Advanced( 2
;2 3
} 	
public 
	Texture2D 
m_spriteSet $
;$ %
private 
RuleOverrideTile  
	m_tileset! *
;* +
public## 
static## 
void## 
CreateWizard## '
(##' (
RuleOverrideTile##( 8
target##9 ?
)##? @
{##A B)
PopulateRuleOverideTileWizard$$ )
wizard$$* 0
=$$1 2
DisplayWizard$$3 @
<$$@ A)
PopulateRuleOverideTileWizard$$A ^
>$$^ _
($$_ `
$str$$` s
,$$s t
$str$$u 
)	$$ Ђ
;
$$Ђ Ѓ
wizard%% 
.%% 
	m_tileset%% 
=%% 
target%% %
;%%% &
}&& 	
public,, 
static,, 
void,, 
CloneWizard,, &
(,,& ')
PopulateRuleOverideTileWizard,,' D
	oldWizard,,E N
),,N O
{,,P Q)
PopulateRuleOverideTileWizard-- )
wizard--* 0
=--1 2
DisplayWizard--3 @
<--@ A)
PopulateRuleOverideTileWizard--A ^
>--^ _
(--_ `
$str--` s
,--s t
$str--u 
)	-- Ђ
;
--Ђ Ѓ
wizard.. 
... 
	m_tileset.. 
=.. 
	oldWizard.. (
...( )
	m_tileset..) 2
;..2 3
wizard// 
.// 
m_spriteSet// 
=//  
	oldWizard//! *
.//* +
m_spriteSet//+ 6
;//6 7
}00 	
private22 
void22 
OnWizardUpdate22 #
(22# $
)22$ %
{22& '
isValid33 
=33 
	m_tileset33 
!=33  "
null33# '
&&33( *
m_spriteSet33+ 6
!=337 9
null33: >
;33> ?
}44 	
private66 
void66 
OnWizardCreate66 #
(66# $
)66$ %
{66& '
try77 
{77 
Populate88 
(88 
)88 
;88 
}99 
catch:: 
(:: 
System:: 
.:: 
	Exception:: "
ex::# %
)::% &
{::' (
EditorUtility;; 
.;; 
DisplayDialog;; +
(;;+ ,
$str;;, C
,;;C D
ex;;E G
.;;G H
Message;;H O
,;;O P
$str;;Q U
);;U V
;;;V W
CloneWizard<< 
(<< 
this<<  
)<<  !
;<<! "
}== 
}>> 	
privateGG 
voidGG 
PopulateGG 
(GG 
)GG 
{GG  !
stringHH 
spriteSheetHH 
=HH  
AssetDatabaseHH! .
.HH. /
GetAssetPathHH/ ;
(HH; <
m_spriteSetHH< G
)HHG H
;HHH I
SpriteII 
[II 
]II 
overrideSpritesII $
=II% &
AssetDatabaseII' 4
.II4 5
LoadAllAssetsAtPathII5 H
(IIH I
spriteSheetIII T
)IIT U
.IIU V
OfTypeIIV \
<II\ ]
SpriteII] c
>IIc d
(IId e
)IIe f
.IIf g
ToArrayIIg n
(IIn o
)IIo p
;IIp q
boolKK 
finishedKK 
=KK 
falseKK !
;KK! "
tryMM 
{MM 
UndoNN 
.NN 
RecordObjectNN !
(NN! "
	m_tilesetNN" +
,NN+ ,
$strNN- =
+NN> ?
	m_tilesetNN@ I
.NNI J
nameNNJ N
)NNN O
;NNO P
foreachPP 
(PP 
RuleTilePP  
.PP  !

TilingRulePP! +
rulePP, 0
inPP1 3
	m_tilesetPP4 =
.PP= >
m_TilePP> D
.PPD E
m_TilingRulesPPE R
)PPR S
{PPT U
foreachQQ 
(QQ 
SpriteQQ "
originalSpriteQQ# 1
inQQ2 4
ruleQQ5 9
.QQ9 :
	m_SpritesQQ: C
)QQC D
{QQE F
stringRR 

spriteNameRR )
=RR* +
originalSpriteRR, :
.RR: ;
nameRR; ?
;RR? @
stringSS 
spriteNumberSS +
=SS, -
RegexSS. 3
.SS3 4
MatchSS4 9
(SS9 :

spriteNameSS: D
,SSD E
$strSSF N
)SSN O
.SSO P
ValueSSP U
;SSU V
SpriteUU "
matchingOverrideSpriteUU 5
=UU6 7
overrideSpritesUU8 G
.UUG H
FirstUUH M
(UUM N
spriteUUN T
=>UUU W
spriteUUX ^
.UU^ _
nameUU_ c
.UUc d
EndsWithUUd l
(UUl m
spriteNumberUUm y
)UUy z
)UUz {
;UU{ |
	m_tilesetWW !
[WW! "
originalSpriteWW" 0
]WW0 1
=WW2 3"
matchingOverrideSpriteWW4 J
;WWJ K
}XX 
}YY 
finished[[ 
=[[ 
true[[ 
;[[  
}\\ 
catch]] 
(]] 
System]] 
.]] %
InvalidOperationException]] 2
ex]]3 5
)]]5 6
{]]7 8
throw^^ 
(^^ 
new^^ 
System^^ !
.^^! "'
ArgumentOutOfRangeException^^" =
(^^= >
$str^^> U
,^^U V
ex^^W Y
)^^Y Z
)^^Z [
;^^[ \
}__ 
finally`` 
{`` 
ifcc 
(cc 
!cc 
finishedcc 
)cc 
{cc 
Undodd 
.dd 
PerformUndodd $
(dd$ %
)dd% &
;dd& '
}ee 
}ff 
}gg 	
}ii 
}jj ”з
©C:\Users\Davis\Desktop\Facultad\5to Periodo\Tecnologias\Pacman\ClientePacman\Packages\com.unity.2d.tilemap.extras\Editor\Tiles\RuleOverrideTile\RuleOverrideTileEditor.cs
	namespace 	
UnityEditor
 
{ 
[		 
CustomEditor		 
(		 
typeof		 
(		 
RuleOverrideTile		 )
)		) *
)		* +
]		+ ,
public

 

class

 "
RuleOverrideTileEditor

 '
:

( )
Editor

* 0
{ 
public 
RuleOverrideTile 
overrideTile  ,
{- .
get/ 2
{3 4
return5 ;
(< =
target= C
asD F
RuleOverrideTileG W
)W X
;X Y
}Z [
}\ ]
public 
RuleTileEditor 
ruleTileEditor ,
{ 	
get 
{ 
if 
(  
m_RuleTileEditorTile (
!=) +
overrideTile, 8
.8 9
m_Tile9 ?
)? @
{ 
DestroyImmediate $
($ %
m_RuleTileEditor% 5
)5 6
;6 7
m_RuleTileEditor $
=% &
Editor' -
.- .
CreateEditor. :
(: ;
overrideTile; G
.G H
m_TileH N
)N O
asP R
RuleTileEditorS a
;a b 
m_RuleTileEditorTile (
=) *
overrideTile+ 7
.7 8
m_Tile8 >
;> ?
} 
return 
m_RuleTileEditor '
;' (
} 
} 	
private 
List 
< 
KeyValuePair !
<! "
Sprite" (
,( )
Sprite* 0
>0 1
>1 2
	m_Sprites3 <
;< =
private 
List 
< 
KeyValuePair !
<! "
RuleTile" *
.* +

TilingRule+ 5
,5 6
RuleTile7 ?
.? @

TilingRule@ J
>J K
>K L
m_RulesM T
;T U
ReorderableList 
m_SpriteList $
;$ %
ReorderableList   

m_RuleList   "
;  " #
RuleTileEditor!! 
m_RuleTileEditor!! '
;!!' (
RuleTile""  
m_RuleTileEditorTile"" %
;""% &
private$$ 
float$$ "
k_DefaultElementHeight$$ ,
{$$- .
get$$/ 2
{$$3 4
return$$5 ;
RuleTileEditor$$< J
.$$J K"
k_DefaultElementHeight$$K a
;$$a b
}$$c d
}$$e f
private%% 
float%% !
k_PaddingBetweenRules%% +
{%%, -
get%%. 1
{%%2 3
return%%4 :
RuleTileEditor%%; I
.%%I J!
k_PaddingBetweenRules%%J _
;%%_ `
}%%a b
}%%c d
private&& 
float&& 
k_SingleLineHeight&& (
{&&) *
get&&+ .
{&&/ 0
return&&1 7
RuleTileEditor&&8 F
.&&F G
k_SingleLineHeight&&G Y
;&&Y Z
}&&[ \
}&&] ^
private'' 
float'' 
k_LabelWidth'' "
{''# $
get''% (
{'') *
return''+ 1
RuleTileEditor''2 @
.''@ A
k_LabelWidth''A M
;''M N
}''O P
}''Q R
void)) 
OnEnable)) 
()) 
))) 
{** 	
if++ 
(++ 
	m_Sprites++ 
==++ 
null++ !
)++! "
	m_Sprites,, 
=,, 
new,, 
List,,  $
<,,$ %
KeyValuePair,,% 1
<,,1 2
Sprite,,2 8
,,,8 9
Sprite,,: @
>,,@ A
>,,A B
(,,B C
),,C D
;,,D E
if.. 
(.. 
m_Rules.. 
==.. 
null.. 
)..  
m_Rules// 
=// 
new// 
List// "
<//" #
KeyValuePair//# /
</// 0
RuleTile//0 8
.//8 9

TilingRule//9 C
,//C D
RuleTile//E M
.//M N

TilingRule//N X
>//X Y
>//Y Z
(//Z [
)//[ \
;//\ ]
if11 
(11 
m_SpriteList11 
==11 
null11  $
)11$ %
{22 
overrideTile33 
.33 
GetOverrides33 )
(33) *
	m_Sprites33* 3
)333 4
;334 5
m_SpriteList55 
=55 
new55 "
ReorderableList55# 2
(552 3
	m_Sprites553 <
,55< =
typeof55> D
(55D E
KeyValuePair55E Q
<55Q R
Sprite55R X
,55X Y
Sprite55Z `
>55` a
)55a b
,55b c
false55d i
,55i j
true55k o
,55o p
false55q v
,55v w
false55x }
)55} ~
;55~ 
m_SpriteList66 
.66 
drawHeaderCallback66 /
=660 1
DrawSpriteHeader662 B
;66B C
m_SpriteList77 
.77 
drawElementCallback77 0
=771 2
DrawSpriteElement773 D
;77D E
m_SpriteList88 
.88 
elementHeight88 *
=88+ ,"
k_DefaultElementHeight88- C
+88D E!
k_PaddingBetweenRules88F [
;88[ \
}99 
if:: 
(:: 

m_RuleList:: 
==:: 
null:: "
)::" #
{;; 
overrideTile<< 
.<< 
GetOverrides<< )
(<<) *
m_Rules<<* 1
)<<1 2
;<<2 3

m_RuleList>> 
=>> 
new>>  
ReorderableList>>! 0
(>>0 1
m_Rules>>1 8
,>>8 9
typeof>>: @
(>>@ A
KeyValuePair>>A M
<>>M N
RuleTile>>N V
.>>V W

TilingRule>>W a
,>>a b
RuleTile>>c k
.>>k l

TilingRule>>l v
>>>v w
)>>w x
,>>x y
false>>z 
,	>> Ђ
true
>>Ѓ …
,
>>… †
false
>>‡ Њ
,
>>Њ Ќ
false
>>Ћ “
)
>>“ ”
;
>>” •

m_RuleList?? 
.?? 
drawHeaderCallback?? -
=??. /
DrawRuleHeader??0 >
;??> ?

m_RuleList@@ 
.@@ 
drawElementCallback@@ .
=@@/ 0
DrawRuleElement@@1 @
;@@@ A

m_RuleListAA 
.AA !
elementHeightCallbackAA 0
=AA1 2 
GetRuleElementHeightAA3 G
;AAG H
}BB 
}CC 	
voidEE 
	OnDisableEE 
(EE 
)EE 
{FF 	
DestroyImmediateGG 
(GG 
ruleTileEditorGG +
)GG+ ,
;GG, - 
m_RuleTileEditorTileHH  
=HH! "
nullHH# '
;HH' (
}II 	
publicKK 
overrideKK 
voidKK 
OnInspectorGUIKK +
(KK+ ,
)KK, -
{LL 	
serializedObjectMM 
.MM $
UpdateIfRequiredOrScriptMM 5
(MM5 6
)MM6 7
;MM7 8
	EditorGUIOO 
.OO 
BeginChangeCheckOO &
(OO& '
)OO' (
;OO( )
EditorGUILayoutQQ 
.QQ 
PropertyFieldQQ )
(QQ) *
serializedObjectQQ* :
.QQ: ;
FindPropertyQQ; G
(QQG H
$strQQH P
)QQP Q
)QQQ R
;QQR S
ifRR 
(RR 
overrideTileRR 
.RR 
m_InstanceTileRR +
)RR+ ,
{SS 
SerializedObjectTT  (
instanceTileSerializedObjectTT! =
=TT> ?
newTT@ C
SerializedObjectTTD T
(TTT U
overrideTileTTU a
.TTa b
m_InstanceTileTTb p
)TTp q
;TTq r
overrideTileUU 
.UU 
m_InstanceTileUU +
.UU+ ,
	hideFlagsUU, 5
=UU6 7
	HideFlagsUU8 A
.UUA B
NoneUUB F
;UUF G
RuleTileEditorVV 
.VV 
DrawCustomFieldsVV /
(VV/ 0
overrideTileVV0 <
.VV< =
m_InstanceTileVV= K
,VVK L(
instanceTileSerializedObjectVVM i
)VVi j
;VVj k
overrideTileWW 
.WW 
m_InstanceTileWW +
.WW+ ,
	hideFlagsWW, 5
=WW6 7
	HideFlagsWW8 A
.WWA B
NotEditableWWB M
;WWM N(
instanceTileSerializedObjectXX ,
.XX, -#
ApplyModifiedPropertiesXX- D
(XXD E
)XXE F
;XXF G
}YY 
EditorGUILayoutZZ 
.ZZ 
PropertyFieldZZ )
(ZZ) *
serializedObjectZZ* :
.ZZ: ;
FindPropertyZZ; G
(ZZG H
$strZZH T
)ZZT U
)ZZU V
;ZZV W
serializedObject[[ 
.[[ #
ApplyModifiedProperties[[ 4
([[4 5
)[[5 6
;[[6 7
if]] 
(]] 
	EditorGUI]] 
.]] 
EndChangeCheck]] (
(]]( )
)]]) *
)]]* +
{^^ 
UpdateInstanceTile__ "
(__" #
)__# $
;__$ %
SaveTile`` 
(`` 
)`` 
;`` 
}aa 
ifcc 
(cc 
!cc 
overrideTilecc 
.cc 

m_Advancedcc (
)cc( )
{dd 
usingee 
(ee 
newee 
	EditorGUIee $
.ee$ %
DisabledScopeee% 2
(ee2 3
overrideTileee3 ?
.ee? @
m_Tileee@ F
==eeG I
nulleeJ N
)eeN O
)eeO P
{ff 
	EditorGUIgg 
.gg 
BeginChangeCheckgg .
(gg. /
)gg/ 0
;gg0 1
overrideTilehh  
.hh  !
GetOverrideshh! -
(hh- .
	m_Spriteshh. 7
)hh7 8
;hh8 9
m_SpriteListjj  
.jj  !
listjj! %
=jj& '
	m_Spritesjj( 1
;jj1 2
m_SpriteListkk  
.kk  !
DoLayoutListkk! -
(kk- .
)kk. /
;kk/ 0
ifll 
(ll 
	EditorGUIll !
.ll! "
EndChangeCheckll" 0
(ll0 1
)ll1 2
)ll2 3
{mm 
fornn 
(nn 
intnn  
inn! "
=nn# $
$numnn% &
;nn& '
inn( )
<nn* +
targetsnn, 3
.nn3 4
Lengthnn4 :
;nn: ;
inn< =
++nn= ?
)nn? @
{oo 
RuleOverrideTilepp ,
tilepp- 1
=pp2 3
targetspp4 ;
[pp; <
ipp< =
]pp= >
aspp? A
RuleOverrideTileppB R
;ppR S
tileqq  
.qq  !
ApplyOverridesqq! /
(qq/ 0
	m_Spritesqq0 9
)qq9 :
;qq: ;
SaveTilerr $
(rr$ %
)rr% &
;rr& '
}ss 
}tt 
}uu 
}vv 
elseww 
{xx 
usingyy 
(yy 
newyy 
	EditorGUIyy $
.yy$ %
DisabledScopeyy% 2
(yy2 3
overrideTileyy3 ?
.yy? @
m_Tileyy@ F
==yyG I
nullyyJ N
)yyN O
)yyO P
{zz 
overrideTile{{  
.{{  !
GetOverrides{{! -
({{- .
m_Rules{{. 5
){{5 6
;{{6 7

m_RuleList}} 
.}} 
list}} #
=}}$ %
m_Rules}}& -
;}}- .

m_RuleList~~ 
.~~ 
DoLayoutList~~ +
(~~+ ,
)~~, -
;~~- .
} 
}
ЂЂ 
}
ЃЃ 	
private
ѓѓ 
void
ѓѓ  
UpdateInstanceTile
ѓѓ '
(
ѓѓ' (
)
ѓѓ( )
{
„„ 	
bool
…… 
assetChanged
…… 
=
…… 
false
……  %
;
……% &
if
‡‡ 
(
‡‡ 
overrideTile
‡‡ 
.
‡‡ 
m_InstanceTile
‡‡ +
)
‡‡+ ,
{
€€ 
if
‰‰ 
(
‰‰ 
!
‰‰ 
overrideTile
‰‰ !
.
‰‰! "
m_Tile
‰‰" (
||
‰‰) +
overrideTile
‰‰, 8
.
‰‰8 9
m_InstanceTile
‰‰9 G
.
‰‰G H
GetType
‰‰H O
(
‰‰O P
)
‰‰P Q
!=
‰‰R T
overrideTile
‰‰U a
.
‰‰a b
m_Tile
‰‰b h
.
‰‰h i
GetType
‰‰i p
(
‰‰p q
)
‰‰q r
)
‰‰r s
{
ЉЉ 
DestroyImmediate
‹‹ $
(
‹‹$ %
overrideTile
‹‹% 1
.
‹‹1 2
m_InstanceTile
‹‹2 @
,
‹‹@ A
true
‹‹B F
)
‹‹F G
;
‹‹G H
overrideTile
ЊЊ  
.
ЊЊ  !
m_InstanceTile
ЊЊ! /
=
ЊЊ0 1
null
ЊЊ2 6
;
ЊЊ6 7
assetChanged
ЌЌ  
=
ЌЌ! "
true
ЌЌ# '
;
ЌЌ' (
}
ЋЋ 
}
ЏЏ 
if
ђђ 
(
ђђ 
!
ђђ 
overrideTile
ђђ 
.
ђђ 
m_InstanceTile
ђђ ,
)
ђђ, -
{
‘‘ 
if
’’ 
(
’’ 
overrideTile
’’  
.
’’  !
m_Tile
’’! '
)
’’' (
{
““ 
var
”” 
t
”” 
=
”” 
overrideTile
”” (
.
””( )
m_Tile
””) /
.
””/ 0
GetType
””0 7
(
””7 8
)
””8 9
;
””9 :
RuleTile
•• 
instanceTile
•• )
=
••* +
ScriptableObject
••, <
.
••< =
CreateInstance
••= K
(
••K L
t
••L M
)
••M N
as
••O Q
RuleTile
••R Z
;
••Z [
instanceTile
––  
.
––  !
	hideFlags
––! *
=
––+ ,
	HideFlags
––- 6
.
––6 7
NotEditable
––7 B
;
––B C
AssetDatabase
—— !
.
——! "
AddObjectToAsset
——" 2
(
——2 3
instanceTile
——3 ?
,
——? @
overrideTile
——A M
)
——M N
;
——N O
overrideTile
  
.
  !
m_InstanceTile
! /
=
0 1
instanceTile
2 >
;
> ?
assetChanged
™™  
=
™™! "
true
™™# '
;
™™' (
}
љљ 
}
›› 
if
ќќ 
(
ќќ 
overrideTile
ќќ 
.
ќќ 
m_InstanceTile
ќќ +
)
ќќ+ ,
{
ћћ 
string
џџ 
instanceTileName
џџ '
=
џџ( )
overrideTile
џџ* 6
.
џџ6 7
m_Tile
џџ7 =
.
џџ= >
name
џџ> B
+
џџC D
$str
џџE R
;
џџR S
if
   
(
   
overrideTile
    
.
    !
m_InstanceTile
  ! /
.
  / 0
name
  0 4
!=
  5 7
instanceTileName
  8 H
)
  H I
{
ЎЎ 
overrideTile
ўў  
.
ўў  !
m_InstanceTile
ўў! /
.
ўў/ 0
name
ўў0 4
=
ўў5 6
instanceTileName
ўў7 G
;
ўўG H
assetChanged
ЈЈ  
=
ЈЈ! "
true
ЈЈ# '
;
ЈЈ' (
}
¤¤ 
}
ҐҐ 
if
§§ 
(
§§ 
assetChanged
§§ 
)
§§ 
AssetDatabase
ЁЁ 
.
ЁЁ 

SaveAssets
ЁЁ (
(
ЁЁ( )
)
ЁЁ) *
;
ЁЁ* +
}
©© 	
private
«« 
void
«« 
SaveTile
«« 
(
«« 
)
«« 
{
¬¬ 	
EditorUtility
­­ 
.
­­ 
SetDirty
­­ "
(
­­" #
target
­­# )
)
­­) *
;
­­* +
	SceneView
®® 
.
®® 

RepaintAll
®®  
(
®®  !
)
®®! "
;
®®" #
overrideTile
°° 
.
°° 
Override
°° !
(
°°! "
)
°°" #
;
°°# $
}
±± 	
private
іі 
void
іі 
DrawSpriteElement
іі &
(
іі& '
Rect
іі' +
rect
іі, 0
,
іі0 1
int
іі2 5
index
іі6 ;
,
іі; <
bool
іі= A
selected
ііB J
,
ііJ K
bool
ііL P
focused
ііQ X
)
ііX Y
{
ґґ 	
Sprite
µµ 
originalSprite
µµ !
=
µµ" #
	m_Sprites
µµ$ -
[
µµ- .
index
µµ. 3
]
µµ3 4
.
µµ4 5
Key
µµ5 8
;
µµ8 9
Sprite
¶¶ 
overrideSprite
¶¶ !
=
¶¶" #
	m_Sprites
¶¶$ -
[
¶¶- .
index
¶¶. 3
]
¶¶3 4
.
¶¶4 5
Value
¶¶5 :
;
¶¶: ;
rect
ёё 
.
ёё 
y
ёё 
+=
ёё 
$num
ёё 
;
ёё 
rect
№№ 
.
№№ 
height
№№ 
-=
№№ #
k_PaddingBetweenRules
№№ 0
;
№№0 1
rect
»» 
.
»» 
xMax
»» 
=
»» 
rect
»» 
.
»» 
xMax
»» !
/
»»" #
$num
»»$ (
;
»»( )
using
јј 
(
јј 
new
јј 
	EditorGUI
јј  
.
јј  !
DisabledScope
јј! .
(
јј. /
true
јј/ 3
)
јј3 4
)
јј4 5
	EditorGUI
ЅЅ 
.
ЅЅ 
ObjectField
ЅЅ %
(
ЅЅ% &
new
ЅЅ& )
Rect
ЅЅ* .
(
ЅЅ. /
rect
ЅЅ/ 3
.
ЅЅ3 4
xMin
ЅЅ4 8
,
ЅЅ8 9
rect
ЅЅ: >
.
ЅЅ> ?
yMin
ЅЅ? C
,
ЅЅC D
rect
ЅЅE I
.
ЅЅI J
height
ЅЅJ P
,
ЅЅP Q
rect
ЅЅR V
.
ЅЅV W
height
ЅЅW ]
)
ЅЅ] ^
,
ЅЅ^ _
originalSprite
ЅЅ` n
,
ЅЅn o
typeof
ЅЅp v
(
ЅЅv w
Sprite
ЅЅw }
)
ЅЅ} ~
,
ЅЅ~ 
falseЅЅЂ …
)ЅЅ… †
;ЅЅ† ‡
rect
ѕѕ 
.
ѕѕ 
xMin
ѕѕ 
=
ѕѕ 
rect
ѕѕ 
.
ѕѕ 
xMax
ѕѕ !
;
ѕѕ! "
rect
її 
.
її 
xMax
її 
*=
її 
$num
її 
;
її 
	EditorGUI
ББ 
.
ББ 
BeginChangeCheck
ББ &
(
ББ& '
)
ББ' (
;
ББ( )
overrideSprite
ВВ 
=
ВВ 
	EditorGUI
ВВ &
.
ВВ& '
ObjectField
ВВ' 2
(
ВВ2 3
new
ВВ3 6
Rect
ВВ7 ;
(
ВВ; <
rect
ВВ< @
.
ВВ@ A
xMin
ВВA E
,
ВВE F
rect
ВВG K
.
ВВK L
yMin
ВВL P
,
ВВP Q
rect
ВВR V
.
ВВV W
height
ВВW ]
,
ВВ] ^
rect
ВВ_ c
.
ВВc d
height
ВВd j
)
ВВj k
,
ВВk l
overrideSprite
ВВm {
,
ВВ{ |
typeofВВ} ѓ
(ВВѓ „
SpriteВВ„ Љ
)ВВЉ ‹
,ВВ‹ Њ
falseВВЌ ’
)ВВ’ “
asВВ” –
SpriteВВ— ќ
;ВВќ ћ
if
ГГ 
(
ГГ 
	EditorGUI
ГГ 
.
ГГ 
EndChangeCheck
ГГ (
(
ГГ( )
)
ГГ) *
)
ГГ* +
{
ДД 
	m_Sprites
ЕЕ 
[
ЕЕ 
index
ЕЕ 
]
ЕЕ  
=
ЕЕ! "
new
ЕЕ# &
KeyValuePair
ЕЕ' 3
<
ЕЕ3 4
Sprite
ЕЕ4 :
,
ЕЕ: ;
Sprite
ЕЕ< B
>
ЕЕB C
(
ЕЕC D
originalSprite
ЕЕD R
,
ЕЕR S
overrideSprite
ЕЕT b
)
ЕЕb c
;
ЕЕc d
}
ЖЖ 
}
ЗЗ 	
private
ИИ 
void
ИИ 
DrawSpriteHeader
ИИ %
(
ИИ% &
Rect
ИИ& *
rect
ИИ+ /
)
ИИ/ 0
{
ЙЙ 	
float
КК 
xMax
КК 
=
КК 
rect
КК 
.
КК 
xMax
КК "
;
КК" #
rect
ЛЛ 
.
ЛЛ 
xMax
ЛЛ 
=
ЛЛ 
rect
ЛЛ 
.
ЛЛ 
xMax
ЛЛ !
/
ЛЛ" #
$num
ЛЛ$ (
;
ЛЛ( )
GUI
ММ 
.
ММ 
Label
ММ 
(
ММ 
rect
ММ 
,
ММ 
$str
ММ &
,
ММ& '
EditorStyles
ММ( 4
.
ММ4 5
label
ММ5 :
)
ММ: ;
;
ММ; <
rect
НН 
.
НН 
xMin
НН 
=
НН 
rect
НН 
.
НН 
xMax
НН !
;
НН! "
rect
ОО 
.
ОО 
xMax
ОО 
=
ОО 
xMax
ОО 
;
ОО 
GUI
ПП 
.
ПП 
Label
ПП 
(
ПП 
rect
ПП 
,
ПП 
$str
ПП &
,
ПП& '
EditorStyles
ПП( 4
.
ПП4 5
label
ПП5 :
)
ПП: ;
;
ПП; <
}
РР 	
private
ТТ 
void
ТТ 
DrawRuleElement
ТТ $
(
ТТ$ %
Rect
ТТ% )
rect
ТТ* .
,
ТТ. /
int
ТТ0 3
index
ТТ4 9
,
ТТ9 :
bool
ТТ; ?
selected
ТТ@ H
,
ТТH I
bool
ТТJ N
focused
ТТO V
)
ТТV W
{
УУ 	
RuleTile
ФФ 
.
ФФ 

TilingRule
ФФ 
originalRule
ФФ  ,
=
ФФ- .
m_Rules
ФФ/ 6
[
ФФ6 7
index
ФФ7 <
]
ФФ< =
.
ФФ= >
Key
ФФ> A
;
ФФA B
RuleTile
ХХ 
.
ХХ 

TilingRule
ХХ 
overrideRule
ХХ  ,
=
ХХ- .
m_Rules
ХХ/ 6
[
ХХ6 7
index
ХХ7 <
]
ХХ< =
.
ХХ= >
Value
ХХ> C
;
ХХC D
float
ЧЧ 
matrixWidth
ЧЧ 
=
ЧЧ $
k_DefaultElementHeight
ЧЧ  6
;
ЧЧ6 7
float
ЩЩ 
xMax
ЩЩ 
=
ЩЩ 
rect
ЩЩ 
.
ЩЩ 
xMax
ЩЩ "
;
ЩЩ" #
rect
ЪЪ 
.
ЪЪ 
xMax
ЪЪ 
=
ЪЪ 
rect
ЪЪ 
.
ЪЪ 
xMax
ЪЪ !
/
ЪЪ" #
$num
ЪЪ$ (
+
ЪЪ) *
matrixWidth
ЪЪ+ 6
-
ЪЪ7 8
$num
ЪЪ9 <
;
ЪЪ< =
if
ЬЬ 
(
ЬЬ 
index
ЬЬ 
!=
ЬЬ 
overrideTile
ЬЬ %
.
ЬЬ% &
m_Tile
ЬЬ& ,
.
ЬЬ, -
m_TilingRules
ЬЬ- :
.
ЬЬ: ;
Count
ЬЬ; @
)
ЬЬ@ A%
DrawOriginalRuleElement
ЭЭ '
(
ЭЭ' (
rect
ЭЭ( ,
,
ЭЭ, -
originalRule
ЭЭ. :
)
ЭЭ: ;
;
ЭЭ; <
else
ЮЮ %
DrawOriginalRuleElement
ЯЯ '
(
ЯЯ' (
rect
ЯЯ( ,
,
ЯЯ, -
originalRule
ЯЯ. :
,
ЯЯ: ;
true
ЯЯ< @
)
ЯЯ@ A
;
ЯЯA B
rect
бб 
.
бб 
xMin
бб 
=
бб 
rect
бб 
.
бб 
xMax
бб !
;
бб! "
rect
вв 
.
вв 
xMax
вв 
=
вв 
xMax
вв 
;
вв 
	EditorGUI
дд 
.
дд 
BeginChangeCheck
дд &
(
дд& '
)
дд' (
;
дд( )
if
ее 
(
ее 
index
ее 
!=
ее 
overrideTile
ее %
.
ее% &
m_Tile
ее& ,
.
ее, -
m_TilingRules
ее- :
.
ее: ;
Count
ее; @
)
ее@ A!
DrawOverrideElement
жж #
(
жж# $
rect
жж$ (
,
жж( )
originalRule
жж* 6
)
жж6 7
;
жж7 8
else
зз (
DrawOverrideDefaultElement
ии *
(
ии* +
rect
ии+ /
,
ии/ 0
overrideRule
ии1 =
)
ии= >
;
ии> ?
if
йй 
(
йй 
	EditorGUI
йй 
.
йй 
EndChangeCheck
йй (
(
йй( )
)
йй) *
)
йй* +
SaveTile
кк 
(
кк 
)
кк 
;
кк 
}
лл 	
public
мм 
void
мм %
DrawOriginalRuleElement
мм +
(
мм+ ,
Rect
мм, 0
rect
мм1 5
,
мм5 6
RuleTile
мм7 ?
.
мм? @

TilingRule
мм@ J
originalRule
ммK W
,
ммW X
bool
ммY ]
	isDefault
мм^ g
=
ммh i
false
ммj o
)
ммo p
{
нн 	
using
оо 
(
оо 
new
оо 
	EditorGUI
оо  
.
оо  !
DisabledScope
оо! .
(
оо. /
true
оо/ 3
)
оо3 4
)
оо4 5
{
пп 
float
рр 
yPos
рр 
=
рр 
rect
рр !
.
рр! "
yMin
рр" &
+
рр' (
$num
рр) +
;
рр+ ,
float
сс 
height
сс 
=
сс 
rect
сс #
.
сс# $
height
сс$ *
-
сс+ ,#
k_PaddingBetweenRules
сс- B
;
ссB C
float
тт 
matrixWidth
тт !
=
тт" #$
k_DefaultElementHeight
тт$ :
;
тт: ;
	BoundsInt
фф 

ruleBounds
фф $
=
фф% &
originalRule
фф' 3
.
фф3 4
	GetBounds
фф4 =
(
фф= >
)
фф> ?
;
фф? @
	BoundsInt
хх 
ruleGuiBounds
хх '
=
хх( )
ruleTileEditor
хх* 8
.
хх8 9
GetRuleGUIBounds
хх9 I
(
ххI J

ruleBounds
ххJ T
,
ххT U
originalRule
ххV b
)
ххb c
;
ххc d
Vector2
цц 

matrixSize
цц "
=
цц# $
ruleTileEditor
цц% 3
.
цц3 4
GetMatrixSize
цц4 A
(
ццA B
ruleGuiBounds
ццB O
)
ццO P
;
ццP Q
Vector2
чч 
matrixSizeRate
чч &
=
чч' (

matrixSize
чч) 3
/
чч4 5
Mathf
чч6 ;
.
чч; <
Max
чч< ?
(
чч? @

matrixSize
чч@ J
.
ччJ K
x
ччK L
,
ччL M

matrixSize
ччN X
.
ччX Y
y
ччY Z
)
ччZ [
;
чч[ \
Vector2
шш 
matrixRectSize
шш &
=
шш' (
new
шш) ,
Vector2
шш- 4
(
шш4 5
matrixWidth
шш5 @
*
шшA B
matrixSizeRate
шшC Q
.
шшQ R
x
шшR S
,
шшS T$
k_DefaultElementHeight
шшU k
*
шшl m
matrixSizeRate
шшn |
.
шш| }
y
шш} ~
)
шш~ 
;шш Ђ
Vector2
щщ  
matrixRectPosition
щщ *
=
щщ+ ,
new
щщ- 0
Vector2
щщ1 8
(
щщ8 9
rect
щщ9 =
.
щщ= >
xMax
щщ> B
-
щщC D
matrixWidth
щщE P
*
щщQ R
$num
щщS U
-
щщV W
$num
щщX [
,
щщ[ \
yPos
щщ] a
)
щщa b
;
щщb c 
matrixRectPosition
ъъ "
.
ъъ" #
x
ъъ# $
+=
ъъ% '
(
ъъ( )
matrixWidth
ъъ) 4
-
ъъ5 6
matrixRectSize
ъъ7 E
.
ъъE F
x
ъъF G
)
ъъG H
*
ъъI J
$num
ъъK O
;
ъъO P 
matrixRectPosition
ыы "
.
ыы" #
y
ыы# $
+=
ыы% '
(
ыы( )$
k_DefaultElementHeight
ыы) ?
-
ыы@ A
matrixRectSize
ыыB P
.
ыыP Q
y
ыыQ R
)
ыыR S
*
ыыT U
$num
ыыV Z
;
ыыZ [
Rect
ээ 
inspectorRect
ээ "
=
ээ# $
new
ээ% (
Rect
ээ) -
(
ээ- .
rect
ээ. 2
.
ээ2 3
xMin
ээ3 7
,
ээ7 8
yPos
ээ9 =
,
ээ= >
rect
ээ? C
.
ээC D
width
ээD I
-
ээJ K
matrixWidth
ээL W
*
ээX Y
$num
ээZ \
-
ээ] ^
$num
ээ_ b
,
ээb c
height
ээd j
)
ээj k
;
ээk l
Rect
юю 

matrixRect
юю 
=
юю  !
new
юю" %
Rect
юю& *
(
юю* + 
matrixRectPosition
юю+ =
,
юю= >
matrixRectSize
юю? M
)
ююM N
;
ююN O
Rect
яя 

spriteRect
яя 
=
яя  !
new
яя" %
Rect
яя& *
(
яя* +
rect
яя+ /
.
яя/ 0
xMax
яя0 4
-
яя5 6
matrixWidth
яя7 B
-
яяC D
$num
яяE G
,
яяG H
yPos
яяI M
,
яяM N
matrixWidth
яяO Z
,
яяZ [$
k_DefaultElementHeight
яя\ r
)
яяr s
;
яяs t
if
‚‚ 
(
‚‚ 
!
‚‚ 
	isDefault
‚‚ 
)
‚‚ 
{
ѓѓ 
ruleTileEditor
„„ "
.
„„" # 
RuleInspectorOnGUI
„„# 5
(
„„5 6
inspectorRect
„„6 C
,
„„C D
originalRule
„„E Q
)
„„Q R
;
„„R S
ruleTileEditor
…… "
.
……" #
RuleMatrixOnGUI
……# 2
(
……2 3
overrideTile
……3 ?
.
……? @
m_Tile
……@ F
,
……F G

matrixRect
……H R
,
……R S
ruleGuiBounds
……T a
,
……a b
originalRule
……c o
)
……o p
;
……p q
}
†† 
else
‡‡ 
{
€€ /
!RuleOriginalDefaultInspectorOnGUI
‰‰ 5
(
‰‰5 6
inspectorRect
‰‰6 C
,
‰‰C D
originalRule
‰‰E Q
)
‰‰Q R
;
‰‰R S
}
ЉЉ 
ruleTileEditor
ЊЊ 
.
ЊЊ 
SpriteOnGUI
ЊЊ *
(
ЊЊ* +

spriteRect
ЊЊ+ 5
,
ЊЊ5 6
originalRule
ЊЊ7 C
)
ЊЊC D
;
ЊЊD E
}
ЌЌ 
}
ЋЋ 	
private
ЏЏ 
void
ЏЏ !
DrawOverrideElement
ЏЏ (
(
ЏЏ( )
Rect
ЏЏ) -
rect
ЏЏ. 2
,
ЏЏ2 3
RuleTile
ЏЏ4 <
.
ЏЏ< =

TilingRule
ЏЏ= G
originalRule
ЏЏH T
)
ЏЏT U
{
ђђ 	
float
‘‘ 
yPos
‘‘ 
=
‘‘ 
rect
‘‘ 
.
‘‘ 
yMin
‘‘ "
+
‘‘# $
$num
‘‘% '
;
‘‘' (
float
’’ 
height
’’ 
=
’’ 
rect
’’ 
.
’’  
height
’’  &
-
’’' (#
k_PaddingBetweenRules
’’) >
;
’’> ?
float
““ 
matrixWidth
““ 
=
““ $
k_DefaultElementHeight
““  6
;
““6 7
Rect
•• 
inspectorRect
•• 
=
••  
new
••! $
Rect
••% )
(
••) *
rect
••* .
.
••. /
xMin
••/ 3
,
••3 4
yPos
••5 9
,
••9 :
rect
••; ?
.
••? @
width
••@ E
-
••F G
matrixWidth
••H S
-
••T U
$num
••V Y
,
••Y Z
height
••[ a
)
••a b
;
••b c
Rect
–– 

spriteRect
–– 
=
–– 
new
–– !
Rect
––" &
(
––& '
rect
––' +
.
––+ ,
xMax
––, 0
-
––1 2
matrixWidth
––3 >
-
––? @
$num
––A C
,
––C D
yPos
––E I
,
––I J
matrixWidth
––K V
,
––V W$
k_DefaultElementHeight
––X n
)
––n o
;
––o p(
RuleOverrideInspectorOnGUI
 &
(
& '
inspectorRect
' 4
,
4 5
originalRule
6 B
)
B C
;
C D
RuleTile
™™ 
.
™™ 

TilingRule
™™ 
overrideRule
™™  ,
=
™™- .
overrideTile
™™/ ;
[
™™; <
originalRule
™™< H
]
™™H I
;
™™I J
if
љљ 
(
љљ 
overrideRule
љљ 
!=
љљ 
null
љљ  $
)
љљ$ %
ruleTileEditor
›› 
.
›› 
SpriteOnGUI
›› *
(
››* +

spriteRect
››+ 5
,
››5 6
overrideRule
››7 C
)
››C D
;
››D E
}
њњ 	
private
ќќ 
void
ќќ /
!RuleOriginalDefaultInspectorOnGUI
ќќ 6
(
ќќ6 7
Rect
ќќ7 ;
rect
ќќ< @
,
ќќ@ A
RuleTile
ќќB J
.
ќќJ K

TilingRule
ќќK U
originalRule
ќќV b
)
ќќb c
{
ћћ 	
float
џџ 
y
џџ 
=
џџ 
rect
џџ 
.
џџ 
yMin
џџ 
;
џџ  
GUI
ЎЎ 
.
ЎЎ 
Label
ЎЎ 
(
ЎЎ 
new
ЎЎ 
Rect
ЎЎ 
(
ЎЎ 
rect
ЎЎ #
.
ЎЎ# $
xMin
ЎЎ$ (
,
ЎЎ( )
y
ЎЎ* +
,
ЎЎ+ ,
k_LabelWidth
ЎЎ- 9
,
ЎЎ9 : 
k_SingleLineHeight
ЎЎ; M
)
ЎЎM N
,
ЎЎN O
$str
ЎЎP V
)
ЎЎV W
;
ЎЎW X
	EditorGUI
ўў 
.
ўў 

LabelField
ўў  
(
ўў  !
new
ўў! $
Rect
ўў% )
(
ўў) *
rect
ўў* .
.
ўў. /
xMin
ўў/ 3
+
ўў4 5
k_LabelWidth
ўў6 B
,
ўўB C
y
ўўD E
,
ўўE F
rect
ўўG K
.
ўўK L
width
ўўL Q
-
ўўR S
k_LabelWidth
ўўT `
,
ўў` a 
k_SingleLineHeight
ўўb t
)
ўўt u
,
ўўu v
$strўўw Ђ
)ўўЂ Ѓ
;ўўЃ ‚
y
ЈЈ 
+=
ЈЈ  
k_SingleLineHeight
ЈЈ #
;
ЈЈ# $
GUI
ҐҐ 
.
ҐҐ 
Label
ҐҐ 
(
ҐҐ 
new
ҐҐ 
Rect
ҐҐ 
(
ҐҐ 
rect
ҐҐ #
.
ҐҐ# $
xMin
ҐҐ$ (
,
ҐҐ( )
y
ҐҐ* +
,
ҐҐ+ ,
k_LabelWidth
ҐҐ- 9
,
ҐҐ9 : 
k_SingleLineHeight
ҐҐ; M
)
ҐҐM N
,
ҐҐN O
$str
ҐҐP Z
)
ҐҐZ [
;
ҐҐ[ \
	EditorGUI
¦¦ 
.
¦¦ 
	EnumPopup
¦¦ 
(
¦¦  
new
¦¦  #
Rect
¦¦$ (
(
¦¦( )
rect
¦¦) -
.
¦¦- .
xMin
¦¦. 2
+
¦¦3 4
k_LabelWidth
¦¦5 A
,
¦¦A B
y
¦¦C D
,
¦¦D E
rect
¦¦F J
.
¦¦J K
width
¦¦K P
-
¦¦Q R
k_LabelWidth
¦¦S _
,
¦¦_ ` 
k_SingleLineHeight
¦¦a s
)
¦¦s t
,
¦¦t u
originalRule¦¦v ‚
.¦¦‚ ѓ
m_ColliderType¦¦ѓ ‘
)¦¦‘ ’
;¦¦’ “
y
§§ 
+=
§§  
k_SingleLineHeight
§§ #
;
§§# $
}
ЁЁ 	
private
©© 
void
©© (
RuleOverrideInspectorOnGUI
©© /
(
©©/ 0
Rect
©©0 4
rect
©©5 9
,
©©9 :
RuleTile
©©; C
.
©©C D

TilingRule
©©D N
originalRule
©©O [
)
©©[ \
{
ЄЄ 	
RuleTile
«« 
.
«« 

TilingRule
«« 
overrideRule
««  ,
=
««- .
overrideTile
««/ ;
[
««; <
originalRule
««< H
]
««H I
;
««I J
float
­­ 
y
­­ 
=
­­ 
rect
­­ 
.
­­ 
yMin
­­ 
;
­­  
	EditorGUI
®® 
.
®® 
BeginChangeCheck
®® &
(
®®& '
)
®®' (
;
®®( )
GUI
°° 
.
°° 
Label
°° 
(
°° 
new
°° 
Rect
°° 
(
°° 
rect
°° #
.
°°# $
xMin
°°$ (
,
°°( )
y
°°* +
,
°°+ ,
k_LabelWidth
°°- 9
,
°°9 : 
k_SingleLineHeight
°°; M
)
°°M N
,
°°N O
$str
°°P Y
)
°°Y Z
;
°°Z [
bool
±± 
enabled
±± 
=
±± 
	EditorGUI
±± $
.
±±$ %
Toggle
±±% +
(
±±+ ,
new
±±, /
Rect
±±0 4
(
±±4 5
rect
±±5 9
.
±±9 :
xMin
±±: >
+
±±? @
k_LabelWidth
±±A M
,
±±M N
y
±±O P
,
±±P Q
rect
±±R V
.
±±V W
width
±±W \
-
±±] ^
k_LabelWidth
±±_ k
,
±±k l 
k_SingleLineHeight
±±m 
)±± Ђ
,±±Ђ Ѓ
overrideRule±±‚ Ћ
!=±±Џ ‘
null±±’ –
)±±– —
;±±— 
y
ІІ 
+=
ІІ  
k_SingleLineHeight
ІІ #
;
ІІ# $
if
ґґ 
(
ґґ 
	EditorGUI
ґґ 
.
ґґ 
EndChangeCheck
ґґ (
(
ґґ( )
)
ґґ) *
)
ґґ* +
{
µµ 
if
¶¶ 
(
¶¶ 
enabled
¶¶ 
)
¶¶ 
overrideTile
··  
[
··  !
originalRule
··! -
]
··- .
=
··/ 0
originalRule
··1 =
;
··= >
else
ёё 
overrideTile
№№  
[
№№  !
originalRule
№№! -
]
№№- .
=
№№/ 0
null
№№1 5
;
№№5 6
overrideRule
єє 
=
єє 
overrideTile
єє +
[
єє+ ,
originalRule
єє, 8
]
єє8 9
;
єє9 :
}
»» 
if
ЅЅ 
(
ЅЅ 
overrideRule
ЅЅ 
==
ЅЅ 
null
ЅЅ  $
)
ЅЅ$ %
return
ѕѕ 
;
ѕѕ 
GUI
АА 
.
АА 
Label
АА 
(
АА 
new
АА 
Rect
АА 
(
АА 
rect
АА #
.
АА# $
xMin
АА$ (
,
АА( )
y
АА* +
,
АА+ ,
k_LabelWidth
АА- 9
,
АА9 : 
k_SingleLineHeight
АА; M
)
ААM N
,
ААN O
$str
ААP ]
)
АА] ^
;
АА^ _
overrideRule
ББ 
.
ББ 
m_GameObject
ББ %
=
ББ& '
(
ББ( )

GameObject
ББ) 3
)
ББ3 4
	EditorGUI
ББ4 =
.
ББ= >
ObjectField
ББ> I
(
ББI J
new
ББJ M
Rect
ББN R
(
ББR S
rect
ББS W
.
ББW X
xMin
ББX \
+
ББ] ^
k_LabelWidth
ББ_ k
,
ББk l
y
ББm n
,
ББn o
rect
ББp t
.
ББt u
width
ББu z
-
ББ{ |
k_LabelWidthББ} ‰
,ББ‰ Љ"
k_SingleLineHeightББ‹ ќ
)ББќ ћ
,ББћ џ
$strББ  ў
,ББў Ј
overrideRuleББ¤ °
.ББ° ±
m_GameObjectББ± Ѕ
,ББЅ ѕ
typeofББї Е
(ББЕ Ж

GameObjectББЖ Р
)ББР С
,ББС Т
falseББУ Ш
)ББШ Щ
;ББЩ Ъ
y
ВВ 
+=
ВВ  
k_SingleLineHeight
ВВ #
;
ВВ# $
GUI
ГГ 
.
ГГ 
Label
ГГ 
(
ГГ 
new
ГГ 
Rect
ГГ 
(
ГГ 
rect
ГГ #
.
ГГ# $
xMin
ГГ$ (
,
ГГ( )
y
ГГ* +
,
ГГ+ ,
k_LabelWidth
ГГ- 9
,
ГГ9 : 
k_SingleLineHeight
ГГ; M
)
ГГM N
,
ГГN O
$str
ГГP Z
)
ГГZ [
;
ГГ[ \
overrideRule
ДД 
.
ДД 
m_ColliderType
ДД '
=
ДД( )
(
ДД* +
Tile
ДД+ /
.
ДД/ 0
ColliderType
ДД0 <
)
ДД< =
	EditorGUI
ДД= F
.
ДДF G
	EnumPopup
ДДG P
(
ДДP Q
new
ДДQ T
Rect
ДДU Y
(
ДДY Z
rect
ДДZ ^
.
ДД^ _
xMin
ДД_ c
+
ДДd e
k_LabelWidth
ДДf r
,
ДДr s
y
ДДt u
,
ДДu v
rect
ДДw {
.
ДД{ |
widthДД| Ѓ
-ДД‚ ѓ
k_LabelWidthДД„ ђ
,ДДђ ‘"
k_SingleLineHeightДД’ ¤
)ДД¤ Ґ
,ДДҐ ¦
overrideRuleДД§ і
.ДДі ґ
m_ColliderTypeДДґ В
)ДДВ Г
;ДДГ Д
y
ЕЕ 
+=
ЕЕ  
k_SingleLineHeight
ЕЕ #
;
ЕЕ# $
GUI
ЖЖ 
.
ЖЖ 
Label
ЖЖ 
(
ЖЖ 
new
ЖЖ 
Rect
ЖЖ 
(
ЖЖ 
rect
ЖЖ #
.
ЖЖ# $
xMin
ЖЖ$ (
,
ЖЖ( )
y
ЖЖ* +
,
ЖЖ+ ,
k_LabelWidth
ЖЖ- 9
,
ЖЖ9 : 
k_SingleLineHeight
ЖЖ; M
)
ЖЖM N
,
ЖЖN O
$str
ЖЖP X
)
ЖЖX Y
;
ЖЖY Z
overrideRule
ЗЗ 
.
ЗЗ 
m_Output
ЗЗ !
=
ЗЗ" #
(
ЗЗ$ %
RuleTile
ЗЗ% -
.
ЗЗ- .

TilingRule
ЗЗ. 8
.
ЗЗ8 9
OutputSprite
ЗЗ9 E
)
ЗЗE F
	EditorGUI
ЗЗF O
.
ЗЗO P
	EnumPopup
ЗЗP Y
(
ЗЗY Z
new
ЗЗZ ]
Rect
ЗЗ^ b
(
ЗЗb c
rect
ЗЗc g
.
ЗЗg h
xMin
ЗЗh l
+
ЗЗm n
k_LabelWidth
ЗЗo {
,
ЗЗ{ |
y
ЗЗ} ~
,
ЗЗ~ 
rectЗЗЂ „
.ЗЗ„ …
widthЗЗ… Љ
-ЗЗ‹ Њ
k_LabelWidthЗЗЌ ™
,ЗЗ™ љ"
k_SingleLineHeightЗЗ› ­
)ЗЗ­ ®
,ЗЗ® Ї
overrideRuleЗЗ° ј
.ЗЗј Ѕ
m_OutputЗЗЅ Е
)ЗЗЕ Ж
;ЗЗЖ З
y
ИИ 
+=
ИИ  
k_SingleLineHeight
ИИ #
;
ИИ# $
if
КК 
(
КК 
overrideRule
КК 
.
КК 
m_Output
КК %
==
КК& (
RuleTile
КК) 1
.
КК1 2

TilingRule
КК2 <
.
КК< =
OutputSprite
КК= I
.
ККI J
	Animation
ККJ S
)
ККS T
{
ЛЛ 
GUI
ММ 
.
ММ 
Label
ММ 
(
ММ 
new
ММ 
Rect
ММ "
(
ММ" #
rect
ММ# '
.
ММ' (
xMin
ММ( ,
,
ММ, -
y
ММ. /
,
ММ/ 0
k_LabelWidth
ММ1 =
,
ММ= > 
k_SingleLineHeight
ММ? Q
)
ММQ R
,
ММR S
$str
ММT [
)
ММ[ \
;
ММ\ ]
overrideRule
НН 
.
НН 
m_AnimationSpeed
НН -
=
НН. /
	EditorGUI
НН0 9
.
НН9 :

FloatField
НН: D
(
ННD E
new
ННE H
Rect
ННI M
(
ННM N
rect
ННN R
.
ННR S
xMin
ННS W
+
ННX Y
k_LabelWidth
ННZ f
,
ННf g
y
ННh i
,
ННi j
rect
ННk o
.
ННo p
width
ННp u
-
ННv w
k_LabelWidthННx „
,НН„ …"
k_SingleLineHeightНН† 
)НН ™
,НН™ љ
overrideRuleНН› §
.НН§ Ё 
m_AnimationSpeedННЁ ё
)ННё №
;НН№ є
y
ОО 
+=
ОО  
k_SingleLineHeight
ОО '
;
ОО' (
}
ПП 
if
РР 
(
РР 
overrideRule
РР 
.
РР 
m_Output
РР %
==
РР& (
RuleTile
РР) 1
.
РР1 2

TilingRule
РР2 <
.
РР< =
OutputSprite
РР= I
.
РРI J
Random
РРJ P
)
РРP Q
{
СС 
GUI
ТТ 
.
ТТ 
Label
ТТ 
(
ТТ 
new
ТТ 
Rect
ТТ "
(
ТТ" #
rect
ТТ# '
.
ТТ' (
xMin
ТТ( ,
,
ТТ, -
y
ТТ. /
,
ТТ/ 0
k_LabelWidth
ТТ1 =
,
ТТ= > 
k_SingleLineHeight
ТТ? Q
)
ТТQ R
,
ТТR S
$str
ТТT [
)
ТТ[ \
;
ТТ\ ]
overrideRule
УУ 
.
УУ 
m_PerlinScale
УУ *
=
УУ+ ,
	EditorGUI
УУ- 6
.
УУ6 7
Slider
УУ7 =
(
УУ= >
new
УУ> A
Rect
УУB F
(
УУF G
rect
УУG K
.
УУK L
xMin
УУL P
+
УУQ R
k_LabelWidth
УУS _
,
УУ_ `
y
УУa b
,
УУb c
rect
УУd h
.
УУh i
width
УУi n
-
УУo p
k_LabelWidth
УУq }
,
УУ} ~!
k_SingleLineHeightУУ ‘
)УУ‘ ’
,УУ’ “
overrideRuleУУ”  
.УУ  Ў
m_PerlinScaleУУЎ ®
,УУ® Ї
$numУУ° ¶
,УУ¶ ·
$numУУё ѕ
)УУѕ ї
;УУї А
y
ФФ 
+=
ФФ  
k_SingleLineHeight
ФФ '
;
ФФ' (
GUI
ЦЦ 
.
ЦЦ 
Label
ЦЦ 
(
ЦЦ 
new
ЦЦ 
Rect
ЦЦ "
(
ЦЦ" #
rect
ЦЦ# '
.
ЦЦ' (
xMin
ЦЦ( ,
,
ЦЦ, -
y
ЦЦ. /
,
ЦЦ/ 0
k_LabelWidth
ЦЦ1 =
,
ЦЦ= > 
k_SingleLineHeight
ЦЦ? Q
)
ЦЦQ R
,
ЦЦR S
$str
ЦЦT ]
)
ЦЦ] ^
;
ЦЦ^ _
overrideRule
ЧЧ 
.
ЧЧ 
m_RandomTransform
ЧЧ .
=
ЧЧ/ 0
(
ЧЧ1 2
RuleTile
ЧЧ2 :
.
ЧЧ: ;

TilingRule
ЧЧ; E
.
ЧЧE F
	Transform
ЧЧF O
)
ЧЧO P
	EditorGUI
ЧЧP Y
.
ЧЧY Z
	EnumPopup
ЧЧZ c
(
ЧЧc d
new
ЧЧd g
Rect
ЧЧh l
(
ЧЧl m
rect
ЧЧm q
.
ЧЧq r
xMin
ЧЧr v
+
ЧЧw x
k_LabelWidthЧЧy …
,ЧЧ… †
yЧЧ‡ €
,ЧЧ€ ‰
rectЧЧЉ Ћ
.ЧЧЋ Џ
widthЧЧЏ ”
-ЧЧ• –
k_LabelWidthЧЧ— Ј
,ЧЧЈ ¤"
k_SingleLineHeightЧЧҐ ·
)ЧЧ· ё
,ЧЧё №
overrideRuleЧЧє Ж
.ЧЧЖ З!
m_RandomTransformЧЧЗ Ш
)ЧЧШ Щ
;ЧЧЩ Ъ
y
ШШ 
+=
ШШ  
k_SingleLineHeight
ШШ '
;
ШШ' (
}
ЩЩ 
if
ЫЫ 
(
ЫЫ 
overrideRule
ЫЫ 
.
ЫЫ 
m_Output
ЫЫ %
!=
ЫЫ& (
RuleTile
ЫЫ) 1
.
ЫЫ1 2

TilingRule
ЫЫ2 <
.
ЫЫ< =
OutputSprite
ЫЫ= I
.
ЫЫI J
Single
ЫЫJ P
)
ЫЫP Q
{
ЬЬ 
GUI
ЭЭ 
.
ЭЭ 
Label
ЭЭ 
(
ЭЭ 
new
ЭЭ 
Rect
ЭЭ "
(
ЭЭ" #
rect
ЭЭ# '
.
ЭЭ' (
xMin
ЭЭ( ,
,
ЭЭ, -
y
ЭЭ. /
,
ЭЭ/ 0
k_LabelWidth
ЭЭ1 =
,
ЭЭ= > 
k_SingleLineHeight
ЭЭ? Q
)
ЭЭQ R
,
ЭЭR S
$str
ЭЭT Z
)
ЭЭZ [
;
ЭЭ[ \
	EditorGUI
ЮЮ 
.
ЮЮ 
BeginChangeCheck
ЮЮ *
(
ЮЮ* +
)
ЮЮ+ ,
;
ЮЮ, -
int
ЯЯ 
	newLength
ЯЯ 
=
ЯЯ 
	EditorGUI
ЯЯ  )
.
ЯЯ) *
DelayedIntField
ЯЯ* 9
(
ЯЯ9 :
new
ЯЯ: =
Rect
ЯЯ> B
(
ЯЯB C
rect
ЯЯC G
.
ЯЯG H
xMin
ЯЯH L
+
ЯЯM N
k_LabelWidth
ЯЯO [
,
ЯЯ[ \
y
ЯЯ] ^
,
ЯЯ^ _
rect
ЯЯ` d
.
ЯЯd e
width
ЯЯe j
-
ЯЯk l
k_LabelWidth
ЯЯm y
,
ЯЯy z!
k_SingleLineHeightЯЯ{ Ќ
)ЯЯЌ Ћ
,ЯЯЋ Џ
overrideRuleЯЯђ њ
.ЯЯњ ќ
	m_SpritesЯЯќ ¦
.ЯЯ¦ §
LengthЯЯ§ ­
)ЯЯ­ ®
;ЯЯ® Ї
if
аа 
(
аа 
	EditorGUI
аа 
.
аа 
EndChangeCheck
аа ,
(
аа, -
)
аа- .
)
аа. /
Array
бб 
.
бб 
Resize
бб  
(
бб  !
ref
бб! $
overrideRule
бб% 1
.
бб1 2
	m_Sprites
бб2 ;
,
бб; <
Math
бб= A
.
ббA B
Max
ббB E
(
ббE F
	newLength
ббF O
,
ббO P
$num
ббQ R
)
ббR S
)
ббS T
;
ббT U
y
вв 
+=
вв  
k_SingleLineHeight
вв '
;
вв' (
for
дд 
(
дд 
int
дд 
i
дд 
=
дд 
$num
дд 
;
дд 
i
дд  !
<
дд" #
overrideRule
дд$ 0
.
дд0 1
	m_Sprites
дд1 :
.
дд: ;
Length
дд; A
;
ддA B
i
ддC D
++
ддD F
)
ддF G
{
ее 
overrideRule
жж  
.
жж  !
	m_Sprites
жж! *
[
жж* +
i
жж+ ,
]
жж, -
=
жж. /
	EditorGUI
жж0 9
.
жж9 :
ObjectField
жж: E
(
жжE F
new
жжF I
Rect
жжJ N
(
жжN O
rect
жжO S
.
жжS T
xMin
жжT X
+
жжY Z
k_LabelWidth
жж[ g
,
жжg h
y
жжi j
,
жжj k
rect
жжl p
.
жжp q
width
жжq v
-
жжw x
k_LabelWidthжжy …
,жж… †"
k_SingleLineHeightжж‡ ™
)жж™ љ
,жжљ ›
overrideRuleжжњ Ё
.жжЁ ©
	m_Spritesжж© І
[жжІ і
iжжі ґ
]жжґ µ
,жжµ ¶
typeofжж· Ѕ
(жжЅ ѕ
Spriteжжѕ Д
)жжД Е
,жжЕ Ж
falseжжЗ М
)жжМ Н
asжжО Р
SpriteжжС Ч
;жжЧ Ш
y
зз 
+=
зз  
k_SingleLineHeight
зз +
;
зз+ ,
}
ии 
}
йй 
}
кк 	
private
лл 
void
лл (
DrawOverrideDefaultElement
лл /
(
лл/ 0
Rect
лл0 4
rect
лл5 9
,
лл9 :
RuleTile
лл; C
.
ллC D

TilingRule
ллD N
originalRule
ллO [
)
лл[ \
{
мм 	
float
нн 
yPos
нн 
=
нн 
rect
нн 
.
нн 
yMin
нн "
+
нн# $
$num
нн% '
;
нн' (
float
оо 
height
оо 
=
оо 
rect
оо 
.
оо  
height
оо  &
-
оо' (#
k_PaddingBetweenRules
оо) >
;
оо> ?
float
пп 
matrixWidth
пп 
=
пп $
k_DefaultElementHeight
пп  6
;
пп6 7
Rect
сс 
inspectorRect
сс 
=
сс  
new
сс! $
Rect
сс% )
(
сс) *
rect
сс* .
.
сс. /
xMin
сс/ 3
,
сс3 4
yPos
сс5 9
,
сс9 :
rect
сс; ?
.
сс? @
width
сс@ E
-
ссF G
matrixWidth
ссH S
-
ссT U
$num
ссV Y
,
ссY Z
height
сс[ a
)
ссa b
;
ссb c
Rect
тт 

spriteRect
тт 
=
тт 
new
тт !
Rect
тт" &
(
тт& '
rect
тт' +
.
тт+ ,
xMax
тт, 0
-
тт1 2
matrixWidth
тт3 >
-
тт? @
$num
ттA C
,
ттC D
yPos
ттE I
,
ттI J
matrixWidth
ттK V
,
ттV W$
k_DefaultElementHeight
ттX n
)
ттn o
;
ттo p/
!RuleOverrideDefaultInspectorOnGUI
фф -
(
фф- .
inspectorRect
фф. ;
,
фф; <
originalRule
фф= I
)
ффI J
;
ффJ K
if
хх 
(
хх 
overrideTile
хх 
.
хх 
m_OverrideDefault
хх .
.
хх. /
	m_Enabled
хх/ 8
)
хх8 9
ruleTileEditor
цц 
.
цц 
SpriteOnGUI
цц *
(
цц* +

spriteRect
цц+ 5
,
цц5 6
overrideTile
цц7 C
.
ццC D
m_OverrideDefault
ццD U
.
ццU V
m_TilingRule
ццV b
)
ццb c
;
ццc d
}
чч 	
private
шш 
void
шш /
!RuleOverrideDefaultInspectorOnGUI
шш 6
(
шш6 7
Rect
шш7 ;
rect
шш< @
,
шш@ A
RuleTile
шшB J
.
шшJ K

TilingRule
шшK U
overrideRule
шшV b
)
шшb c
{
щщ 	
float
ъъ 
y
ъъ 
=
ъъ 
rect
ъъ 
.
ъъ 
yMin
ъъ 
;
ъъ  
	EditorGUI
ыы 
.
ыы 
BeginChangeCheck
ыы &
(
ыы& '
)
ыы' (
;
ыы( )
GUI
ээ 
.
ээ 
Label
ээ 
(
ээ 
new
ээ 
Rect
ээ 
(
ээ 
rect
ээ #
.
ээ# $
xMin
ээ$ (
,
ээ( )
y
ээ* +
,
ээ+ ,
k_LabelWidth
ээ- 9
,
ээ9 : 
k_SingleLineHeight
ээ; M
)
ээM N
,
ээN O
$str
ээP Y
)
ээY Z
;
ээZ [
bool
юю 
enabled
юю 
=
юю 
	EditorGUI
юю $
.
юю$ %
Toggle
юю% +
(
юю+ ,
new
юю, /
Rect
юю0 4
(
юю4 5
rect
юю5 9
.
юю9 :
xMin
юю: >
+
юю? @
k_LabelWidth
ююA M
,
ююM N
y
ююO P
,
ююP Q
rect
ююR V
.
ююV W
width
ююW \
-
юю] ^
k_LabelWidth
юю_ k
,
ююk l 
k_SingleLineHeight
ююm 
)юю Ђ
,ююЂ Ѓ
overrideTileюю‚ Ћ
.ююЋ Џ!
m_OverrideDefaultююЏ  
.юю  Ў
	m_EnabledююЎ Є
)ююЄ «
;юю« ¬
y
яя 
+=
яя  
k_SingleLineHeight
яя #
;
яя# $
if
ЃЃ 
(
ЃЃ 
	EditorGUI
ЃЃ 
.
ЃЃ 
EndChangeCheck
ЃЃ (
(
ЃЃ( )
)
ЃЃ) *
)
ЃЃ* +
{
‚‚ 
overrideTile
ѓѓ 
.
ѓѓ 
m_OverrideDefault
ѓѓ .
.
ѓѓ. /
	m_Enabled
ѓѓ/ 8
=
ѓѓ9 :
enabled
ѓѓ; B
;
ѓѓB C
overrideTile
„„ 
.
„„ 
m_OverrideDefault
„„ .
.
„„. /
m_TilingRule
„„/ ;
=
„„< =
overrideTile
„„> J
.
„„J K
m_OriginalDefault
„„K \
;
„„\ ]
}
…… 
if
‡‡ 
(
‡‡ 
!
‡‡ 
enabled
‡‡ 
)
‡‡ 
return
€€ 
;
€€ 
GUI
ЉЉ 
.
ЉЉ 
Label
ЉЉ 
(
ЉЉ 
new
ЉЉ 
Rect
ЉЉ 
(
ЉЉ 
rect
ЉЉ #
.
ЉЉ# $
xMin
ЉЉ$ (
,
ЉЉ( )
y
ЉЉ* +
,
ЉЉ+ ,
k_LabelWidth
ЉЉ- 9
,
ЉЉ9 : 
k_SingleLineHeight
ЉЉ; M
)
ЉЉM N
,
ЉЉN O
$str
ЉЉP Z
)
ЉЉZ [
;
ЉЉ[ \
overrideRule
‹‹ 
.
‹‹ 
m_ColliderType
‹‹ '
=
‹‹( )
(
‹‹* +
Tile
‹‹+ /
.
‹‹/ 0
ColliderType
‹‹0 <
)
‹‹< =
	EditorGUI
‹‹= F
.
‹‹F G
	EnumPopup
‹‹G P
(
‹‹P Q
new
‹‹Q T
Rect
‹‹U Y
(
‹‹Y Z
rect
‹‹Z ^
.
‹‹^ _
xMin
‹‹_ c
+
‹‹d e
k_LabelWidth
‹‹f r
,
‹‹r s
y
‹‹t u
,
‹‹u v
rect
‹‹w {
.
‹‹{ |
width‹‹| Ѓ
-‹‹‚ ѓ
k_LabelWidth‹‹„ ђ
,‹‹ђ ‘"
k_SingleLineHeight‹‹’ ¤
)‹‹¤ Ґ
,‹‹Ґ ¦
overrideRule‹‹§ і
.‹‹і ґ
m_ColliderType‹‹ґ В
)‹‹В Г
;‹‹Г Д
y
ЊЊ 
+=
ЊЊ  
k_SingleLineHeight
ЊЊ #
;
ЊЊ# $
}
ЌЌ 	
private
ЋЋ 
void
ЋЋ 
DrawRuleHeader
ЋЋ #
(
ЋЋ# $
Rect
ЋЋ$ (
rect
ЋЋ) -
)
ЋЋ- .
{
ЏЏ 	
float
ђђ 
matrixWidth
ђђ 
=
ђђ $
k_DefaultElementHeight
ђђ  6
;
ђђ6 7
float
’’ 
xMax
’’ 
=
’’ 
rect
’’ 
.
’’ 
xMax
’’ "
;
’’" #
rect
““ 
.
““ 
xMax
““ 
=
““ 
rect
““ 
.
““ 
xMax
““ !
/
““" #
$num
““$ (
+
““) *
matrixWidth
““+ 6
-
““7 8
$num
““9 <
;
““< =
GUI
”” 
.
”” 
Label
”” 
(
”” 
rect
”” 
,
”” 
$str
”” &
,
””& '
EditorStyles
””( 4
.
””4 5
label
””5 :
)
””: ;
;
””; <
rect
•• 
.
•• 
xMin
•• 
=
•• 
rect
•• 
.
•• 
xMax
•• !
;
••! "
rect
–– 
.
–– 
xMax
–– 
=
–– 
xMax
–– 
;
–– 
GUI
—— 
.
—— 
Label
—— 
(
—— 
rect
—— 
,
—— 
$str
—— &
,
——& '
EditorStyles
——( 4
.
——4 5
label
——5 :
)
——: ;
;
——; <
}
 	
private
™™ 
float
™™ "
GetRuleElementHeight
™™ *
(
™™* +
int
™™+ .
index
™™/ 4
)
™™4 5
{
љљ 	
if
›› 
(
›› 
index
›› 
!=
›› 
overrideTile
›› %
.
››% &
m_Tile
››& ,
.
››, -
m_TilingRules
››- :
.
››: ;
Count
››; @
)
››@ A
{
њњ 
var
ќќ 
overrideRule
ќќ  
=
ќќ! "
overrideTile
ќќ# /
[
ќќ/ 0
overrideTile
ќќ0 <
.
ќќ< =
m_Tile
ќќ= C
.
ќќC D
m_TilingRules
ќќD Q
[
ќќQ R
index
ќќR W
]
ќќW X
]
ќќX Y
;
ќќY Z
float
ћћ 
overrideHeight
ћћ $
=
ћћ% &"
GetRuleElementHeight
ћћ' ;
(
ћћ; <
overrideRule
ћћ< H
)
ћћH I
;
ћћI J
float
џџ 
originalHeight
џџ $
=
џџ% &"
GetRuleElementHeight
џџ' ;
(
џџ; <
overrideTile
џџ< H
.
џџH I
m_Tile
џџI O
.
џџO P
m_TilingRules
џџP ]
[
џџ] ^
index
џџ^ c
]
џџc d
)
џџd e
;
џџe f
return
   
Mathf
   
.
   
Max
    
(
    !
overrideHeight
  ! /
,
  / 0
originalHeight
  1 ?
)
  ? @
;
  @ A
}
ЎЎ 
else
ўў 
{
ЈЈ 
var
¤¤ 
overrideRule
¤¤  
=
¤¤! "
overrideTile
¤¤# /
.
¤¤/ 0
m_OverrideDefault
¤¤0 A
.
¤¤A B
	m_Enabled
¤¤B K
?
¤¤L M
overrideTile
¤¤N Z
.
¤¤Z [
m_OverrideDefault
¤¤[ l
.
¤¤l m
m_TilingRule
¤¤m y
:
¤¤z {
null¤¤| Ђ
;¤¤Ђ Ѓ
float
ҐҐ 
overrideHeight
ҐҐ $
=
ҐҐ% &"
GetRuleElementHeight
ҐҐ' ;
(
ҐҐ; <
overrideRule
ҐҐ< H
)
ҐҐH I
;
ҐҐI J
float
¦¦ 
originalHeight
¦¦ $
=
¦¦% &"
GetRuleElementHeight
¦¦' ;
(
¦¦; <
new
¦¦< ?
RuleTile
¦¦@ H
.
¦¦H I

TilingRule
¦¦I S
(
¦¦S T
)
¦¦T U
)
¦¦U V
;
¦¦V W
return
§§ 
Mathf
§§ 
.
§§ 
Max
§§  
(
§§  !
overrideHeight
§§! /
,
§§/ 0
originalHeight
§§1 ?
)
§§? @
;
§§@ A
}
ЁЁ 
}
©© 	
private
ЄЄ 
float
ЄЄ "
GetRuleElementHeight
ЄЄ *
(
ЄЄ* +
RuleTile
ЄЄ+ 3
.
ЄЄ3 4

TilingRule
ЄЄ4 >
rule
ЄЄ? C
)
ЄЄC D
{
«« 	
float
¬¬ 
height
¬¬ 
=
¬¬ $
k_DefaultElementHeight
¬¬ 1
+
¬¬2 3#
k_PaddingBetweenRules
¬¬4 I
;
¬¬I J
if
­­ 
(
­­ 
rule
­­ 
!=
­­ 
null
­­ 
)
­­ 
{
®® 
switch
ЇЇ 
(
ЇЇ 
rule
ЇЇ 
.
ЇЇ 
m_Output
ЇЇ %
)
ЇЇ% &
{
°° 
case
±± 
RuleTile
±± !
.
±±! "

TilingRule
±±" ,
.
±±, -
OutputSprite
±±- 9
.
±±9 :
Random
±±: @
:
±±@ A
height
ІІ 
=
ІІ  $
k_DefaultElementHeight
ІІ! 7
+
ІІ8 9 
k_SingleLineHeight
ІІ: L
*
ІІM N
(
ІІO P
rule
ІІP T
.
ІІT U
	m_Sprites
ІІU ^
.
ІІ^ _
Length
ІІ_ e
+
ІІf g
$num
ІІh i
)
ІІi j
+
ІІk l$
k_PaddingBetweenRulesІІm ‚
;ІІ‚ ѓ
break
іі 
;
іі 
case
ґґ 
RuleTile
ґґ !
.
ґґ! "

TilingRule
ґґ" ,
.
ґґ, -
OutputSprite
ґґ- 9
.
ґґ9 :
	Animation
ґґ: C
:
ґґC D
height
µµ 
=
µµ  $
k_DefaultElementHeight
µµ! 7
+
µµ8 9 
k_SingleLineHeight
µµ: L
*
µµM N
(
µµO P
rule
µµP T
.
µµT U
	m_Sprites
µµU ^
.
µµ^ _
Length
µµ_ e
+
µµf g
$num
µµh i
)
µµi j
+
µµk l$
k_PaddingBetweenRulesµµm ‚
;µµ‚ ѓ
break
¶¶ 
;
¶¶ 
}
·· 
}
ёё 
return
№№ 
height
№№ 
;
№№ 
}
єє 	
}
»» 
}јј ѕ
ќC:\Users\Davis\Desktop\Facultad\5to Periodo\Tecnologias\Pacman\ClientePacman\Packages\com.unity.2d.tilemap.extras\Editor\Tiles\RuleTile\CustomRuleTileMenu.cs
	namespace 	
UnityEditor
 
{ 
static 

class 
CustomRuleTileMenu #
{ 
[ 	
MenuItem	 
( 
$str 9
,9 :
false; @
,@ A
$numB D
)D E
]E F
static 
void  
CreateCustomRuleTile (
(( )
)) *
{ 	
ProjectWindowUtil 
. -
!CreateScriptAssetFromTemplateFile ?
(? @
$str	@ Ґ
,
Ґ ¦
$str
§ Ѕ
)
Ѕ ѕ
;
ѕ ї
}		 	
}

 
} Ьр
™C:\Users\Davis\Desktop\Facultad\5to Periodo\Tecnologias\Pacman\ClientePacman\Packages\com.unity.2d.tilemap.extras\Editor\Tiles\RuleTile\RuleTileEditor.cs
	namespace

 	
UnityEditor


 
{ 
[ 
CustomEditor 
( 
typeof 
( 
RuleTile !
)! "
," #
true$ (
)( )
]) *
[ "
CanEditMultipleObjects 
] 
public 

class 
RuleTileEditor 
:  !
Editor" (
{ 
private 
const 
string 
s_XIconString *
=+ ,
$str	- ы
;
ы ь
private 
const 
string 
s_Arrow0 %
=& '
$str	( ¶
;
¶ ·
private 
const 
string 
s_Arrow1 %
=& '
$str	( ц
;
ц ч
private 
const 
string 
s_Arrow2 %
=& '
$str	( Ъ
;
Ъ Ы
private 
const 
string 
s_Arrow3 %
=& '
$str	( †
;
† ‡
private 
const 
string 
s_Arrow5 %
=& '
$str	( ц
;
ц ч
private 
const 
string 
s_Arrow6 %
=& '
$str	( ¶
;
¶ ·
private 
const 
string 
s_Arrow7 %
=& '
$str	( Ц
;
Ц Ч
private 
const 
string 
s_Arrow8 %
=& '
$str	( ¶
;
¶ ·
private 
const 
string 
	s_MirrorX &
=' (
$str	) л
;
л м
private 
const 
string 
	s_MirrorY &
=' (
$str	) п
;
п р
private 
const 
string 

s_MirrorXY '
=( )
$str	* а
;
а б
private 
const 
string 
	s_Rotated &
=' (
$str	) ч
;
ч ш
private 
const 
string 
s_Fixed $
=% &
$str	' ќ
;
ќ ћ
private 
static 
	Texture2D  
[  !
]! "
s_Arrows# +
;+ ,
public   
static   
	Texture2D   
[    
]    !
arrows  " (
{!! 	
get"" 
{## 
if$$ 
($$ 
s_Arrows$$ 
==$$ 
null$$  $
)$$$ %
{%% 
s_Arrows&& 
=&& 
new&& "
	Texture2D&&# ,
[&&, -
$num&&- /
]&&/ 0
;&&0 1
s_Arrows'' 
['' 
$num'' 
]'' 
=''  !
Base64ToTexture''" 1
(''1 2
s_Arrow0''2 :
)'': ;
;''; <
s_Arrows(( 
[(( 
$num(( 
](( 
=((  !
Base64ToTexture((" 1
(((1 2
s_Arrow1((2 :
)((: ;
;((; <
s_Arrows)) 
[)) 
$num)) 
])) 
=))  !
Base64ToTexture))" 1
())1 2
s_Arrow2))2 :
))): ;
;)); <
s_Arrows** 
[** 
$num** 
]** 
=**  !
Base64ToTexture**" 1
(**1 2
s_Arrow3**2 :
)**: ;
;**; <
s_Arrows++ 
[++ 
$num++ 
]++ 
=++  !
Base64ToTexture++" 1
(++1 2
s_Arrow5++2 :
)++: ;
;++; <
s_Arrows,, 
[,, 
$num,, 
],, 
=,,  !
Base64ToTexture,," 1
(,,1 2
s_Arrow6,,2 :
),,: ;
;,,; <
s_Arrows-- 
[-- 
$num-- 
]-- 
=--  !
Base64ToTexture--" 1
(--1 2
s_Arrow7--2 :
)--: ;
;--; <
s_Arrows.. 
[.. 
$num.. 
].. 
=..  !
Base64ToTexture.." 1
(..1 2
s_Arrow8..2 :
)..: ;
;..; <
s_Arrows// 
[// 
$num// 
]// 
=//  !
Base64ToTexture//" 1
(//1 2
s_XIconString//2 ?
)//? @
;//@ A
}00 
return11 
s_Arrows11 
;11  
}22 
}33 	
private55 
static55 
	Texture2D55  
[55  !
]55! "
s_AutoTransforms55# 3
;553 4
public66 
static66 
	Texture2D66 
[66  
]66  !
autoTransforms66" 0
{77 	
get88 
{99 
if:: 
(:: 
s_AutoTransforms:: $
==::% '
null::( ,
)::, -
{;; 
s_AutoTransforms<< $
=<<% &
new<<' *
	Texture2D<<+ 4
[<<4 5
$num<<5 6
]<<6 7
;<<7 8
s_AutoTransforms== $
[==$ %
$num==% &
]==& '
===( )
Base64ToTexture==* 9
(==9 :
	s_Rotated==: C
)==C D
;==D E
s_AutoTransforms>> $
[>>$ %
$num>>% &
]>>& '
=>>( )
Base64ToTexture>>* 9
(>>9 :
	s_MirrorX>>: C
)>>C D
;>>D E
s_AutoTransforms?? $
[??$ %
$num??% &
]??& '
=??( )
Base64ToTexture??* 9
(??9 :
	s_MirrorY??: C
)??C D
;??D E
s_AutoTransforms@@ $
[@@$ %
$num@@% &
]@@& '
=@@( )
Base64ToTexture@@* 9
(@@9 :
s_Fixed@@: A
)@@A B
;@@B C
s_AutoTransformsAA $
[AA$ %
$numAA% &
]AA& '
=AA( )
Base64ToTextureAA* 9
(AA9 :

s_MirrorXYAA: D
)AAD E
;AAE F
}BB 
returnCC 
s_AutoTransformsCC '
;CC' (
}DD 
}EE 	
publicGG 
RuleTileGG 
tileGG 
{GG 
getGG "
{GG# $
returnGG% +
(GG, -
targetGG- 3
asGG4 6
RuleTileGG7 ?
)GG? @
;GG@ A
}GGB C
}GGD E
privateHH 
ReorderableListHH 
m_ReorderableListHH  1
;HH1 2
publicII 
boolII 
extendNeighborII "
;II" #
publicKK 
constKK 
floatKK "
k_DefaultElementHeightKK 1
=KK2 3
$numKK4 7
;KK7 8
publicLL 
constLL 
floatLL !
k_PaddingBetweenRulesLL 0
=LL1 2
$numLL3 6
;LL6 7
publicMM 
constMM 
floatMM 
k_SingleLineHeightMM -
=MM. /
$numMM0 3
;MM3 4
publicNN 
constNN 
floatNN 
k_LabelWidthNN '
=NN( )
$numNN* -
;NN- .
publicPP 
voidPP 
OnEnablePP 
(PP 
)PP 
{QQ 	
m_ReorderableListRR 
=RR 
newRR  #
ReorderableListRR$ 3
(RR3 4
tileRR4 8
.RR8 9
m_TilingRulesRR9 F
,RRF G
typeofRRH N
(RRN O
RuleTileRRO W
.RRW X

TilingRuleRRX b
)RRb c
,RRc d
trueRRe i
,RRi j
trueRRk o
,RRo p
trueRRq u
,RRu v
trueRRw {
)RR{ |
;RR| }
m_ReorderableListSS 
.SS 
drawHeaderCallbackSS 0
=SS1 2
OnDrawHeaderSS3 ?
;SS? @
m_ReorderableListTT 
.TT 
drawElementCallbackTT 1
=TT2 3
OnDrawElementTT4 A
;TTA B
m_ReorderableListUU 
.UU !
elementHeightCallbackUU 3
=UU4 5
GetElementHeightUU6 F
;UUF G
m_ReorderableListVV 
.VV 
onChangedCallbackVV /
=VV0 1
ListUpdatedVV2 =
;VV= >
m_ReorderableListWW 
.WW 
onAddCallbackWW +
=WW, -
OnAddElementWW. :
;WW: ;
}XX 	
publicZZ 
virtualZZ 
	BoundsIntZZ  
GetRuleGUIBoundsZZ! 1
(ZZ1 2
	BoundsIntZZ2 ;
boundsZZ< B
,ZZB C
RuleTileZZD L
.ZZL M

TilingRuleZZM W
ruleZZX \
)ZZ\ ]
{[[ 	
if\\ 
(\\ 
extendNeighbor\\ 
)\\ 
{]] 
bounds^^ 
.^^ 
xMin^^ 
--^^ 
;^^ 
bounds__ 
.__ 
yMin__ 
--__ 
;__ 
bounds`` 
.`` 
xMax`` 
++`` 
;`` 
boundsaa 
.aa 
yMaxaa 
++aa 
;aa 
}bb 
boundscc 
.cc 
xMincc 
=cc 
Mathfcc 
.cc  
Mincc  #
(cc# $
boundscc$ *
.cc* +
xMincc+ /
,cc/ 0
-cc1 2
$numcc2 3
)cc3 4
;cc4 5
boundsdd 
.dd 
yMindd 
=dd 
Mathfdd 
.dd  
Mindd  #
(dd# $
boundsdd$ *
.dd* +
yMindd+ /
,dd/ 0
-dd1 2
$numdd2 3
)dd3 4
;dd4 5
boundsee 
.ee 
xMaxee 
=ee 
Mathfee 
.ee  
Maxee  #
(ee# $
boundsee$ *
.ee* +
xMaxee+ /
,ee/ 0
$numee1 2
)ee2 3
;ee3 4
boundsff 
.ff 
yMaxff 
=ff 
Mathfff 
.ff  
Maxff  #
(ff# $
boundsff$ *
.ff* +
yMaxff+ /
,ff/ 0
$numff1 2
)ff2 3
;ff3 4
returngg 
boundsgg 
;gg 
}hh 	
privatejj 
voidjj 
ListUpdatedjj  
(jj  !
ReorderableListjj! 0
listjj1 5
)jj5 6
{kk 	
SaveTilell 
(ll 
)ll 
;ll 
}mm 	
privateoo 
floatoo 
GetElementHeightoo &
(oo& '
intoo' *
indexoo+ 0
)oo0 1
{pp 	
RuleTileqq 
.qq 

TilingRuleqq 
ruleqq  $
=qq% &
tileqq' +
.qq+ ,
m_TilingRulesqq, 9
[qq9 :
indexqq: ?
]qq? @
;qq@ A
	BoundsIntrr 
boundsrr 
=rr 
GetRuleGUIBoundsrr /
(rr/ 0
rulerr0 4
.rr4 5
	GetBoundsrr5 >
(rr> ?
)rr? @
,rr@ A
rulerrB F
)rrF G
;rrG H
floattt 
inspectorHeighttt !
=tt" #"
k_DefaultElementHeighttt$ :
+tt; <!
k_PaddingBetweenRulestt= R
;ttR S
floatuu 
matrixHeightuu 
=uu  
GetMatrixSizeuu! .
(uu. /
boundsuu/ 5
)uu5 6
.uu6 7
yuu7 8
+uu9 :
$numuu; >
;uu> ?
ifww 
(ww 
indexww 
<ww 
tileww 
.ww 
m_TilingRulesww *
.ww* +
Countww+ 0
)ww0 1
{xx 
switchyy 
(yy 
tileyy 
.yy 
m_TilingRulesyy *
[yy* +
indexyy+ 0
]yy0 1
.yy1 2
m_Outputyy2 :
)yy: ;
{zz 
case{{ 
RuleTile{{ !
.{{! "

TilingRule{{" ,
.{{, -
OutputSprite{{- 9
.{{9 :
Random{{: @
:{{@ A
inspectorHeight|| '
=||( )"
k_DefaultElementHeight||* @
+||A B
k_SingleLineHeight||C U
*||V W
(||X Y
tile||Y ]
.||] ^
m_TilingRules||^ k
[||k l
index||l q
]||q r
.||r s
	m_Sprites||s |
.||| }
Length	||} ѓ
+
||„ …
$num
||† ‡
)
||‡ €
+
||‰ Љ#
k_PaddingBetweenRules
||‹  
;
||  Ў
break}} 
;}} 
case~~ 
RuleTile~~ !
.~~! "

TilingRule~~" ,
.~~, -
OutputSprite~~- 9
.~~9 :
	Animation~~: C
:~~C D
inspectorHeight '
=( )"
k_DefaultElementHeight* @
+A B
k_SingleLineHeightC U
*V W
(X Y
tileY ]
.] ^
m_TilingRules^ k
[k l
indexl q
]q r
.r s
	m_Spritess |
.| }
Length	} ѓ
+
„ …
$num
† ‡
)
‡ €
+
‰ Љ#
k_PaddingBetweenRules
‹  
;
  Ў
break
ЂЂ 
;
ЂЂ 
}
ЃЃ 
}
‚‚ 
return
„„ 
Mathf
„„ 
.
„„ 
Max
„„ 
(
„„ 
inspectorHeight
„„ ,
,
„„, -
matrixHeight
„„. :
)
„„: ;
;
„„; <
}
…… 	
public
‡‡ 
virtual
‡‡ 
Vector2
‡‡ 
GetMatrixSize
‡‡ ,
(
‡‡, -
	BoundsInt
‡‡- 6
bounds
‡‡7 =
)
‡‡= >
{
€€ 	
return
‰‰ 
new
‰‰ 
Vector2
‰‰ 
(
‰‰ 
bounds
‰‰ %
.
‰‰% &
size
‰‰& *
.
‰‰* +
x
‰‰+ ,
*
‰‰- . 
k_SingleLineHeight
‰‰/ A
,
‰‰A B
bounds
‰‰C I
.
‰‰I J
size
‰‰J N
.
‰‰N O
y
‰‰O P
*
‰‰Q R 
k_SingleLineHeight
‰‰S e
)
‰‰e f
;
‰‰f g
}
ЉЉ 	
	protected
ЊЊ 
virtual
ЊЊ 
void
ЊЊ 
OnDrawElement
ЊЊ ,
(
ЊЊ, -
Rect
ЊЊ- 1
rect
ЊЊ2 6
,
ЊЊ6 7
int
ЊЊ8 ;
index
ЊЊ< A
,
ЊЊA B
bool
ЊЊC G
isactive
ЊЊH P
,
ЊЊP Q
bool
ЊЊR V
	isfocused
ЊЊW `
)
ЊЊ` a
{
ЌЌ 	
RuleTile
ЋЋ 
.
ЋЋ 

TilingRule
ЋЋ 
rule
ЋЋ  $
=
ЋЋ% &
tile
ЋЋ' +
.
ЋЋ+ ,
m_TilingRules
ЋЋ, 9
[
ЋЋ9 :
index
ЋЋ: ?
]
ЋЋ? @
;
ЋЋ@ A
	BoundsInt
ЏЏ 
bounds
ЏЏ 
=
ЏЏ 
GetRuleGUIBounds
ЏЏ /
(
ЏЏ/ 0
rule
ЏЏ0 4
.
ЏЏ4 5
	GetBounds
ЏЏ5 >
(
ЏЏ> ?
)
ЏЏ? @
,
ЏЏ@ A
rule
ЏЏB F
)
ЏЏF G
;
ЏЏG H
float
‘‘ 
yPos
‘‘ 
=
‘‘ 
rect
‘‘ 
.
‘‘ 
yMin
‘‘ "
+
‘‘# $
$num
‘‘% '
;
‘‘' (
float
’’ 
height
’’ 
=
’’ 
rect
’’ 
.
’’  
height
’’  &
-
’’' (#
k_PaddingBetweenRules
’’) >
;
’’> ?
Vector2
““ 

matrixSize
““ 
=
““  
GetMatrixSize
““! .
(
““. /
bounds
““/ 5
)
““5 6
;
““6 7
Rect
•• 

spriteRect
•• 
=
•• 
new
•• !
Rect
••" &
(
••& '
rect
••' +
.
••+ ,
xMax
••, 0
-
••1 2$
k_DefaultElementHeight
••3 I
-
••J K
$num
••L N
,
••N O
yPos
••P T
,
••T U$
k_DefaultElementHeight
••V l
,
••l m%
k_DefaultElementHeight••n „
)••„ …
;••… †
Rect
–– 

matrixRect
–– 
=
–– 
new
–– !
Rect
––" &
(
––& '
rect
––' +
.
––+ ,
xMax
––, 0
-
––1 2

matrixSize
––3 =
.
––= >
x
––> ?
-
––@ A

spriteRect
––B L
.
––L M
width
––M R
-
––S T
$num
––U X
,
––X Y
yPos
––Z ^
,
––^ _

matrixSize
––` j
.
––j k
x
––k l
,
––l m

matrixSize
––n x
.
––x y
y
––y z
)
––z {
;
––{ |
Rect
—— 
inspectorRect
—— 
=
——  
new
——! $
Rect
——% )
(
——) *
rect
——* .
.
——. /
xMin
——/ 3
,
——3 4
yPos
——5 9
,
——9 :
rect
——; ?
.
——? @
width
——@ E
-
——F G

matrixSize
——H R
.
——R S
x
——S T
-
——U V

spriteRect
——W a
.
——a b
width
——b g
-
——h i
$num
——j m
,
——m n
height
——o u
)
——u v
;
——v w
	EditorGUI
™™ 
.
™™ 
BeginChangeCheck
™™ &
(
™™& '
)
™™' (
;
™™( ) 
RuleInspectorOnGUI
љљ 
(
љљ 
inspectorRect
љљ ,
,
љљ, -
rule
љљ. 2
)
љљ2 3
;
љљ3 4
RuleMatrixOnGUI
›› 
(
›› 
tile
››  
,
››  !

matrixRect
››" ,
,
››, -
bounds
››. 4
,
››4 5
rule
››6 :
)
››: ;
;
››; <
SpriteOnGUI
њњ 
(
њњ 

spriteRect
њњ "
,
њњ" #
rule
њњ$ (
)
њњ( )
;
њњ) *
if
ќќ 
(
ќќ 
	EditorGUI
ќќ 
.
ќќ 
EndChangeCheck
ќќ (
(
ќќ( )
)
ќќ) *
)
ќќ* +
SaveTile
ћћ 
(
ћћ 
)
ћћ 
;
ћћ 
}
џџ 	
private
ЎЎ 
void
ЎЎ 
OnAddElement
ЎЎ !
(
ЎЎ! "
ReorderableList
ЎЎ" 1
list
ЎЎ2 6
)
ЎЎ6 7
{
ўў 	
RuleTile
ЈЈ 
.
ЈЈ 

TilingRule
ЈЈ 
rule
ЈЈ  $
=
ЈЈ% &
new
ЈЈ' *
RuleTile
ЈЈ+ 3
.
ЈЈ3 4

TilingRule
ЈЈ4 >
(
ЈЈ> ?
)
ЈЈ? @
;
ЈЈ@ A
rule
¤¤ 
.
¤¤ 
m_Output
¤¤ 
=
¤¤ 
RuleTile
¤¤ $
.
¤¤$ %

TilingRule
¤¤% /
.
¤¤/ 0
OutputSprite
¤¤0 <
.
¤¤< =
Single
¤¤= C
;
¤¤C D
rule
ҐҐ 
.
ҐҐ 
	m_Sprites
ҐҐ 
[
ҐҐ 
$num
ҐҐ 
]
ҐҐ 
=
ҐҐ 
tile
ҐҐ  $
.
ҐҐ$ %
m_DefaultSprite
ҐҐ% 4
;
ҐҐ4 5
rule
¦¦ 
.
¦¦ 
m_GameObject
¦¦ 
=
¦¦ 
tile
¦¦  $
.
¦¦$ %!
m_DefaultGameObject
¦¦% 8
;
¦¦8 9
rule
§§ 
.
§§ 
m_ColliderType
§§ 
=
§§  !
tile
§§" &
.
§§& '#
m_DefaultColliderType
§§' <
;
§§< =
tile
ЁЁ 
.
ЁЁ 
m_TilingRules
ЁЁ 
.
ЁЁ 
Add
ЁЁ "
(
ЁЁ" #
rule
ЁЁ# '
)
ЁЁ' (
;
ЁЁ( )
}
©© 	
public
«« 
void
«« 
SaveTile
«« 
(
«« 
)
«« 
{
¬¬ 	
EditorUtility
­­ 
.
­­ 
SetDirty
­­ "
(
­­" #
target
­­# )
)
­­) *
;
­­* +
	SceneView
®® 
.
®® 

RepaintAll
®®  
(
®®  !
)
®®! "
;
®®" #!
UpdateOverrideTiles
°° 
(
°°  
)
°°  !
;
°°! "
}
±± 	
private
іі 
void
іі !
UpdateOverrideTiles
іі (
(
іі( )
)
іі) *
{
ґґ 	
string
µµ 
[
µµ 
]
µµ 
overrideTileGuids
µµ &
=
µµ' (
AssetDatabase
µµ) 6
.
µµ6 7

FindAssets
µµ7 A
(
µµA B
$str
µµB V
)
µµV W
;
µµW X
foreach
¶¶ 
(
¶¶ 
string
¶¶ 
overrideTileGuid
¶¶ ,
in
¶¶- /
overrideTileGuids
¶¶0 A
)
¶¶A B
{
·· 
string
ёё 
overrideTilePath
ёё '
=
ёё( )
AssetDatabase
ёё* 7
.
ёё7 8
GUIDToAssetPath
ёё8 G
(
ёёG H
overrideTileGuid
ёёH X
)
ёёX Y
;
ёёY Z
RuleOverrideTile
№№  
overrideTile
№№! -
=
№№. /
AssetDatabase
№№0 =
.
№№= >
LoadAssetAtPath
№№> M
<
№№M N
RuleOverrideTile
№№N ^
>
№№^ _
(
№№_ `
overrideTilePath
№№` p
)
№№p q
;
№№q r
if
єє 
(
єє 
overrideTile
єє  
.
єє  !
m_Tile
єє! '
==
єє( *
target
єє+ 1
)
єє1 2
overrideTile
»»  
.
»»  !
Override
»»! )
(
»») *
)
»»* +
;
»»+ ,
}
јј 
}
ЅЅ 	
private
її 
void
її 
OnDrawHeader
її !
(
її! "
Rect
її" &
rect
її' +
)
її+ ,
{
АА 	
GUI
ББ 
.
ББ 
Label
ББ 
(
ББ 
rect
ББ 
,
ББ 
$str
ББ *
)
ББ* +
;
ББ+ ,
Rect
ГГ 

toggleRect
ГГ 
=
ГГ 
new
ГГ !
Rect
ГГ" &
(
ГГ& '
rect
ГГ' +
.
ГГ+ ,
xMax
ГГ, 0
-
ГГ1 2
rect
ГГ3 7
.
ГГ7 8
height
ГГ8 >
,
ГГ> ?
rect
ГГ@ D
.
ГГD E
y
ГГE F
,
ГГF G
rect
ГГH L
.
ГГL M
height
ГГM S
,
ГГS T
rect
ГГU Y
.
ГГY Z
height
ГГZ `
)
ГГ` a
;
ГГa b
Rect
ДД 
toggleLabelRect
ДД  
=
ДД! "
new
ДД# &
Rect
ДД' +
(
ДД+ ,
rect
ДД, 0
.
ДД0 1
x
ДД1 2
,
ДД2 3
rect
ДД4 8
.
ДД8 9
y
ДД9 :
,
ДД: ;
rect
ДД< @
.
ДД@ A
width
ДДA F
-
ДДG H

toggleRect
ДДI S
.
ДДS T
width
ДДT Y
-
ДДZ [
$num
ДД\ ^
,
ДД^ _
rect
ДД` d
.
ДДd e
height
ДДe k
)
ДДk l
;
ДДl m
extendNeighbor
ЖЖ 
=
ЖЖ 
	EditorGUI
ЖЖ &
.
ЖЖ& '
Toggle
ЖЖ' -
(
ЖЖ- .

toggleRect
ЖЖ. 8
,
ЖЖ8 9
extendNeighbor
ЖЖ: H
)
ЖЖH I
;
ЖЖI J
	EditorGUI
ЗЗ 
.
ЗЗ 

LabelField
ЗЗ  
(
ЗЗ  !
toggleLabelRect
ЗЗ! 0
,
ЗЗ0 1
$str
ЗЗ2 C
,
ЗЗC D
new
ЗЗE H
GUIStyle
ЗЗI Q
(
ЗЗQ R
)
ЗЗR S
{
ИИ 
	alignment
ЙЙ 
=
ЙЙ 

TextAnchor
ЙЙ &
.
ЙЙ& '
MiddleRight
ЙЙ' 2
,
ЙЙ2 3
	fontStyle
КК 
=
КК 
	FontStyle
КК %
.
КК% &
Bold
КК& *
,
КК* +
fontSize
ЛЛ 
=
ЛЛ 
$num
ЛЛ 
,
ЛЛ 
}
ММ 
)
ММ 
;
ММ 
}
НН 	
public
ПП 
override
ПП 
void
ПП 
OnInspectorGUI
ПП +
(
ПП+ ,
)
ПП, -
{
РР 	
	EditorGUI
СС 
.
СС 
BeginChangeCheck
СС &
(
СС& '
)
СС' (
;
СС( )
tile
ТТ 
.
ТТ 
m_DefaultSprite
ТТ  
=
ТТ! "
EditorGUILayout
ТТ# 2
.
ТТ2 3
ObjectField
ТТ3 >
(
ТТ> ?
$str
ТТ? O
,
ТТO P
tile
ТТQ U
.
ТТU V
m_DefaultSprite
ТТV e
,
ТТe f
typeof
ТТg m
(
ТТm n
Sprite
ТТn t
)
ТТt u
,
ТТu v
false
ТТw |
)
ТТ| }
asТТ~ Ђ
SpriteТТЃ ‡
;ТТ‡ €
tile
УУ 
.
УУ !
m_DefaultGameObject
УУ $
=
УУ% &
EditorGUILayout
УУ' 6
.
УУ6 7
ObjectField
УУ7 B
(
УУB C
$str
УУC X
,
УУX Y
tile
УУZ ^
.
УУ^ _!
m_DefaultGameObject
УУ_ r
,
УУr s
typeof
УУt z
(
УУz {

GameObjectУУ{ …
)УУ… †
,УУ† ‡
falseУУ€ Ќ
)УУЌ Ћ
asУУЏ ‘

GameObjectУУ’ њ
;УУњ ќ
tile
ФФ 
.
ФФ #
m_DefaultColliderType
ФФ &
=
ФФ' (
(
ФФ) *
Tile
ФФ* .
.
ФФ. /
ColliderType
ФФ/ ;
)
ФФ; <
EditorGUILayout
ФФ< K
.
ФФK L
	EnumPopup
ФФL U
(
ФФU V
$str
ФФV h
,
ФФh i
tile
ФФj n
.
ФФn o$
m_DefaultColliderTypeФФo „
)ФФ„ …
;ФФ… †
if
ХХ 
(
ХХ 
	EditorGUI
ХХ 
.
ХХ 
EndChangeCheck
ХХ (
(
ХХ( )
)
ХХ) *
)
ХХ* +
EditorUtility
ЦЦ 
.
ЦЦ 
SetDirty
ЦЦ &
(
ЦЦ& '
tile
ЦЦ' +
)
ЦЦ+ ,
;
ЦЦ, -
serializedObject
ШШ 
.
ШШ 
Update
ШШ #
(
ШШ# $
)
ШШ$ %
;
ШШ% &
	EditorGUI
ЩЩ 
.
ЩЩ 
BeginChangeCheck
ЩЩ &
(
ЩЩ& '
)
ЩЩ' (
;
ЩЩ( )
DrawCustomFields
ЪЪ 
(
ЪЪ 
tile
ЪЪ !
,
ЪЪ! "
serializedObject
ЪЪ# 3
)
ЪЪ3 4
;
ЪЪ4 5
if
ЫЫ 
(
ЫЫ 
	EditorGUI
ЫЫ 
.
ЫЫ 
EndChangeCheck
ЫЫ (
(
ЫЫ( )
)
ЫЫ) *
)
ЫЫ* +
serializedObject
ЬЬ  
.
ЬЬ  !%
ApplyModifiedProperties
ЬЬ! 8
(
ЬЬ8 9
)
ЬЬ9 :
;
ЬЬ: ;
EditorGUILayout
ЮЮ 
.
ЮЮ 
Space
ЮЮ !
(
ЮЮ! "
)
ЮЮ" #
;
ЮЮ# $
if
аа 
(
аа 
m_ReorderableList
аа !
!=
аа" $
null
аа% )
)
аа) *
m_ReorderableList
бб !
.
бб! "
DoLayoutList
бб" .
(
бб. /
)
бб/ 0
;
бб0 1
}
вв 	
public
дд 
static
дд 
void
дд 
DrawCustomFields
дд +
(
дд+ ,
Object
дд, 2
tile
дд3 7
,
дд7 8
SerializedObject
дд9 I
serializedObject
ддJ Z
)
ддZ [
{
ее 	
var
жж 
customFields
жж 
=
жж 
tile
жж #
.
жж# $
GetType
жж$ +
(
жж+ ,
)
жж, -
.
жж- .
	GetFields
жж. 7
(
жж7 8
)
жж8 9
.
зз 
Where
зз 
(
зз 
field
зз 
=>
зз 
typeof
зз  &
(
зз& '
RuleTile
зз' /
)
зз/ 0
.
зз0 1
GetField
зз1 9
(
зз9 :
field
зз: ?
.
зз? @
Name
зз@ D
)
ззD E
==
ззF H
null
ззI M
)
ззM N
.
ии 
Where
ии 
(
ии 
field
ии 
=>
ии 
!
ии  !
field
ии! &
.
ии& '
IsStatic
ии' /
)
ии/ 0
.
йй 
Where
йй 
(
йй 
field
йй 
=>
йй 
field
йй  %
.
йй% &
	FieldType
йй& /
.
йй/ 0
IsSerializable
йй0 >
)
йй> ?
;
йй? @
foreach
кк 
(
кк 
var
кк 
field
кк 
in
кк !
customFields
кк" .
)
кк. /
EditorGUILayout
лл 
.
лл  
PropertyField
лл  -
(
лл- .
serializedObject
лл. >
.
лл> ?
FindProperty
лл? K
(
ллK L
field
ллL Q
.
ллQ R
Name
ллR V
)
ллV W
,
ллW X
true
ллY ]
)
лл] ^
;
лл^ _
}
мм 	
public
оо 
virtual
оо 
int
оо 
GetArrowIndex
оо (
(
оо( )

Vector3Int
оо) 3
position
оо4 <
)
оо< =
{
пп 	
if
рр 
(
рр 
Mathf
рр 
.
рр 
Abs
рр 
(
рр 
position
рр "
.
рр" #
x
рр# $
)
рр$ %
==
рр& (
Mathf
рр) .
.
рр. /
Abs
рр/ 2
(
рр2 3
position
рр3 ;
.
рр; <
y
рр< =
)
рр= >
)
рр> ?
{
сс 
if
тт 
(
тт 
position
тт 
.
тт 
x
тт 
<
тт  
$num
тт! "
&&
тт# %
position
тт& .
.
тт. /
y
тт/ 0
>
тт1 2
$num
тт3 4
)
тт4 5
return
уу 
$num
уу 
;
уу 
else
фф 
if
фф 
(
фф 
position
фф !
.
фф! "
x
фф" #
>
фф$ %
$num
фф& '
&&
фф( *
position
фф+ 3
.
фф3 4
y
фф4 5
>
фф6 7
$num
фф8 9
)
фф9 :
return
хх 
$num
хх 
;
хх 
else
цц 
if
цц 
(
цц 
position
цц !
.
цц! "
x
цц" #
<
цц$ %
$num
цц& '
&&
цц( *
position
цц+ 3
.
цц3 4
y
цц4 5
<
цц6 7
$num
цц8 9
)
цц9 :
return
чч 
$num
чч 
;
чч 
else
шш 
if
шш 
(
шш 
position
шш !
.
шш! "
x
шш" #
>
шш$ %
$num
шш& '
&&
шш( *
position
шш+ 3
.
шш3 4
y
шш4 5
<
шш6 7
$num
шш8 9
)
шш9 :
return
щщ 
$num
щщ 
;
щщ 
}
ъъ 
else
ыы 
if
ыы 
(
ыы 
Mathf
ыы 
.
ыы 
Abs
ыы 
(
ыы 
position
ыы '
.
ыы' (
x
ыы( )
)
ыы) *
>
ыы+ ,
Mathf
ыы- 2
.
ыы2 3
Abs
ыы3 6
(
ыы6 7
position
ыы7 ?
.
ыы? @
y
ыы@ A
)
ыыA B
)
ыыB C
{
ьь 
if
ээ 
(
ээ 
position
ээ 
.
ээ 
x
ээ 
>
ээ  
$num
ээ! "
)
ээ" #
return
юю 
$num
юю 
;
юю 
else
яя 
return
ЂЂ 
$num
ЂЂ 
;
ЂЂ 
}
ЃЃ 
else
‚‚ 
{
ѓѓ 
if
„„ 
(
„„ 
position
„„ 
.
„„ 
y
„„ 
>
„„  
$num
„„! "
)
„„" #
return
…… 
$num
…… 
;
…… 
else
†† 
return
‡‡ 
$num
‡‡ 
;
‡‡ 
}
€€ 
return
‰‰ 
-
‰‰ 
$num
‰‰ 
;
‰‰ 
}
ЉЉ 	
public
ЊЊ 
virtual
ЊЊ 
void
ЊЊ 
	RuleOnGUI
ЊЊ %
(
ЊЊ% &
Rect
ЊЊ& *
rect
ЊЊ+ /
,
ЊЊ/ 0

Vector3Int
ЊЊ1 ;
position
ЊЊ< D
,
ЊЊD E
int
ЊЊF I
neighbor
ЊЊJ R
)
ЊЊR S
{
ЌЌ 	
switch
ЋЋ 
(
ЋЋ 
neighbor
ЋЋ 
)
ЋЋ 
{
ЏЏ 
case
ђђ 
RuleTile
ђђ 
.
ђђ 

TilingRule
ђђ (
.
ђђ( )
Neighbor
ђђ) 1
.
ђђ1 2
This
ђђ2 6
:
ђђ6 7
GUI
‘‘ 
.
‘‘ 
DrawTexture
‘‘ #
(
‘‘# $
rect
‘‘$ (
,
‘‘( )
arrows
‘‘* 0
[
‘‘0 1
GetArrowIndex
‘‘1 >
(
‘‘> ?
position
‘‘? G
)
‘‘G H
]
‘‘H I
)
‘‘I J
;
‘‘J K
break
’’ 
;
’’ 
case
““ 
RuleTile
““ 
.
““ 

TilingRule
““ (
.
““( )
Neighbor
““) 1
.
““1 2
NotThis
““2 9
:
““9 :
GUI
”” 
.
”” 
DrawTexture
”” #
(
””# $
rect
””$ (
,
””( )
arrows
””* 0
[
””0 1
$num
””1 2
]
””2 3
)
””3 4
;
””4 5
break
•• 
;
•• 
default
–– 
:
–– 
var
—— 
style
—— 
=
—— 
new
——  #
GUIStyle
——$ ,
(
——, -
)
——- .
;
——. /
style
 
.
 
	alignment
 #
=
$ %

TextAnchor
& 0
.
0 1
MiddleCenter
1 =
;
= >
style
™™ 
.
™™ 
fontSize
™™ "
=
™™# $
$num
™™% '
;
™™' (
GUI
љљ 
.
љљ 
Label
љљ 
(
љљ 
rect
љљ "
,
љљ" #
neighbor
љљ$ ,
.
љљ, -
ToString
љљ- 5
(
љљ5 6
)
љљ6 7
,
љљ7 8
style
љљ9 >
)
љљ> ?
;
љљ? @
break
›› 
;
›› 
}
њњ 
}
ќќ 	
public
џџ 
void
џџ 
RuleTooltipOnGUI
џџ $
(
џџ$ %
Rect
џџ% )
rect
џџ* .
,
џџ. /
int
џџ0 3
neighbor
џџ4 <
)
џџ< =
{
   	
var
ЎЎ 
	allConsts
ЎЎ 
=
ЎЎ 
tile
ЎЎ  
.
ЎЎ  !
m_NeighborType
ЎЎ! /
.
ЎЎ/ 0
	GetFields
ЎЎ0 9
(
ЎЎ9 :
System
ЎЎ: @
.
ЎЎ@ A

Reflection
ЎЎA K
.
ЎЎK L
BindingFlags
ЎЎL X
.
ЎЎX Y
Public
ЎЎY _
|
ЎЎ` a
System
ЎЎb h
.
ЎЎh i

Reflection
ЎЎi s
.
ЎЎs t
BindingFlagsЎЎt Ђ
.ЎЎЂ Ѓ
StaticЎЎЃ ‡
|ЎЎ€ ‰
SystemЎЎЉ ђ
.ЎЎђ ‘

ReflectionЎЎ‘ ›
.ЎЎ› њ
BindingFlagsЎЎњ Ё
.ЎЎЁ © 
FlattenHierarchyЎЎ© №
)ЎЎ№ є
;ЎЎє »
foreach
ўў 
(
ўў 
var
ўў 
c
ўў 
in
ўў 
	allConsts
ўў '
)
ўў' (
{
ЈЈ 
if
¤¤ 
(
¤¤ 
(
¤¤ 
int
¤¤ 
)
¤¤ 
c
¤¤ 
.
¤¤ 
GetValue
¤¤ #
(
¤¤# $
null
¤¤$ (
)
¤¤( )
==
¤¤* ,
neighbor
¤¤- 5
)
¤¤5 6
{
ҐҐ 
GUI
¦¦ 
.
¦¦ 
Label
¦¦ 
(
¦¦ 
rect
¦¦ "
,
¦¦" #
new
¦¦$ '

GUIContent
¦¦( 2
(
¦¦2 3
$str
¦¦3 5
,
¦¦5 6
c
¦¦7 8
.
¦¦8 9
Name
¦¦9 =
)
¦¦= >
)
¦¦> ?
;
¦¦? @
break
§§ 
;
§§ 
}
ЁЁ 
}
©© 
}
ЄЄ 	
public
¬¬ 
virtual
¬¬ 
void
¬¬  
RuleTransformOnGUI
¬¬ .
(
¬¬. /
Rect
¬¬/ 3
rect
¬¬4 8
,
¬¬8 9
RuleTile
¬¬: B
.
¬¬B C

TilingRule
¬¬C M
.
¬¬M N
	Transform
¬¬N W
ruleTransform
¬¬X e
)
¬¬e f
{
­­ 	
switch
®® 
(
®® 
ruleTransform
®® !
)
®®! "
{
ЇЇ 
case
°° 
RuleTile
°° 
.
°° 

TilingRule
°° (
.
°°( )
	Transform
°°) 2
.
°°2 3
Rotated
°°3 :
:
°°: ;
GUI
±± 
.
±± 
DrawTexture
±± #
(
±±# $
rect
±±$ (
,
±±( )
autoTransforms
±±* 8
[
±±8 9
$num
±±9 :
]
±±: ;
)
±±; <
;
±±< =
break
ІІ 
;
ІІ 
case
іі 
RuleTile
іі 
.
іі 

TilingRule
іі (
.
іі( )
	Transform
іі) 2
.
іі2 3
MirrorX
іі3 :
:
іі: ;
GUI
ґґ 
.
ґґ 
DrawTexture
ґґ #
(
ґґ# $
rect
ґґ$ (
,
ґґ( )
autoTransforms
ґґ* 8
[
ґґ8 9
$num
ґґ9 :
]
ґґ: ;
)
ґґ; <
;
ґґ< =
break
µµ 
;
µµ 
case
¶¶ 
RuleTile
¶¶ 
.
¶¶ 

TilingRule
¶¶ (
.
¶¶( )
	Transform
¶¶) 2
.
¶¶2 3
MirrorY
¶¶3 :
:
¶¶: ;
GUI
·· 
.
·· 
DrawTexture
·· #
(
··# $
rect
··$ (
,
··( )
autoTransforms
··* 8
[
··8 9
$num
··9 :
]
··: ;
)
··; <
;
··< =
break
ёё 
;
ёё 
case
№№ 
RuleTile
№№ 
.
№№ 

TilingRule
№№ (
.
№№( )
	Transform
№№) 2
.
№№2 3
Fixed
№№3 8
:
№№8 9
GUI
єє 
.
єє 
DrawTexture
єє #
(
єє# $
rect
єє$ (
,
єє( )
autoTransforms
єє* 8
[
єє8 9
$num
єє9 :
]
єє: ;
)
єє; <
;
єє< =
break
»» 
;
»» 
case
јј 
RuleTile
јј 
.
јј 

TilingRule
јј (
.
јј( )
	Transform
јј) 2
.
јј2 3
MirrorXY
јј3 ;
:
јј; <
GUI
ЅЅ 
.
ЅЅ 
DrawTexture
ЅЅ #
(
ЅЅ# $
rect
ЅЅ$ (
,
ЅЅ( )
autoTransforms
ЅЅ* 8
[
ЅЅ8 9
$num
ЅЅ9 :
]
ЅЅ: ;
)
ЅЅ; <
;
ЅЅ< =
break
ѕѕ 
;
ѕѕ 
}
її 
}
АА 	
public
ВВ 
bool
ВВ  
RuleNeighborUpdate
ВВ &
(
ВВ& '
Rect
ВВ' +
rect
ВВ, 0
,
ВВ0 1
RuleTile
ВВ2 :
.
ВВ: ;

TilingRule
ВВ; E

tilingRule
ВВF P
,
ВВP Q

Dictionary
ВВR \
<
ВВ\ ]

Vector3Int
ВВ] g
,
ВВg h
int
ВВi l
>
ВВl m
	neighbors
ВВn w
,ГГ 

Vector3Int
ГГ 
position
ГГ 
)
ГГ 
{
ДД 	
if
ЕЕ 
(
ЕЕ 
Event
ЕЕ 
.
ЕЕ 
current
ЕЕ 
.
ЕЕ 
type
ЕЕ "
==
ЕЕ# %
	EventType
ЕЕ& /
.
ЕЕ/ 0
	MouseDown
ЕЕ0 9
&&
ЕЕ: <#
ContainsMousePosition
ЕЕ= R
(
ЕЕR S
rect
ЕЕS W
)
ЕЕW X
)
ЕЕX Y
{
ЖЖ 
var
ЗЗ 
	allConsts
ЗЗ 
=
ЗЗ 
tile
ЗЗ  $
.
ЗЗ$ %
m_NeighborType
ЗЗ% 3
.
ЗЗ3 4
	GetFields
ЗЗ4 =
(
ЗЗ= >
BindingFlags
ЗЗ> J
.
ЗЗJ K
Public
ЗЗK Q
|
ЗЗR S
BindingFlags
ЗЗT `
.
ЗЗ` a
Static
ЗЗa g
|
ЗЗh i
BindingFlags
ЗЗj v
.
ЗЗv w
FlattenHierarchyЗЗw ‡
)ЗЗ‡ €
;ЗЗ€ ‰
var
ИИ 
neighborConsts
ИИ "
=
ИИ# $
	allConsts
ИИ% .
.
ИИ. /
Select
ИИ/ 5
(
ИИ5 6
c
ИИ6 7
=>
ИИ8 :
(
ИИ; <
int
ИИ< ?
)
ИИ? @
c
ИИ@ A
.
ИИA B
GetValue
ИИB J
(
ИИJ K
null
ИИK O
)
ИИO P
)
ИИP Q
.
ИИQ R
ToList
ИИR X
(
ИИX Y
)
ИИY Z
;
ИИZ [
neighborConsts
ЙЙ 
.
ЙЙ 
Sort
ЙЙ #
(
ЙЙ# $
)
ЙЙ$ %
;
ЙЙ% &
if
ЛЛ 
(
ЛЛ 
	neighbors
ЛЛ 
.
ЛЛ 
ContainsKey
ЛЛ )
(
ЛЛ) *
position
ЛЛ* 2
)
ЛЛ2 3
)
ЛЛ3 4
{
ММ 
int
НН 
oldIndex
НН  
=
НН! "
neighborConsts
НН# 1
.
НН1 2
IndexOf
НН2 9
(
НН9 :
	neighbors
НН: C
[
ННC D
position
ННD L
]
ННL M
)
ННM N
;
ННN O
int
ОО 
newIndex
ОО  
=
ОО! "
oldIndex
ОО# +
+
ОО, -
GetMouseChange
ОО. <
(
ОО< =
)
ОО= >
;
ОО> ?
if
ПП 
(
ПП 
newIndex
ПП  
>=
ПП! #
$num
ПП$ %
&&
ПП& (
newIndex
ПП) 1
<
ПП2 3
neighborConsts
ПП4 B
.
ППB C
Count
ППC H
)
ППH I
{
РР 
newIndex
СС  
=
СС! "
(
СС# $
int
СС$ '
)
СС' (
Mathf
СС( -
.
СС- .
Repeat
СС. 4
(
СС4 5
newIndex
СС5 =
,
СС= >
neighborConsts
СС? M
.
ССM N
Count
ССN S
)
ССS T
;
ССT U
	neighbors
ТТ !
[
ТТ! "
position
ТТ" *
]
ТТ* +
=
ТТ, -
neighborConsts
ТТ. <
[
ТТ< =
newIndex
ТТ= E
]
ТТE F
;
ТТF G
}
УУ 
else
ФФ 
{
ХХ 
	neighbors
ЦЦ !
.
ЦЦ! "
Remove
ЦЦ" (
(
ЦЦ( )
position
ЦЦ) 1
)
ЦЦ1 2
;
ЦЦ2 3
}
ЧЧ 
}
ШШ 
else
ЩЩ 
{
ЪЪ 
int
ЫЫ 
mouseChange
ЫЫ #
=
ЫЫ$ %
GetMouseChange
ЫЫ& 4
(
ЫЫ4 5
)
ЫЫ5 6
;
ЫЫ6 7
if
ЬЬ 
(
ЬЬ 
mouseChange
ЬЬ #
==
ЬЬ$ &
$num
ЬЬ' (
)
ЬЬ( )
{
ЭЭ 
	neighbors
ЮЮ !
.
ЮЮ! "
Add
ЮЮ" %
(
ЮЮ% &
position
ЮЮ& .
,
ЮЮ. /
neighborConsts
ЮЮ0 >
[
ЮЮ> ?
$num
ЮЮ? @
]
ЮЮ@ A
)
ЮЮA B
;
ЮЮB C
}
ЯЯ 
else
аа 
{
бб 
	neighbors
вв !
.
вв! "
Add
вв" %
(
вв% &
position
вв& .
,
вв. /
neighborConsts
вв0 >
[
вв> ?
neighborConsts
вв? M
.
ввM N
Count
ввN S
-
ввT U
$num
ввV W
]
ввW X
)
ввX Y
;
ввY Z
}
гг 
}
дд 

tilingRule
ее 
.
ее 
ApplyNeighbors
ее )
(
ее) *
	neighbors
ее* 3
)
ее3 4
;
ее4 5
GUI
зз 
.
зз 
changed
зз 
=
зз 
true
зз "
;
зз" #
Event
ии 
.
ии 
current
ии 
.
ии 
Use
ии !
(
ии! "
)
ии" #
;
ии# $
return
кк 
true
кк 
;
кк 
}
лл 
return
нн 
false
нн 
;
нн 
}
оо 	
public
рр 
bool
рр !
RuleTransformUpdate
рр '
(
рр' (
Rect
рр( ,
rect
рр- 1
,
рр1 2
RuleTile
рр3 ;
.
рр; <

TilingRule
рр< F

tilingRule
ррG Q
)
ррQ R
{
сс 	
if
тт 
(
тт 
Event
тт 
.
тт 
current
тт 
.
тт 
type
тт "
==
тт# %
	EventType
тт& /
.
тт/ 0
	MouseDown
тт0 9
&&
тт: <#
ContainsMousePosition
тт= R
(
ттR S
rect
ттS W
)
ттW X
)
ттX Y
{
уу 

tilingRule
фф 
.
фф 
m_RuleTransform
фф *
=
фф+ ,
(
фф- .
RuleTile
фф. 6
.
фф6 7

TilingRule
фф7 A
.
ффA B
	Transform
ффB K
)
ффK L
(
ффL M
int
ффM P
)
ффP Q
Mathf
ффQ V
.
ффV W
Repeat
ффW ]
(
фф] ^
(
фф^ _
int
фф_ b
)
ффb c

tilingRule
ффc m
.
ффm n
m_RuleTransform
ффn }
+
фф~ 
GetMouseChangeффЂ Ћ
(ффЋ Џ
)ффЏ ђ
,ффђ ‘
Enumфф’ –
.фф– —
	GetValuesфф—  
(фф  Ў
typeofффЎ §
(фф§ Ё
RuleTileффЁ °
.фф° ±

TilingRuleфф± »
.фф» ј
	Transformффј Е
)ффЕ Ж
)ффЖ З
.ффЗ И
LengthффИ О
)ффО П
;ффП Р
GUI
хх 
.
хх 
changed
хх 
=
хх 
true
хх "
;
хх" #
Event
цц 
.
цц 
current
цц 
.
цц 
Use
цц !
(
цц! "
)
цц" #
;
цц# $
return
шш 
true
шш 
;
шш 
}
щщ 
return
ыы 
false
ыы 
;
ыы 
}
ьь 	
public
юю 
virtual
юю 
bool
юю #
ContainsMousePosition
юю 1
(
юю1 2
Rect
юю2 6
rect
юю7 ;
)
юю; <
{
яя 	
return
ЂЂ 
rect
ЂЂ 
.
ЂЂ 
Contains
ЂЂ  
(
ЂЂ  !
Event
ЂЂ! &
.
ЂЂ& '
current
ЂЂ' .
.
ЂЂ. /
mousePosition
ЂЂ/ <
)
ЂЂ< =
;
ЂЂ= >
}
ЃЃ 	
private
ѓѓ 
static
ѓѓ 
int
ѓѓ 
GetMouseChange
ѓѓ )
(
ѓѓ) *
)
ѓѓ* +
{
„„ 	
return
…… 
Event
…… 
.
…… 
current
……  
.
……  !
button
……! '
==
……( *
$num
……+ ,
?
……- .
-
……/ 0
$num
……0 1
:
……2 3
$num
……4 5
;
……5 6
}
†† 	
public
€€ 
virtual
€€ 
void
€€ 
RuleMatrixOnGUI
€€ +
(
€€+ ,
RuleTile
€€, 4
tile
€€5 9
,
€€9 :
Rect
€€; ?
rect
€€@ D
,
€€D E
	BoundsInt
€€F O
bounds
€€P V
,
€€V W
RuleTile
€€X `
.
€€` a

TilingRule
€€a k

tilingRule
€€l v
)
€€v w
{
‰‰ 	
Handles
ЉЉ 
.
ЉЉ 
color
ЉЉ 
=
ЉЉ 
EditorGUIUtility
ЉЉ ,
.
ЉЉ, -
	isProSkin
ЉЉ- 6
?
ЉЉ7 8
new
ЉЉ9 <
Color
ЉЉ= B
(
ЉЉB C
$num
ЉЉC E
,
ЉЉE F
$num
ЉЉG I
,
ЉЉI J
$num
ЉЉK M
,
ЉЉM N
$num
ЉЉO S
)
ЉЉS T
:
ЉЉU V
new
ЉЉW Z
Color
ЉЉ[ `
(
ЉЉ` a
$num
ЉЉa c
,
ЉЉc d
$num
ЉЉe g
,
ЉЉg h
$num
ЉЉi k
,
ЉЉk l
$num
ЉЉm q
)
ЉЉq r
;
ЉЉr s
float
‹‹ 
w
‹‹ 
=
‹‹ 
rect
‹‹ 
.
‹‹ 
width
‹‹  
/
‹‹! "
bounds
‹‹# )
.
‹‹) *
size
‹‹* .
.
‹‹. /
x
‹‹/ 0
;
‹‹0 1
float
ЊЊ 
h
ЊЊ 
=
ЊЊ 
rect
ЊЊ 
.
ЊЊ 
height
ЊЊ !
/
ЊЊ" #
bounds
ЊЊ$ *
.
ЊЊ* +
size
ЊЊ+ /
.
ЊЊ/ 0
y
ЊЊ0 1
;
ЊЊ1 2
for
ЋЋ 
(
ЋЋ 
int
ЋЋ 
y
ЋЋ 
=
ЋЋ 
$num
ЋЋ 
;
ЋЋ 
y
ЋЋ 
<=
ЋЋ  
bounds
ЋЋ! '
.
ЋЋ' (
size
ЋЋ( ,
.
ЋЋ, -
y
ЋЋ- .
;
ЋЋ. /
y
ЋЋ0 1
++
ЋЋ1 3
)
ЋЋ3 4
{
ЏЏ 
float
ђђ 
top
ђђ 
=
ђђ 
rect
ђђ  
.
ђђ  !
yMin
ђђ! %
+
ђђ& '
y
ђђ( )
*
ђђ* +
h
ђђ, -
;
ђђ- .
Handles
‘‘ 
.
‘‘ 
DrawLine
‘‘  
(
‘‘  !
new
‘‘! $
Vector3
‘‘% ,
(
‘‘, -
rect
‘‘- 1
.
‘‘1 2
xMin
‘‘2 6
,
‘‘6 7
top
‘‘8 ;
)
‘‘; <
,
‘‘< =
new
‘‘> A
Vector3
‘‘B I
(
‘‘I J
rect
‘‘J N
.
‘‘N O
xMax
‘‘O S
,
‘‘S T
top
‘‘U X
)
‘‘X Y
)
‘‘Y Z
;
‘‘Z [
}
’’ 
for
““ 
(
““ 
int
““ 
x
““ 
=
““ 
$num
““ 
;
““ 
x
““ 
<=
““  
bounds
““! '
.
““' (
size
““( ,
.
““, -
x
““- .
;
““. /
x
““0 1
++
““1 3
)
““3 4
{
”” 
float
•• 
left
•• 
=
•• 
rect
•• !
.
••! "
xMin
••" &
+
••' (
x
••) *
*
••+ ,
w
••- .
;
••. /
Handles
–– 
.
–– 
DrawLine
––  
(
––  !
new
––! $
Vector3
––% ,
(
––, -
left
––- 1
,
––1 2
rect
––3 7
.
––7 8
yMin
––8 <
)
––< =
,
––= >
new
––? B
Vector3
––C J
(
––J K
left
––K O
,
––O P
rect
––Q U
.
––U V
yMax
––V Z
)
––Z [
)
––[ \
;
––\ ]
}
—— 
Handles
 
.
 
color
 
=
 
Color
 !
.
! "
white
" '
;
' (
var
љљ 
	neighbors
љљ 
=
љљ 

tilingRule
љљ &
.
љљ& '
GetNeighbors
љљ' 3
(
љљ3 4
)
љљ4 5
;
љљ5 6
for
њњ 
(
њњ 
int
њњ 
y
њњ 
=
њњ 
bounds
њњ 
.
њњ  
yMin
њњ  $
;
њњ$ %
y
њњ& '
<
њњ( )
bounds
њњ* 0
.
њњ0 1
yMax
њњ1 5
;
њњ5 6
y
њњ7 8
++
њњ8 :
)
њњ: ;
{
ќќ 
for
ћћ 
(
ћћ 
int
ћћ 
x
ћћ 
=
ћћ 
bounds
ћћ #
.
ћћ# $
xMin
ћћ$ (
;
ћћ( )
x
ћћ* +
<
ћћ, -
bounds
ћћ. 4
.
ћћ4 5
xMax
ћћ5 9
;
ћћ9 :
x
ћћ; <
++
ћћ< >
)
ћћ> ?
{
џџ 

Vector3Int
   
pos
   "
=
  # $
new
  % (

Vector3Int
  ) 3
(
  3 4
x
  4 5
,
  5 6
y
  7 8
,
  8 9
$num
  : ;
)
  ; <
;
  < =
Rect
ЎЎ 
r
ЎЎ 
=
ЎЎ 
new
ЎЎ  
Rect
ЎЎ! %
(
ЎЎ% &
rect
ЎЎ& *
.
ЎЎ* +
xMin
ЎЎ+ /
+
ЎЎ0 1
(
ЎЎ2 3
x
ЎЎ3 4
-
ЎЎ5 6
bounds
ЎЎ7 =
.
ЎЎ= >
xMin
ЎЎ> B
)
ЎЎB C
*
ЎЎD E
w
ЎЎF G
,
ЎЎG H
rect
ЎЎI M
.
ЎЎM N
yMin
ЎЎN R
+
ЎЎS T
(
ЎЎU V
-
ЎЎV W
y
ЎЎW X
+
ЎЎY Z
bounds
ЎЎ[ a
.
ЎЎa b
yMax
ЎЎb f
-
ЎЎg h
$num
ЎЎi j
)
ЎЎj k
*
ЎЎl m
h
ЎЎn o
,
ЎЎo p
w
ЎЎq r
-
ЎЎs t
$num
ЎЎu v
,
ЎЎv w
h
ЎЎx y
-
ЎЎz {
$num
ЎЎ| }
)
ЎЎ} ~
;
ЎЎ~ 
if
ўў 
(
ўў 
x
ўў 
!=
ўў 
$num
ўў 
||
ўў !
y
ўў" #
!=
ўў$ &
$num
ўў' (
)
ўў( )
{
ЈЈ 
if
¤¤ 
(
¤¤ 
	neighbors
¤¤ %
.
¤¤% &
ContainsKey
¤¤& 1
(
¤¤1 2
pos
¤¤2 5
)
¤¤5 6
)
¤¤6 7
{
ҐҐ 
	RuleOnGUI
¦¦ %
(
¦¦% &
r
¦¦& '
,
¦¦' (
pos
¦¦) ,
,
¦¦, -
	neighbors
¦¦. 7
[
¦¦7 8
pos
¦¦8 ;
]
¦¦; <
)
¦¦< =
;
¦¦= >
RuleTooltipOnGUI
§§ ,
(
§§, -
r
§§- .
,
§§. /
	neighbors
§§0 9
[
§§9 :
pos
§§: =
]
§§= >
)
§§> ?
;
§§? @
}
ЁЁ 
if
©© 
(
©©  
RuleNeighborUpdate
©© .
(
©©. /
r
©©/ 0
,
©©0 1

tilingRule
©©2 <
,
©©< =
	neighbors
©©> G
,
©©G H
pos
©©I L
)
©©L M
)
©©M N
{
ЄЄ 
tile
««  
.
««  !%
UpdateNeighborPositions
««! 8
(
««8 9
)
««9 :
;
««: ;
}
¬¬ 
}
­­ 
else
®® 
{
ЇЇ  
RuleTransformOnGUI
°° *
(
°°* +
r
°°+ ,
,
°°, -

tilingRule
°°. 8
.
°°8 9
m_RuleTransform
°°9 H
)
°°H I
;
°°I J
if
±± 
(
±± !
RuleTransformUpdate
±± /
(
±±/ 0
r
±±0 1
,
±±1 2

tilingRule
±±3 =
)
±±= >
)
±±> ?
{
ІІ 
tile
іі  
.
іі  !%
UpdateNeighborPositions
іі! 8
(
іі8 9
)
іі9 :
;
іі: ;
}
ґґ 
}
µµ 
}
¶¶ 
}
·· 
}
ёё 	
public
єє 
virtual
єє 
void
єє 
SpriteOnGUI
єє '
(
єє' (
Rect
єє( ,
rect
єє- 1
,
єє1 2
RuleTile
єє3 ;
.
єє; <

TilingRule
єє< F

tilingRule
єєG Q
)
єєQ R
{
»» 	

tilingRule
јј 
.
јј 
	m_Sprites
јј  
[
јј  !
$num
јј! "
]
јј" #
=
јј$ %
	EditorGUI
јј& /
.
јј/ 0
ObjectField
јј0 ;
(
јј; <
new
јј< ?
Rect
јј@ D
(
јјD E
rect
јјE I
.
јјI J
xMax
јјJ N
-
јјO P
rect
јјQ U
.
јјU V
height
јјV \
,
јј\ ]
rect
јј^ b
.
јјb c
yMin
јјc g
,
јјg h
rect
јјi m
.
јјm n
height
јјn t
,
јјt u
rect
јјv z
.
јјz {
heightјј{ Ѓ
)јјЃ ‚
,јј‚ ѓ

tilingRuleјј„ Ћ
.јјЋ Џ
	m_SpritesјјЏ 
[јј ™
$numјј™ љ
]јјљ ›
,јј› њ
typeofјјќ Ј
(јјЈ ¤
Spriteјј¤ Є
)јјЄ «
,јј« ¬
falseјј­ І
)јјІ і
asјјґ ¶
Spriteјј· Ѕ
;јјЅ ѕ
}
ЅЅ 	
public
її 
virtual
її 
void
її  
RuleInspectorOnGUI
її .
(
її. /
Rect
її/ 3
rect
її4 8
,
її8 9
RuleTile
її: B
.
їїB C

TilingRule
їїC M

tilingRule
їїN X
)
їїX Y
{
АА 	
float
ББ 
y
ББ 
=
ББ 
rect
ББ 
.
ББ 
yMin
ББ 
;
ББ  
	EditorGUI
ВВ 
.
ВВ 
BeginChangeCheck
ВВ &
(
ВВ& '
)
ВВ' (
;
ВВ( )
GUI
ГГ 
.
ГГ 
Label
ГГ 
(
ГГ 
new
ГГ 
Rect
ГГ 
(
ГГ 
rect
ГГ #
.
ГГ# $
xMin
ГГ$ (
,
ГГ( )
y
ГГ* +
,
ГГ+ ,
k_LabelWidth
ГГ- 9
,
ГГ9 : 
k_SingleLineHeight
ГГ; M
)
ГГM N
,
ГГN O
$str
ГГP V
)
ГГV W
;
ГГW X

tilingRule
ДД 
.
ДД 
m_RuleTransform
ДД &
=
ДД' (
(
ДД) *
RuleTile
ДД* 2
.
ДД2 3

TilingRule
ДД3 =
.
ДД= >
	Transform
ДД> G
)
ДДG H
	EditorGUI
ДДH Q
.
ДДQ R
	EnumPopup
ДДR [
(
ДД[ \
new
ДД\ _
Rect
ДД` d
(
ДДd e
rect
ДДe i
.
ДДi j
xMin
ДДj n
+
ДДo p
k_LabelWidth
ДДq }
,
ДД} ~
yДД Ђ
,ДДЂ Ѓ
rectДД‚ †
.ДД† ‡
widthДД‡ Њ
-ДДЌ Ћ
k_LabelWidthДДЏ ›
,ДД› њ"
k_SingleLineHeightДДќ Ї
)ДДЇ °
,ДД° ±

tilingRuleДДІ ј
.ДДј Ѕ
m_RuleTransformДДЅ М
)ДДМ Н
;ДДН О
y
ЕЕ 
+=
ЕЕ  
k_SingleLineHeight
ЕЕ #
;
ЕЕ# $
GUI
ЖЖ 
.
ЖЖ 
Label
ЖЖ 
(
ЖЖ 
new
ЖЖ 
Rect
ЖЖ 
(
ЖЖ 
rect
ЖЖ #
.
ЖЖ# $
xMin
ЖЖ$ (
,
ЖЖ( )
y
ЖЖ* +
,
ЖЖ+ ,
k_LabelWidth
ЖЖ- 9
,
ЖЖ9 : 
k_SingleLineHeight
ЖЖ; M
)
ЖЖM N
,
ЖЖN O
$str
ЖЖP ]
)
ЖЖ] ^
;
ЖЖ^ _

tilingRule
ЗЗ 
.
ЗЗ 
m_GameObject
ЗЗ #
=
ЗЗ$ %
(
ЗЗ& '

GameObject
ЗЗ' 1
)
ЗЗ1 2
	EditorGUI
ЗЗ2 ;
.
ЗЗ; <
ObjectField
ЗЗ< G
(
ЗЗG H
new
ЗЗH K
Rect
ЗЗL P
(
ЗЗP Q
rect
ЗЗQ U
.
ЗЗU V
xMin
ЗЗV Z
+
ЗЗ[ \
k_LabelWidth
ЗЗ] i
,
ЗЗi j
y
ЗЗk l
,
ЗЗl m
rect
ЗЗn r
.
ЗЗr s
width
ЗЗs x
-
ЗЗy z
k_LabelWidthЗЗ{ ‡
,ЗЗ‡ €"
k_SingleLineHeightЗЗ‰ ›
)ЗЗ› њ
,ЗЗњ ќ
$strЗЗћ  
,ЗЗ  Ў

tilingRuleЗЗў ¬
.ЗЗ¬ ­
m_GameObjectЗЗ­ №
,ЗЗ№ є
typeofЗЗ» Б
(ЗЗБ В

GameObjectЗЗВ М
)ЗЗМ Н
,ЗЗН О
falseЗЗП Ф
)ЗЗФ Х
;ЗЗХ Ц
y
ИИ 
+=
ИИ  
k_SingleLineHeight
ИИ #
;
ИИ# $
GUI
ЙЙ 
.
ЙЙ 
Label
ЙЙ 
(
ЙЙ 
new
ЙЙ 
Rect
ЙЙ 
(
ЙЙ 
rect
ЙЙ #
.
ЙЙ# $
xMin
ЙЙ$ (
,
ЙЙ( )
y
ЙЙ* +
,
ЙЙ+ ,
k_LabelWidth
ЙЙ- 9
,
ЙЙ9 : 
k_SingleLineHeight
ЙЙ; M
)
ЙЙM N
,
ЙЙN O
$str
ЙЙP Z
)
ЙЙZ [
;
ЙЙ[ \

tilingRule
КК 
.
КК 
m_ColliderType
КК %
=
КК& '
(
КК( )
Tile
КК) -
.
КК- .
ColliderType
КК. :
)
КК: ;
	EditorGUI
КК; D
.
ККD E
	EnumPopup
ККE N
(
ККN O
new
ККO R
Rect
ККS W
(
ККW X
rect
ККX \
.
КК\ ]
xMin
КК] a
+
ККb c
k_LabelWidth
ККd p
,
ККp q
y
ККr s
,
ККs t
rect
ККu y
.
ККy z
width
ККz 
-ККЂ Ѓ
k_LabelWidthКК‚ Ћ
,ККЋ Џ"
k_SingleLineHeightККђ ў
)ККў Ј
,ККЈ ¤

tilingRuleККҐ Ї
.ККЇ °
m_ColliderTypeКК° ѕ
)ККѕ ї
;ККї А
y
ЛЛ 
+=
ЛЛ  
k_SingleLineHeight
ЛЛ #
;
ЛЛ# $
GUI
ММ 
.
ММ 
Label
ММ 
(
ММ 
new
ММ 
Rect
ММ 
(
ММ 
rect
ММ #
.
ММ# $
xMin
ММ$ (
,
ММ( )
y
ММ* +
,
ММ+ ,
k_LabelWidth
ММ- 9
,
ММ9 : 
k_SingleLineHeight
ММ; M
)
ММM N
,
ММN O
$str
ММP X
)
ММX Y
;
ММY Z

tilingRule
НН 
.
НН 
m_Output
НН 
=
НН  !
(
НН" #
RuleTile
НН# +
.
НН+ ,

TilingRule
НН, 6
.
НН6 7
OutputSprite
НН7 C
)
ННC D
	EditorGUI
ННD M
.
ННM N
	EnumPopup
ННN W
(
ННW X
new
ННX [
Rect
НН\ `
(
НН` a
rect
ННa e
.
ННe f
xMin
ННf j
+
ННk l
k_LabelWidth
ННm y
,
ННy z
y
НН{ |
,
НН| }
rectНН~ ‚
.НН‚ ѓ
widthННѓ €
-НН‰ Љ
k_LabelWidthНН‹ —
,НН— "
k_SingleLineHeightНН™ «
)НН« ¬
,НН¬ ­

tilingRuleНН® ё
.ННё №
m_OutputНН№ Б
)ННБ В
;ННВ Г
y
ОО 
+=
ОО  
k_SingleLineHeight
ОО #
;
ОО# $
if
РР 
(
РР 

tilingRule
РР 
.
РР 
m_Output
РР #
==
РР$ &
RuleTile
РР' /
.
РР/ 0

TilingRule
РР0 :
.
РР: ;
OutputSprite
РР; G
.
РРG H
	Animation
РРH Q
)
РРQ R
{
СС 
GUI
ТТ 
.
ТТ 
Label
ТТ 
(
ТТ 
new
ТТ 
Rect
ТТ "
(
ТТ" #
rect
ТТ# '
.
ТТ' (
xMin
ТТ( ,
,
ТТ, -
y
ТТ. /
,
ТТ/ 0
k_LabelWidth
ТТ1 =
,
ТТ= > 
k_SingleLineHeight
ТТ? Q
)
ТТQ R
,
ТТR S
$str
ТТT [
)
ТТ[ \
;
ТТ\ ]

tilingRule
УУ 
.
УУ 
m_AnimationSpeed
УУ +
=
УУ, -
	EditorGUI
УУ. 7
.
УУ7 8

FloatField
УУ8 B
(
УУB C
new
УУC F
Rect
УУG K
(
УУK L
rect
УУL P
.
УУP Q
xMin
УУQ U
+
УУV W
k_LabelWidth
УУX d
,
УУd e
y
УУf g
,
УУg h
rect
УУi m
.
УУm n
width
УУn s
-
УУt u
k_LabelWidthУУv ‚
,УУ‚ ѓ"
k_SingleLineHeightУУ„ –
)УУ– —
,УУ— 

tilingRuleУУ™ Ј
.УУЈ ¤ 
m_AnimationSpeedУУ¤ ґ
)УУґ µ
;УУµ ¶
y
ФФ 
+=
ФФ  
k_SingleLineHeight
ФФ '
;
ФФ' (
}
ХХ 
if
ЦЦ 
(
ЦЦ 

tilingRule
ЦЦ 
.
ЦЦ 
m_Output
ЦЦ #
==
ЦЦ$ &
RuleTile
ЦЦ' /
.
ЦЦ/ 0

TilingRule
ЦЦ0 :
.
ЦЦ: ;
OutputSprite
ЦЦ; G
.
ЦЦG H
Random
ЦЦH N
)
ЦЦN O
{
ЧЧ 
GUI
ШШ 
.
ШШ 
Label
ШШ 
(
ШШ 
new
ШШ 
Rect
ШШ "
(
ШШ" #
rect
ШШ# '
.
ШШ' (
xMin
ШШ( ,
,
ШШ, -
y
ШШ. /
,
ШШ/ 0
k_LabelWidth
ШШ1 =
,
ШШ= > 
k_SingleLineHeight
ШШ? Q
)
ШШQ R
,
ШШR S
$str
ШШT [
)
ШШ[ \
;
ШШ\ ]

tilingRule
ЩЩ 
.
ЩЩ 
m_PerlinScale
ЩЩ (
=
ЩЩ) *
	EditorGUI
ЩЩ+ 4
.
ЩЩ4 5
Slider
ЩЩ5 ;
(
ЩЩ; <
new
ЩЩ< ?
Rect
ЩЩ@ D
(
ЩЩD E
rect
ЩЩE I
.
ЩЩI J
xMin
ЩЩJ N
+
ЩЩO P
k_LabelWidth
ЩЩQ ]
,
ЩЩ] ^
y
ЩЩ_ `
,
ЩЩ` a
rect
ЩЩb f
.
ЩЩf g
width
ЩЩg l
-
ЩЩm n
k_LabelWidth
ЩЩo {
,
ЩЩ{ |!
k_SingleLineHeightЩЩ} Џ
)ЩЩЏ ђ
,ЩЩђ ‘

tilingRuleЩЩ’ њ
.ЩЩњ ќ
m_PerlinScaleЩЩќ Є
,ЩЩЄ «
$numЩЩ¬ І
,ЩЩІ і
$numЩЩґ є
)ЩЩє »
;ЩЩ» ј
y
ЪЪ 
+=
ЪЪ  
k_SingleLineHeight
ЪЪ '
;
ЪЪ' (
GUI
ЬЬ 
.
ЬЬ 
Label
ЬЬ 
(
ЬЬ 
new
ЬЬ 
Rect
ЬЬ "
(
ЬЬ" #
rect
ЬЬ# '
.
ЬЬ' (
xMin
ЬЬ( ,
,
ЬЬ, -
y
ЬЬ. /
,
ЬЬ/ 0
k_LabelWidth
ЬЬ1 =
,
ЬЬ= > 
k_SingleLineHeight
ЬЬ? Q
)
ЬЬQ R
,
ЬЬR S
$str
ЬЬT ]
)
ЬЬ] ^
;
ЬЬ^ _

tilingRule
ЭЭ 
.
ЭЭ 
m_RandomTransform
ЭЭ ,
=
ЭЭ- .
(
ЭЭ/ 0
RuleTile
ЭЭ0 8
.
ЭЭ8 9

TilingRule
ЭЭ9 C
.
ЭЭC D
	Transform
ЭЭD M
)
ЭЭM N
	EditorGUI
ЭЭN W
.
ЭЭW X
	EnumPopup
ЭЭX a
(
ЭЭa b
new
ЭЭb e
Rect
ЭЭf j
(
ЭЭj k
rect
ЭЭk o
.
ЭЭo p
xMin
ЭЭp t
+
ЭЭu v
k_LabelWidthЭЭw ѓ
,ЭЭѓ „
yЭЭ… †
,ЭЭ† ‡
rectЭЭ€ Њ
.ЭЭЊ Ќ
widthЭЭЌ ’
-ЭЭ“ ”
k_LabelWidthЭЭ• Ў
,ЭЭЎ ў"
k_SingleLineHeightЭЭЈ µ
)ЭЭµ ¶
,ЭЭ¶ ·

tilingRuleЭЭё В
.ЭЭВ Г!
m_RandomTransformЭЭГ Ф
)ЭЭФ Х
;ЭЭХ Ц
y
ЮЮ 
+=
ЮЮ  
k_SingleLineHeight
ЮЮ '
;
ЮЮ' (
}
ЯЯ 
if
бб 
(
бб 

tilingRule
бб 
.
бб 
m_Output
бб #
!=
бб$ &
RuleTile
бб' /
.
бб/ 0

TilingRule
бб0 :
.
бб: ;
OutputSprite
бб; G
.
ббG H
Single
ббH N
)
ббN O
{
вв 
GUI
гг 
.
гг 
Label
гг 
(
гг 
new
гг 
Rect
гг "
(
гг" #
rect
гг# '
.
гг' (
xMin
гг( ,
,
гг, -
y
гг. /
,
гг/ 0
k_LabelWidth
гг1 =
,
гг= > 
k_SingleLineHeight
гг? Q
)
ггQ R
,
ггR S
$str
ггT Z
)
ггZ [
;
гг[ \
	EditorGUI
дд 
.
дд 
BeginChangeCheck
дд *
(
дд* +
)
дд+ ,
;
дд, -
int
ее 
	newLength
ее 
=
ее 
	EditorGUI
ее  )
.
ее) *
DelayedIntField
ее* 9
(
ее9 :
new
ее: =
Rect
ее> B
(
ееB C
rect
ееC G
.
ееG H
xMin
ееH L
+
ееM N
k_LabelWidth
ееO [
,
ее[ \
y
ее] ^
,
ее^ _
rect
ее` d
.
ееd e
width
ееe j
-
ееk l
k_LabelWidth
ееm y
,
ееy z!
k_SingleLineHeightее{ Ќ
)ееЌ Ћ
,ееЋ Џ

tilingRuleееђ љ
.еељ ›
	m_Spritesее› ¤
.ее¤ Ґ
LengthееҐ «
)ее« ¬
;ее¬ ­
if
жж 
(
жж 
	EditorGUI
жж 
.
жж 
EndChangeCheck
жж ,
(
жж, -
)
жж- .
)
жж. /
Array
зз 
.
зз 
Resize
зз  
(
зз  !
ref
зз! $

tilingRule
зз% /
.
зз/ 0
	m_Sprites
зз0 9
,
зз9 :
Math
зз; ?
.
зз? @
Max
зз@ C
(
ззC D
	newLength
ззD M
,
ззM N
$num
ззO P
)
ззP Q
)
ззQ R
;
ззR S
y
ии 
+=
ии  
k_SingleLineHeight
ии '
;
ии' (
for
кк 
(
кк 
int
кк 
i
кк 
=
кк 
$num
кк 
;
кк 
i
кк  !
<
кк" #

tilingRule
кк$ .
.
кк. /
	m_Sprites
кк/ 8
.
кк8 9
Length
кк9 ?
;
кк? @
i
ккA B
++
ккB D
)
ккD E
{
лл 

tilingRule
мм 
.
мм 
	m_Sprites
мм (
[
мм( )
i
мм) *
]
мм* +
=
мм, -
	EditorGUI
мм. 7
.
мм7 8
ObjectField
мм8 C
(
ммC D
new
ммD G
Rect
ммH L
(
ммL M
rect
ммM Q
.
ммQ R
xMin
ммR V
+
ммW X
k_LabelWidth
ммY e
,
ммe f
y
ммg h
,
ммh i
rect
ммj n
.
ммn o
width
ммo t
-
ммu v
k_LabelWidthммw ѓ
,ммѓ „"
k_SingleLineHeightмм… —
)мм— 
,мм ™

tilingRuleммљ ¤
.мм¤ Ґ
	m_SpritesммҐ ®
[мм® Ї
iммЇ °
]мм° ±
,мм± І
typeofммі №
(мм№ є
Spriteммє А
)ммА Б
,ммБ В
falseммГ И
)ммИ Й
asммК М
SpriteммН У
;ммУ Ф
y
нн 
+=
нн  
k_SingleLineHeight
нн +
;
нн+ ,
}
оо 
}
пп 
}
рр 	
public
тт 
override
тт 
	Texture2D
тт !!
RenderStaticPreview
тт" 5
(
тт5 6
string
тт6 <
	assetPath
тт= F
,
ттF G
Object
ттH N
[
ттN O
]
ттO P
	subAssets
ттQ Z
,
ттZ [
int
тт\ _
width
тт` e
,
ттe f
int
ттg j
height
ттk q
)
ттq r
{
уу 	
if
фф 
(
фф 
tile
фф 
.
фф 
m_DefaultSprite
фф $
!=
фф% '
null
фф( ,
)
фф, -
{
хх 
Type
цц 
t
цц 
=
цц 
GetType
цц  
(
цц  !
$str
цц! <
)
цц< =
;
цц= >
if
чч 
(
чч 
t
чч 
!=
чч 
null
чч 
)
чч 
{
шш 

MethodInfo
щщ 
method
щщ %
=
щщ& '
t
щщ( )
.
щщ) *
	GetMethod
щщ* 3
(
щщ3 4
$str
щщ4 I
,
щщI J
new
щщK N
Type
щщO S
[
щщS T
]
щщT U
{
щщV W
typeof
щщX ^
(
щщ^ _
Sprite
щщ_ e
)
щщe f
,
щщf g
typeof
щщh n
(
щщn o
Color
щщo t
)
щщt u
,
щщu v
typeof
щщw }
(
щщ} ~
intщщ~ Ѓ
)щщЃ ‚
,щщ‚ ѓ
typeofщщ„ Љ
(щщЉ ‹
intщщ‹ Ћ
)щщЋ Џ
}щщђ ‘
)щщ‘ ’
;щщ’ “
if
ъъ 
(
ъъ 
method
ъъ 
!=
ъъ !
null
ъъ" &
)
ъъ& '
{
ыы 
object
ьь 
ret
ьь "
=
ьь# $
method
ьь% +
.
ьь+ ,
Invoke
ьь, 2
(
ьь2 3
$str
ьь3 H
,
ььH I
new
ььJ M
object
ььN T
[
ььT U
]
ььU V
{
ььW X
tile
ььY ]
.
ьь] ^
m_DefaultSprite
ьь^ m
,
ььm n
Color
ььo t
.
ььt u
white
ььu z
,
ььz {
widthьь| Ѓ
,ььЃ ‚
heightььѓ ‰
}ььЉ ‹
)ьь‹ Њ
;ььЊ Ќ
if
ээ 
(
ээ 
ret
ээ 
is
ээ  "
	Texture2D
ээ# ,
)
ээ, -
return
юю "
ret
юю# &
as
юю' )
	Texture2D
юю* 3
;
юю3 4
}
яя 
}
ЂЂ 
}
ЃЃ 
return
‚‚ 
base
‚‚ 
.
‚‚ !
RenderStaticPreview
‚‚ +
(
‚‚+ ,
	assetPath
‚‚, 5
,
‚‚5 6
	subAssets
‚‚7 @
,
‚‚@ A
width
‚‚B G
,
‚‚G H
height
‚‚I O
)
‚‚O P
;
‚‚P Q
}
ѓѓ 	
private
…… 
static
…… 
Type
…… 
GetType
…… #
(
……# $
string
……$ *
TypeName
……+ 3
)
……3 4
{
†† 	
var
‡‡ 
type
‡‡ 
=
‡‡ 
Type
‡‡ 
.
‡‡ 
GetType
‡‡ #
(
‡‡# $
TypeName
‡‡$ ,
)
‡‡, -
;
‡‡- .
if
€€ 
(
€€ 
type
€€ 
!=
€€ 
null
€€ 
)
€€ 
return
‰‰ 
type
‰‰ 
;
‰‰ 
if
‹‹ 
(
‹‹ 
TypeName
‹‹ 
.
‹‹ 
Contains
‹‹ !
(
‹‹! "
$str
‹‹" %
)
‹‹% &
)
‹‹& '
{
ЊЊ 
var
ЌЌ 
assemblyName
ЌЌ  
=
ЌЌ! "
TypeName
ЌЌ# +
.
ЌЌ+ ,
	Substring
ЌЌ, 5
(
ЌЌ5 6
$num
ЌЌ6 7
,
ЌЌ7 8
TypeName
ЌЌ9 A
.
ЌЌA B
IndexOf
ЌЌB I
(
ЌЌI J
$char
ЌЌJ M
)
ЌЌM N
)
ЌЌN O
;
ЌЌO P
var
ЋЋ 
assembly
ЋЋ 
=
ЋЋ 
Assembly
ЋЋ '
.
ЋЋ' (
Load
ЋЋ( ,
(
ЋЋ, -
assemblyName
ЋЋ- 9
)
ЋЋ9 :
;
ЋЋ: ;
if
ЏЏ 
(
ЏЏ 
assembly
ЏЏ 
==
ЏЏ 
null
ЏЏ  $
)
ЏЏ$ %
return
ђђ 
null
ђђ 
;
ђђ  
type
‘‘ 
=
‘‘ 
assembly
‘‘ 
.
‘‘  
GetType
‘‘  '
(
‘‘' (
TypeName
‘‘( 0
)
‘‘0 1
;
‘‘1 2
if
’’ 
(
’’ 
type
’’ 
!=
’’ 
null
’’  
)
’’  !
return
““ 
type
““ 
;
““  
}
”” 
var
–– 
currentAssembly
–– 
=
––  !
Assembly
––" *
.
––* +"
GetExecutingAssembly
––+ ?
(
––? @
)
––@ A
;
––A B
var
—— "
referencedAssemblies
—— $
=
——% &
currentAssembly
——' 6
.
——6 7%
GetReferencedAssemblies
——7 N
(
——N O
)
——O P
;
——P Q
foreach
 
(
 
var
 
assemblyName
 %
in
& ("
referencedAssemblies
) =
)
= >
{
™™ 
var
љљ 
assembly
љљ 
=
љљ 
Assembly
љљ '
.
љљ' (
Load
љљ( ,
(
љљ, -
assemblyName
љљ- 9
)
љљ9 :
;
љљ: ;
if
›› 
(
›› 
assembly
›› 
!=
›› 
null
››  $
)
››$ %
{
њњ 
type
ќќ 
=
ќќ 
assembly
ќќ #
.
ќќ# $
GetType
ќќ$ +
(
ќќ+ ,
TypeName
ќќ, 4
)
ќќ4 5
;
ќќ5 6
if
ћћ 
(
ћћ 
type
ћћ 
!=
ћћ 
null
ћћ  $
)
ћћ$ %
return
џџ 
type
џџ #
;
џџ# $
}
   
}
ЎЎ 
return
ўў 
null
ўў 
;
ўў 
}
ЈЈ 	
private
ҐҐ 
static
ҐҐ 
	Texture2D
ҐҐ  
Base64ToTexture
ҐҐ! 0
(
ҐҐ0 1
string
ҐҐ1 7
base64
ҐҐ8 >
)
ҐҐ> ?
{
¦¦ 	
	Texture2D
§§ 
t
§§ 
=
§§ 
new
§§ 
	Texture2D
§§ '
(
§§' (
$num
§§( )
,
§§) *
$num
§§+ ,
)
§§, -
;
§§- .
t
ЁЁ 
.
ЁЁ 
	hideFlags
ЁЁ 
=
ЁЁ 
	HideFlags
ЁЁ #
.
ЁЁ# $
HideAndDontSave
ЁЁ$ 3
;
ЁЁ3 4
t
©© 
.
©© 
	LoadImage
©© 
(
©© 
System
©© 
.
©© 
Convert
©© &
.
©©& '
FromBase64String
©©' 7
(
©©7 8
base64
©©8 >
)
©©> ?
)
©©? @
;
©©@ A
return
ЄЄ 
t
ЄЄ 
;
ЄЄ 
}
«« 	
[
­­ 	
Serializable
­­	 
]
­­ 
class
®® !
RuleTileRuleWrapper
®® !
{
ЇЇ 	
[
°° 
SerializeField
°° 
]
°° 
public
±± 
List
±± 
<
±± 
RuleTile
±±  
.
±±  !

TilingRule
±±! +
>
±±+ ,
rules
±±- 2
=
±±3 4
new
±±5 8
List
±±9 =
<
±±= >
RuleTile
±±> F
.
±±F G

TilingRule
±±G Q
>
±±Q R
(
±±R S
)
±±S T
;
±±T U
}
ІІ 	
[
ґґ 	
MenuItem
ґґ	 
(
ґґ 
$str
ґґ 3
)
ґґ3 4
]
ґґ4 5
private
µµ 
static
µµ 
void
µµ 
CopyAllRules
µµ (
(
µµ( )
MenuCommand
µµ) 4
item
µµ5 9
)
µµ9 :
{
¶¶ 	
RuleTile
·· 
tile
·· 
=
·· 
item
··  
.
··  !
context
··! (
as
··) +
RuleTile
··, 4
;
··4 5
if
ёё 
(
ёё 
tile
ёё 
==
ёё 
null
ёё 
)
ёё 
return
№№ 
;
№№ !
RuleTileRuleWrapper
»» 
rulesWrapper
»»  ,
=
»»- .
new
»»/ 2!
RuleTileRuleWrapper
»»3 F
(
»»F G
)
»»G H
;
»»H I
rulesWrapper
јј 
.
јј 
rules
јј 
=
јј  
tile
јј! %
.
јј% &
m_TilingRules
јј& 3
;
јј3 4
var
ЅЅ 
	rulesJson
ЅЅ 
=
ЅЅ 
EditorJsonUtility
ЅЅ -
.
ЅЅ- .
ToJson
ЅЅ. 4
(
ЅЅ4 5
rulesWrapper
ЅЅ5 A
)
ЅЅA B
;
ЅЅB C
EditorGUIUtility
ѕѕ 
.
ѕѕ 
systemCopyBuffer
ѕѕ -
=
ѕѕ. /
	rulesJson
ѕѕ0 9
;
ѕѕ9 :
}
її 	
[
ББ 	
MenuItem
ББ	 
(
ББ 
$str
ББ 0
)
ББ0 1
]
ББ1 2
private
ВВ 
static
ВВ 
void
ВВ 

PasteRules
ВВ &
(
ВВ& '
MenuCommand
ВВ' 2
item
ВВ3 7
)
ВВ7 8
{
ГГ 	
RuleTile
ДД 
tile
ДД 
=
ДД 
item
ДД  
.
ДД  !
context
ДД! (
as
ДД) +
RuleTile
ДД, 4
;
ДД4 5
if
ЕЕ 
(
ЕЕ 
tile
ЕЕ 
==
ЕЕ 
null
ЕЕ 
)
ЕЕ 
return
ЖЖ 
;
ЖЖ 
try
ИИ 
{
ЙЙ !
RuleTileRuleWrapper
КК #
rulesWrapper
КК$ 0
=
КК1 2
new
КК3 6!
RuleTileRuleWrapper
КК7 J
(
ККJ K
)
ККK L
;
ККL M
EditorJsonUtility
ЛЛ !
.
ЛЛ! "
FromJsonOverwrite
ЛЛ" 3
(
ЛЛ3 4
EditorGUIUtility
ЛЛ4 D
.
ЛЛD E
systemCopyBuffer
ЛЛE U
,
ЛЛU V
rulesWrapper
ЛЛW c
)
ЛЛc d
;
ЛЛd e
tile
ММ 
.
ММ 
m_TilingRules
ММ "
.
ММ" #
AddRange
ММ# +
(
ММ+ ,
rulesWrapper
ММ, 8
.
ММ8 9
rules
ММ9 >
)
ММ> ?
;
ММ? @
}
НН 
catch
ОО 
(
ОО 
	Exception
ОО 
)
ОО 
{
ПП 
Debug
РР 
.
РР 
LogError
РР 
(
РР 
$str
РР N
)
РРN O
;
РРO P
}
СС 
}
ТТ 	
}
УУ 
}ФФ 